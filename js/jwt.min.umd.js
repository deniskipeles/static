(function(d,a){typeof exports=="object"&&typeof module!="undefined"?module.exports=a():typeof define=="function"&&define.amd?define(a):(d=typeof globalThis!="undefined"?globalThis:d||self,d.jwt=a())})(this,function(){"use strict";var Ae=Object.defineProperty,Te=Object.defineProperties;var Re=Object.getOwnPropertyDescriptors;var B=Object.getOwnPropertySymbols;var _e=Object.prototype.hasOwnProperty,Ce=Object.prototype.propertyIsEnumerable;var X=(d,a,c)=>a in d?Ae(d,a,{enumerable:!0,configurable:!0,writable:!0,value:c}):d[a]=c,R=(d,a)=>{for(var c in a||(a={}))_e.call(a,c)&&X(d,c,a[c]);if(B)for(var c of B(a))Ce.call(a,c)&&X(d,c,a[c]);return d},W=(d,a)=>Te(d,Re(a));var _=(d,a,c)=>new Promise((A,v)=>{var O=f=>{try{p(c.next(f))}catch(T){v(T)}},C=f=>{try{p(c.throw(f))}catch(T){v(T)}},p=f=>f.done?A(f.value):Promise.resolve(f.value).then(O,C);p((c=c.apply(d,a)).next())});const d=crypto,a=e=>e instanceof CryptoKey,c=new TextEncoder,A=new TextDecoder;function v(...e){const t=e.reduce((o,{length:s})=>o+s,0),r=new Uint8Array(t);let n=0;for(const o of e)r.set(o,n),n+=o.length;return r}const O=e=>{const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r},C=e=>{let t=e;t instanceof Uint8Array&&(t=A.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return O(t)}catch(r){throw new TypeError("The input to be decoded is not correctly encoded.")}};class p extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(t){var r;super(t),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(r=Error.captureStackTrace)==null||r.call(Error,this,this.constructor)}}class f extends p{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(t,r="unspecified",n="unspecified"){super(t),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=r,this.reason=n}}class T extends p{static get code(){return"ERR_JWT_EXPIRED"}constructor(t,r="unspecified",n="unspecified"){super(t),this.code="ERR_JWT_EXPIRED",this.claim=r,this.reason=n}}class j extends p{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class L extends p{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class u extends p{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class D extends p{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class Q extends p{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}function w(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function J(e,t){return e.name===t}function x(e){return parseInt(e.name.slice(4),10)}function Y(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function Z(e,t){if(t.length&&!t.some(r=>e.usages.includes(r))){let r="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const n=t.pop();r+=`one of ${t.join(", ")}, or ${n}.`}else t.length===2?r+=`one of ${t[0]} or ${t[1]}.`:r+=`${t[0]}.`;throw new TypeError(r)}}function ee(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!J(e.algorithm,"HMAC"))throw w("HMAC");const n=parseInt(t.slice(2),10);if(x(e.algorithm.hash)!==n)throw w(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!J(e.algorithm,"RSASSA-PKCS1-v1_5"))throw w("RSASSA-PKCS1-v1_5");const n=parseInt(t.slice(2),10);if(x(e.algorithm.hash)!==n)throw w(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!J(e.algorithm,"RSA-PSS"))throw w("RSA-PSS");const n=parseInt(t.slice(2),10);if(x(e.algorithm.hash)!==n)throw w(`SHA-${n}`,"algorithm.hash");break}case"EdDSA":{if(e.algorithm.name!=="Ed25519"&&e.algorithm.name!=="Ed448")throw w("Ed25519 or Ed448");break}case"ES256":case"ES384":case"ES512":{if(!J(e.algorithm,"ECDSA"))throw w("ECDSA");const n=Y(t);if(e.algorithm.namedCurve!==n)throw w(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}Z(e,r)}function N(e,t,...r){var n;if(r.length>2){const o=r.pop();e+=`one of type ${r.join(", ")}, or ${o}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&(n=t.constructor)!=null&&n.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const U=(e,...t)=>N("Key must be ",e,...t);function K(e,t,...r){return N(`Key for the ${e} algorithm must be `,t,...r)}const M=e=>a(e),b=["CryptoKey"],te=(...e)=>{const t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(const n of t){const o=Object.keys(n);if(!r||r.size===0){r=new Set(o);continue}for(const s of o){if(r.has(s))return!1;r.add(s)}}return!0};function re(e){return typeof e=="object"&&e!==null}function $(e){if(!re(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}const ne=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}},oe=(e,t)=>{if(!(t instanceof Uint8Array)){if(!M(t))throw new TypeError(K(e,t,...b,"Uint8Array"));if(t.type!=="secret")throw new TypeError(`${b.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}},ie=(e,t,r)=>{if(!M(t))throw new TypeError(K(e,t,...b));if(t.type==="secret")throw new TypeError(`${b.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if(t.algorithm&&r==="verify"&&t.type==="private")throw new TypeError(`${b.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&r==="encrypt"&&t.type==="private")throw new TypeError(`${b.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)},ae=(e,t,r)=>{e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?oe(e,t):ie(e,t,r)};function ce(e,t,r,n,o){if(o.crit!==void 0&&(n==null?void 0:n.crit)===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(i=>typeof i!="string"||i.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let s;r!==void 0?s=new Map([...Object.entries(r),...t.entries()]):s=t;for(const i of n.crit){if(!s.has(i))throw new L(`Extension Header Parameter "${i}" is not recognized`);if(o[i]===void 0)throw new e(`Extension Header Parameter "${i}" is missing`);if(s.get(i)&&n[i]===void 0)throw new e(`Extension Header Parameter "${i}" MUST be integrity protected`)}return new Set(n.crit)}const se=(e,t)=>{if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};function de(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new L(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function fe(e,t,r){if(a(t))return ee(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(U(t,...b));return d.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(U(t,...b,"Uint8Array"))}const ue=(e,t,r,n)=>_(this,null,function*(){const o=yield fe(e,t,"verify");ne(e,o);const s=de(e,o.algorithm);try{return yield d.subtle.verify(s,o,r,n)}catch(i){return!1}});function he(e,t,r){return _(this,null,function*(){var P;if(!$(e))throw new u("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new u('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new u("JWS Protected Header incorrect type");if(e.payload===void 0)throw new u("JWS Payload missing");if(typeof e.signature!="string")throw new u("JWS Signature missing or incorrect type");if(e.header!==void 0&&!$(e.header))throw new u("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const I=C(e.protected);n=JSON.parse(A.decode(I))}catch(I){throw new u("JWS Protected Header is invalid")}if(!te(n,e.header))throw new u("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const o=R(R({},n),e.header),s=ce(u,new Map([["b64",!0]]),r==null?void 0:r.crit,n,o);let i=!0;if(s.has("b64")&&(i=n.b64,typeof i!="boolean"))throw new u('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:h}=o;if(typeof h!="string"||!h)throw new u('JWS "alg" (Algorithm) Header Parameter missing or invalid');const m=r&&se("algorithms",r.algorithms);if(m&&!m.has(h))throw new j('"alg" (Algorithm) Header Parameter value not allowed');if(i){if(typeof e.payload!="string")throw new u("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new u("JWS Payload must be a string or an Uint8Array instance");let S=!1;typeof t=="function"&&(t=yield t(n,e),S=!0),ae(h,t,"verify");const E=v(c.encode((P=e.protected)!=null?P:""),c.encode("."),typeof e.payload=="string"?c.encode(e.payload):e.payload);let y;try{y=C(e.signature)}catch(I){throw new u("Failed to base64url decode the signature")}if(!(yield ue(h,t,y,E)))throw new Q;let g;if(i)try{g=C(e.payload)}catch(I){throw new u("Failed to base64url decode the payload")}else typeof e.payload=="string"?g=c.encode(e.payload):g=e.payload;const l={payload:g};return e.protected!==void 0&&(l.protectedHeader=n),e.header!==void 0&&(l.unprotectedHeader=e.header),S?W(R({},l),{key:t}):l})}function le(e,t,r){return _(this,null,function*(){if(e instanceof Uint8Array&&(e=A.decode(e)),typeof e!="string")throw new u("Compact JWS must be a string or Uint8Array");const{0:n,1:o,2:s,length:i}=e.split(".");if(i!==3)throw new u("Invalid Compact JWS");const h=yield he({payload:o,protected:n,signature:s},t,r),m={payload:h.payload,protectedHeader:h.protectedHeader};return typeof t=="function"?W(R({},m),{key:h.key}):m})}const pe=e=>Math.floor(e.getTime()/1e3),k=60,F=k*60,H=F*24,me=H*7,ye=H*365.25,we=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,V=e=>{const t=we.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]),n=t[3].toLowerCase();let o;switch(n){case"sec":case"secs":case"second":case"seconds":case"s":o=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":o=Math.round(r*k);break;case"hour":case"hours":case"hr":case"hrs":case"h":o=Math.round(r*F);break;case"day":case"days":case"d":o=Math.round(r*H);break;case"week":case"weeks":case"w":o=Math.round(r*me);break;default:o=Math.round(r*ye);break}return t[1]==="-"||t[4]==="ago"?-o:o},G=e=>e.toLowerCase().replace(/^application\//,""),Se=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):!1,be=(e,t,r={})=>{const{typ:n}=r;if(n&&(typeof e.typ!="string"||G(e.typ)!==G(n)))throw new f('unexpected "typ" JWT header value',"typ","check_failed");let o;try{o=JSON.parse(A.decode(t))}catch(l){}if(!$(o))throw new D("JWT Claims Set must be a top-level JSON object");const{requiredClaims:s=[],issuer:i,subject:h,audience:m,maxTokenAge:S}=r,E=[...s];S!==void 0&&E.push("iat"),m!==void 0&&E.push("aud"),h!==void 0&&E.push("sub"),i!==void 0&&E.push("iss");for(const l of new Set(E.reverse()))if(!(l in o))throw new f(`missing required "${l}" claim`,l,"missing");if(i&&!(Array.isArray(i)?i:[i]).includes(o.iss))throw new f('unexpected "iss" claim value',"iss","check_failed");if(h&&o.sub!==h)throw new f('unexpected "sub" claim value',"sub","check_failed");if(m&&!Se(o.aud,typeof m=="string"?[m]:m))throw new f('unexpected "aud" claim value',"aud","check_failed");let y;switch(typeof r.clockTolerance){case"string":y=V(r.clockTolerance);break;case"number":y=r.clockTolerance;break;case"undefined":y=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:z}=r,g=pe(z||new Date);if((o.iat!==void 0||S)&&typeof o.iat!="number")throw new f('"iat" claim must be a number',"iat","invalid");if(o.nbf!==void 0){if(typeof o.nbf!="number")throw new f('"nbf" claim must be a number',"nbf","invalid");if(o.nbf>g+y)throw new f('"nbf" claim timestamp check failed',"nbf","check_failed")}if(o.exp!==void 0){if(typeof o.exp!="number")throw new f('"exp" claim must be a number',"exp","invalid");if(o.exp<=g-y)throw new T('"exp" claim timestamp check failed',"exp","check_failed")}if(S){const l=g-o.iat,P=typeof S=="number"?S:V(S);if(l-y>P)throw new T('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(l<0-y)throw new f('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return o};function ge(e,t,r){return _(this,null,function*(){var i;const n=yield le(e,t,r);if((i=n.protectedHeader.crit)!=null&&i.includes("b64")&&n.protectedHeader.b64===!1)throw new D("JWTs MUST NOT use unencoded payload");const s={payload:be(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return typeof t=="function"?W(R({},s),{key:n.key}):s})}const q=new TextEncoder().encode("cc7e0d44fd473002f1c42167459001140ec6389b7353f8088f4d9a95f2f596f2"),Ee="HS256";return{sign:e=>new jose.SignJWT(e).setProtectedHeader({alg:Ee}).setIssuedAt().setIssuer("https://FreeCodeCamp.org").setAudience("https://FreeCodeCamp.org").setExpirationTime("2h").sign(q),verify:e=>_(this,null,function*(){const{payload:t,protectedHeader:r}=yield ge(e,q,{issuer:"https://FreeCodeCamp.org",audience:"https://FreeCodeCamp.org"});return t})}});
