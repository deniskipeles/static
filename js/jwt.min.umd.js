(function(h,f){typeof exports=="object"&&typeof module!="undefined"?module.exports=f():typeof define=="function"&&define.amd?define(f):(h=typeof globalThis!="undefined"?globalThis:h||self,h.jwt=f())})(this,function(){"use strict";var ve=Object.defineProperty,Ie=Object.defineProperties;var We=Object.getOwnPropertyDescriptors;var oe=Object.getOwnPropertySymbols;var xe=Object.prototype.hasOwnProperty,Oe=Object.prototype.propertyIsEnumerable;var ae=(h,f,i)=>f in h?ve(h,f,{enumerable:!0,configurable:!0,writable:!0,value:i}):h[f]=i,d=(h,f)=>{for(var i in f||(f={}))xe.call(f,i)&&ae(h,i,f[i]);if(oe)for(var i of oe(f))Oe.call(f,i)&&ae(h,i,f[i]);return h},u=(h,f)=>Ie(h,We(f));var E=(h,f,i)=>new Promise((H,P)=>{var U=w=>{try{I(i.next(w))}catch(b){P(b)}},v=w=>{try{I(i.throw(w))}catch(b){P(b)}},I=w=>w.done?H(w.value):Promise.resolve(w.value).then(U,v);I((i=i.apply(h,f)).next())});const h=crypto,f=t=>t instanceof CryptoKey,i=new TextEncoder,H=new TextDecoder;function P(...t){const e=t.reduce((o,{length:s})=>o+s,0),r=new Uint8Array(e);let n=0;for(const o of t)r.set(o,n),n+=o.length;return r}const U=t=>{let e=t;typeof e=="string"&&(e=i.encode(e));const r=32768,n=[];for(let o=0;o<e.length;o+=r)n.push(String.fromCharCode.apply(null,e.subarray(o,o+r)));return btoa(n.join(""))},v=t=>U(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),I=t=>{const e=atob(t),r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r},w=t=>{let e=t;e instanceof Uint8Array&&(e=H.decode(e)),e=e.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return I(e)}catch(r){throw new TypeError("The input to be decoded is not correctly encoded.")}};class b extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){var r;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(r=Error.captureStackTrace)==null||r.call(Error,this,this.constructor)}}class g extends b{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(e,r="unspecified",n="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=r,this.reason=n}}class M extends b{static get code(){return"ERR_JWT_EXPIRED"}constructor(e,r="unspecified",n="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=r,this.reason=n}}class ie extends b{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class F extends b{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class c extends b{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class N extends b{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class se extends b{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}function A(t,e="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${e} must be ${t}`)}function x(t,e){return t.name===e}function L(t){return parseInt(t.name.slice(4),10)}function ce(t){switch(t){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function de(t,e){if(e.length&&!e.some(r=>t.usages.includes(r))){let r="CryptoKey does not support this operation, its usages must include ";if(e.length>2){const n=e.pop();r+=`one of ${e.join(", ")}, or ${n}.`}else e.length===2?r+=`one of ${e[0]} or ${e[1]}.`:r+=`${e[0]}.`;throw new TypeError(r)}}function fe(t,e,...r){switch(e){case"HS256":case"HS384":case"HS512":{if(!x(t.algorithm,"HMAC"))throw A("HMAC");const n=parseInt(e.slice(2),10);if(L(t.algorithm.hash)!==n)throw A(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!x(t.algorithm,"RSASSA-PKCS1-v1_5"))throw A("RSASSA-PKCS1-v1_5");const n=parseInt(e.slice(2),10);if(L(t.algorithm.hash)!==n)throw A(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!x(t.algorithm,"RSA-PSS"))throw A("RSA-PSS");const n=parseInt(e.slice(2),10);if(L(t.algorithm.hash)!==n)throw A(`SHA-${n}`,"algorithm.hash");break}case"EdDSA":{if(t.algorithm.name!=="Ed25519"&&t.algorithm.name!=="Ed448")throw A("Ed25519 or Ed448");break}case"ES256":case"ES384":case"ES512":{if(!x(t.algorithm,"ECDSA"))throw A("ECDSA");const n=ce(e);if(t.algorithm.namedCurve!==n)throw A(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}de(t,r)}function k(t,e,...r){var n;if(r.length>2){const o=r.pop();t+=`one of type ${r.join(", ")}, or ${o}.`}else r.length===2?t+=`one of type ${r[0]} or ${r[1]}.`:t+=`of type ${r[0]}.`;return e==null?t+=` Received ${e}`:typeof e=="function"&&e.name?t+=` Received function ${e.name}`:typeof e=="object"&&e!=null&&(n=e.constructor)!=null&&n.name&&(t+=` Received an instance of ${e.constructor.name}`),t}const V=(t,...e)=>k("Key must be ",t,...e);function j(t,e,...r){return k(`Key for the ${t} algorithm must be `,e,...r)}const G=t=>f(t),_=["CryptoKey"],B=(...t)=>{const e=t.filter(Boolean);if(e.length===0||e.length===1)return!0;let r;for(const n of e){const o=Object.keys(n);if(!r||r.size===0){r=new Set(o);continue}for(const s of o){if(r.has(s))return!1;r.add(s)}}return!0};function he(t){return typeof t=="object"&&t!==null}function O(t){if(!he(t)||Object.prototype.toString.call(t)!=="[object Object]")return!1;if(Object.getPrototypeOf(t)===null)return!0;let e=t;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(t)===e}const q=(t,e)=>{if(t.startsWith("RS")||t.startsWith("PS")){const{modulusLength:r}=e.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${t} requires key modulusLength to be 2048 bits or larger`)}},le=(t,e)=>{if(!(e instanceof Uint8Array)){if(!G(e))throw new TypeError(j(t,e,..._,"Uint8Array"));if(e.type!=="secret")throw new TypeError(`${_.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}},ue=(t,e,r)=>{if(!G(e))throw new TypeError(j(t,e,..._));if(e.type==="secret")throw new TypeError(`${_.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if(r==="sign"&&e.type==="public")throw new TypeError(`${_.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if(r==="decrypt"&&e.type==="public")throw new TypeError(`${_.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(e.algorithm&&r==="verify"&&e.type==="private")throw new TypeError(`${_.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(e.algorithm&&r==="encrypt"&&e.type==="private")throw new TypeError(`${_.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)},z=(t,e,r)=>{t.startsWith("HS")||t==="dir"||t.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(t)?le(t,e):ue(t,e,r)};function X(t,e,r,n,o){if(o.crit!==void 0&&(n==null?void 0:n.crit)===void 0)throw new t('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(a=>typeof a!="string"||a.length===0))throw new t('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let s;r!==void 0?s=new Map([...Object.entries(r),...e.entries()]):s=e;for(const a of n.crit){if(!s.has(a))throw new F(`Extension Header Parameter "${a}" is not recognized`);if(o[a]===void 0)throw new t(`Extension Header Parameter "${a}" is missing`);if(s.get(a)&&n[a]===void 0)throw new t(`Extension Header Parameter "${a}" MUST be integrity protected`)}return new Set(n.crit)}const pe=(t,e)=>{if(e!==void 0&&(!Array.isArray(e)||e.some(r=>typeof r!="string")))throw new TypeError(`"${t}" option must be an array of strings`);if(e)return new Set(e)};function Z(t,e){const r=`SHA-${t.slice(-3)}`;switch(t){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:t.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:e.namedCurve};case"EdDSA":return{name:e.name};default:throw new F(`alg ${t} is not supported either by JOSE or your javascript runtime`)}}function Q(t,e,r){if(f(e))return fe(e,t,r),e;if(e instanceof Uint8Array){if(!t.startsWith("HS"))throw new TypeError(V(e,..._));return h.subtle.importKey("raw",e,{hash:`SHA-${t.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(V(e,..._,"Uint8Array"))}const ye=(t,e,r,n)=>E(this,null,function*(){const o=yield Q(t,e,"verify");q(t,o);const s=Z(t,o.algorithm);try{return yield h.subtle.verify(s,o,r,n)}catch(a){return!1}});function me(t,e,r){return E(this,null,function*(){var $;if(!O(t))throw new c("Flattened JWS must be an object");if(t.protected===void 0&&t.header===void 0)throw new c('Flattened JWS must have either of the "protected" or "header" members');if(t.protected!==void 0&&typeof t.protected!="string")throw new c("JWS Protected Header incorrect type");if(t.payload===void 0)throw new c("JWS Payload missing");if(typeof t.signature!="string")throw new c("JWS Signature missing or incorrect type");if(t.header!==void 0&&!O(t.header))throw new c("JWS Unprotected Header incorrect type");let n={};if(t.protected)try{const D=w(t.protected);n=JSON.parse(H.decode(D))}catch(D){throw new c("JWS Protected Header is invalid")}if(!B(n,t.header))throw new c("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const o=d(d({},n),t.header),s=X(c,new Map([["b64",!0]]),r==null?void 0:r.crit,n,o);let a=!0;if(s.has("b64")&&(a=n.b64,typeof a!="boolean"))throw new c('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:l}=o;if(typeof l!="string"||!l)throw new c('JWS "alg" (Algorithm) Header Parameter missing or invalid');const p=r&&pe("algorithms",r.algorithms);if(p&&!p.has(l))throw new ie('"alg" (Algorithm) Header Parameter value not allowed');if(a){if(typeof t.payload!="string")throw new c("JWS Payload must be a string")}else if(typeof t.payload!="string"&&!(t.payload instanceof Uint8Array))throw new c("JWS Payload must be a string or an Uint8Array instance");let S=!1;typeof e=="function"&&(e=yield e(n,t),S=!0),z(l,e,"verify");const T=P(i.encode(($=t.protected)!=null?$:""),i.encode("."),typeof t.payload=="string"?i.encode(t.payload):t.payload);let y;try{y=w(t.signature)}catch(D){throw new c("Failed to base64url decode the signature")}if(!(yield ye(l,e,y,T)))throw new se;let C;if(a)try{C=w(t.payload)}catch(D){throw new c("Failed to base64url decode the payload")}else typeof t.payload=="string"?C=i.encode(t.payload):C=t.payload;const m={payload:C};return t.protected!==void 0&&(m.protectedHeader=n),t.header!==void 0&&(m.unprotectedHeader=t.header),S?u(d({},m),{key:e}):m})}function we(t,e,r){return E(this,null,function*(){if(t instanceof Uint8Array&&(t=H.decode(t)),typeof t!="string")throw new c("Compact JWS must be a string or Uint8Array");const{0:n,1:o,2:s,length:a}=t.split(".");if(a!==3)throw new c("Invalid Compact JWS");const l=yield me({payload:o,protected:n,signature:s},e,r),p={payload:l.payload,protectedHeader:l.protectedHeader};return typeof e=="function"?u(d({},p),{key:l.key}):p})}const R=t=>Math.floor(t.getTime()/1e3),Y=60,ee=Y*60,K=ee*24,be=K*7,Se=K*365.25,ge=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,W=t=>{const e=ge.exec(t);if(!e||e[4]&&e[1])throw new TypeError("Invalid time period format");const r=parseFloat(e[2]),n=e[3].toLowerCase();let o;switch(n){case"sec":case"secs":case"second":case"seconds":case"s":o=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":o=Math.round(r*Y);break;case"hour":case"hours":case"hr":case"hrs":case"h":o=Math.round(r*ee);break;case"day":case"days":case"d":o=Math.round(r*K);break;case"week":case"weeks":case"w":o=Math.round(r*be);break;default:o=Math.round(r*Se);break}return e[1]==="-"||e[4]==="ago"?-o:o},te=t=>t.toLowerCase().replace(/^application\//,""),_e=(t,e)=>typeof t=="string"?e.includes(t):Array.isArray(t)?e.some(Set.prototype.has.bind(new Set(t))):!1,Ee=(t,e,r={})=>{const{typ:n}=r;if(n&&(typeof t.typ!="string"||te(t.typ)!==te(n)))throw new g('unexpected "typ" JWT header value',"typ","check_failed");let o;try{o=JSON.parse(H.decode(e))}catch(m){}if(!O(o))throw new N("JWT Claims Set must be a top-level JSON object");const{requiredClaims:s=[],issuer:a,subject:l,audience:p,maxTokenAge:S}=r,T=[...s];S!==void 0&&T.push("iat"),p!==void 0&&T.push("aud"),l!==void 0&&T.push("sub"),a!==void 0&&T.push("iss");for(const m of new Set(T.reverse()))if(!(m in o))throw new g(`missing required "${m}" claim`,m,"missing");if(a&&!(Array.isArray(a)?a:[a]).includes(o.iss))throw new g('unexpected "iss" claim value',"iss","check_failed");if(l&&o.sub!==l)throw new g('unexpected "sub" claim value',"sub","check_failed");if(p&&!_e(o.aud,typeof p=="string"?[p]:p))throw new g('unexpected "aud" claim value',"aud","check_failed");let y;switch(typeof r.clockTolerance){case"string":y=W(r.clockTolerance);break;case"number":y=r.clockTolerance;break;case"undefined":y=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:ne}=r,C=R(ne||new Date);if((o.iat!==void 0||S)&&typeof o.iat!="number")throw new g('"iat" claim must be a number',"iat","invalid");if(o.nbf!==void 0){if(typeof o.nbf!="number")throw new g('"nbf" claim must be a number',"nbf","invalid");if(o.nbf>C+y)throw new g('"nbf" claim timestamp check failed',"nbf","check_failed")}if(o.exp!==void 0){if(typeof o.exp!="number")throw new g('"exp" claim must be a number',"exp","invalid");if(o.exp<=C-y)throw new M('"exp" claim timestamp check failed',"exp","check_failed")}if(S){const m=C-o.iat,$=typeof S=="number"?S:W(S);if(m-y>$)throw new M('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(m<0-y)throw new g('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return o};function Ae(t,e,r){return E(this,null,function*(){var a;const n=yield we(t,e,r);if((a=n.protectedHeader.crit)!=null&&a.includes("b64")&&n.protectedHeader.b64===!1)throw new N("JWTs MUST NOT use unencoded payload");const s={payload:Ee(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return typeof e=="function"?u(d({},s),{key:n.key}):s})}const Te=(t,e,r)=>E(this,null,function*(){const n=yield Q(t,e,"sign");q(t,n);const o=yield h.subtle.sign(Z(t,n.algorithm),n,r);return new Uint8Array(o)});class He{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}sign(e,r){return E(this,null,function*(){if(!this._protectedHeader&&!this._unprotectedHeader)throw new c("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!B(this._protectedHeader,this._unprotectedHeader))throw new c("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const n=d(d({},this._protectedHeader),this._unprotectedHeader),o=X(c,new Map([["b64",!0]]),r==null?void 0:r.crit,this._protectedHeader,n);let s=!0;if(o.has("b64")&&(s=this._protectedHeader.b64,typeof s!="boolean"))throw new c('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:a}=n;if(typeof a!="string"||!a)throw new c('JWS "alg" (Algorithm) Header Parameter missing or invalid');z(a,e,"sign");let l=this._payload;s&&(l=i.encode(v(l)));let p;this._protectedHeader?p=i.encode(v(JSON.stringify(this._protectedHeader))):p=i.encode("");const S=P(p,i.encode("."),l),T=yield Te(a,e,S),y={signature:v(T),payload:""};return s&&(y.payload=H.decode(l)),this._unprotectedHeader&&(y.header=this._unprotectedHeader),this._protectedHeader&&(y.protected=H.decode(p)),y})}}class Re{constructor(e){this._flattened=new He(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}sign(e,r){return E(this,null,function*(){const n=yield this._flattened.sign(e,r);if(n.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${n.protected}.${n.payload}.${n.signature}`})}}function J(t,e){if(!Number.isFinite(e))throw new TypeError(`Invalid ${t} input`);return e}class Ce{constructor(e={}){if(!O(e))throw new TypeError("JWT Claims Set MUST be an object");this._payload=e}setIssuer(e){return this._payload=u(d({},this._payload),{iss:e}),this}setSubject(e){return this._payload=u(d({},this._payload),{sub:e}),this}setAudience(e){return this._payload=u(d({},this._payload),{aud:e}),this}setJti(e){return this._payload=u(d({},this._payload),{jti:e}),this}setNotBefore(e){return typeof e=="number"?this._payload=u(d({},this._payload),{nbf:J("setNotBefore",e)}):e instanceof Date?this._payload=u(d({},this._payload),{nbf:J("setNotBefore",R(e))}):this._payload=u(d({},this._payload),{nbf:R(new Date)+W(e)}),this}setExpirationTime(e){return typeof e=="number"?this._payload=u(d({},this._payload),{exp:J("setExpirationTime",e)}):e instanceof Date?this._payload=u(d({},this._payload),{exp:J("setExpirationTime",R(e))}):this._payload=u(d({},this._payload),{exp:R(new Date)+W(e)}),this}setIssuedAt(e){return typeof e=="undefined"?this._payload=u(d({},this._payload),{iat:R(new Date)}):e instanceof Date?this._payload=u(d({},this._payload),{iat:J("setIssuedAt",R(e))}):typeof e=="string"?this._payload=u(d({},this._payload),{iat:J("setIssuedAt",R(new Date)+W(e))}):this._payload=u(d({},this._payload),{iat:J("setIssuedAt",e)}),this}}class Je extends Ce{setProtectedHeader(e){return this._protectedHeader=e,this}sign(e,r){return E(this,null,function*(){var o;const n=new Re(i.encode(JSON.stringify(this._payload)));if(n.setProtectedHeader(this._protectedHeader),Array.isArray((o=this._protectedHeader)==null?void 0:o.crit)&&this._protectedHeader.crit.includes("b64")&&this._protectedHeader.b64===!1)throw new N("JWTs MUST NOT use unencoded payload");return n.sign(e,r)})}}const re=new TextEncoder().encode("cc7e0d44fd473002f1c42167459001140ec6389b7353f8088f4d9a95f2f596f2"),Pe="HS256";return{sign:t=>new Je(t).setProtectedHeader({alg:Pe}).setIssuedAt().setIssuer("https://FreeCodeCamp.org").setAudience("https://FreeCodeCamp.org").setExpirationTime("2h").sign(re),verify:t=>E(this,null,function*(){const{payload:e,protectedHeader:r}=yield Ae(t,re,{issuer:"https://FreeCodeCamp.org",audience:"https://FreeCodeCamp.org"});return e})}});
