(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.firebase=f()}})((function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,(function(r){var n=e[i][1][r];return o(n||r)}),p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r}()({1:[function(require,module,exports){var process=module.exports={};var cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}(function(){try{if(typeof setTimeout==="function"){cachedSetTimeout=setTimeout}else{cachedSetTimeout=defaultSetTimout}}catch(e){cachedSetTimeout=defaultSetTimout}try{if(typeof clearTimeout==="function"){cachedClearTimeout=clearTimeout}else{cachedClearTimeout=defaultClearTimeout}}catch(e){cachedClearTimeout=defaultClearTimeout}})();function runTimeout(fun){if(cachedSetTimeout===setTimeout){return setTimeout(fun,0)}if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0)}try{return cachedSetTimeout(fun,0)}catch(e){try{return cachedSetTimeout.call(null,fun,0)}catch(e){return cachedSetTimeout.call(this,fun,0)}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){return clearTimeout(marker)}if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker)}try{return cachedClearTimeout(marker)}catch(e){try{return cachedClearTimeout.call(null,marker)}catch(e){return cachedClearTimeout.call(this,marker)}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue)}else{queueIndex=-1}if(queue.length){drainQueue()}}function drainQueue(){if(draining){return}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run()}}queueIndex=-1;len=queue.length}currentQueue=null;draining=false;runClearTimeout(timeout)}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i]}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue)}};function Item(fun,array){this.fun=fun;this.array=array}Item.prototype.run=function(){this.fun.apply(null,this.array)};process.title="browser";process.browser=true;process.env={};process.argv=[];process.version="";process.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.prependListener=noop;process.prependOnceListener=noop;process.listeners=function(name){return[]};process.binding=function(name){throw new Error("process.binding is not supported")};process.cwd=function(){return"/"};process.chdir=function(dir){throw new Error("process.chdir is not supported")};process.umask=function(){return 0}},{}],2:[function(require,module,exports){const firebase=require("firebase/compat/app").default;require("firebase/compat/database");require("firebase/compat/auth");module.exports=firebase},{"firebase/compat/app":13,"firebase/compat/auth":14,"firebase/compat/database":15}],3:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.default=void 0;var _util=require("@firebase/util");var _component=require("@firebase/component");var modularAPIs=_interopRequireWildcard(require("@firebase/app"));var _logger=require("@firebase/logger");function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!=="function")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!=="object"&&typeof obj!=="function"){return{default:obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!=="default"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class FirebaseAppImpl{constructor(_delegate,firebase){this._delegate=_delegate;this.firebase=firebase;(0,modularAPIs._addComponent)(_delegate,new _component.Component("app-compat",(()=>this),"PUBLIC"));this.container=_delegate.container}get automaticDataCollectionEnabled(){return this._delegate.automaticDataCollectionEnabled}set automaticDataCollectionEnabled(val){this._delegate.automaticDataCollectionEnabled=val}get name(){return this._delegate.name}get options(){return this._delegate.options}delete(){return new Promise((resolve=>{this._delegate.checkDestroyed();resolve()})).then((()=>{this.firebase.INTERNAL.removeApp(this.name);return(0,modularAPIs.deleteApp)(this._delegate)}))}_getService(name,instanceIdentifier=modularAPIs._DEFAULT_ENTRY_NAME){var _a;this._delegate.checkDestroyed();const provider=this._delegate.container.getProvider(name);if(!provider.isInitialized()&&((_a=provider.getComponent())===null||_a===void 0?void 0:_a.instantiationMode)==="EXPLICIT"){provider.initialize()}return provider.getImmediate({identifier:instanceIdentifier})}_removeServiceInstance(name,instanceIdentifier=modularAPIs._DEFAULT_ENTRY_NAME){this._delegate.container.getProvider(name).clearInstance(instanceIdentifier)}_addComponent(component){(0,modularAPIs._addComponent)(this._delegate,component)}_addOrOverwriteComponent(component){(0,modularAPIs._addOrOverwriteComponent)(this._delegate,component)}toJSON(){return{name:this.name,automaticDataCollectionEnabled:this.automaticDataCollectionEnabled,options:this.options}}}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ERRORS={["no-app"]:"No Firebase App '{$appName}' has been created - "+"call Firebase App.initializeApp()",["invalid-app-argument"]:"firebase.{$appName}() takes either no argument or a "+"Firebase App instance."};const ERROR_FACTORY=new _util.ErrorFactory("app-compat","Firebase",ERRORS);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function createFirebaseNamespaceCore(firebaseAppImpl){const apps={};const namespace={__esModule:true,initializeApp:initializeAppCompat,app:app,registerVersion:modularAPIs.registerVersion,setLogLevel:modularAPIs.setLogLevel,onLog:modularAPIs.onLog,apps:null,SDK_VERSION:modularAPIs.SDK_VERSION,INTERNAL:{registerComponent:registerComponentCompat,removeApp:removeApp,useAsService:useAsService,modularAPIs:modularAPIs}};namespace["default"]=namespace;Object.defineProperty(namespace,"apps",{get:getApps});function removeApp(name){delete apps[name]}function app(name){name=name||modularAPIs._DEFAULT_ENTRY_NAME;if(!(0,_util.contains)(apps,name)){throw ERROR_FACTORY.create("no-app",{appName:name})}return apps[name]}app["App"]=firebaseAppImpl;function initializeAppCompat(options,rawConfig={}){const app=modularAPIs.initializeApp(options,rawConfig);if((0,_util.contains)(apps,app.name)){return apps[app.name]}const appCompat=new firebaseAppImpl(app,namespace);apps[app.name]=appCompat;return appCompat}function getApps(){return Object.keys(apps).map((name=>apps[name]))}function registerComponentCompat(component){const componentName=component.name;const componentNameWithoutCompat=componentName.replace("-compat","");if(modularAPIs._registerComponent(component)&&component.type==="PUBLIC"){const serviceNamespace=(appArg=app())=>{if(typeof appArg[componentNameWithoutCompat]!=="function"){throw ERROR_FACTORY.create("invalid-app-argument",{appName:componentName})}return appArg[componentNameWithoutCompat]()};if(component.serviceProps!==undefined){(0,_util.deepExtend)(serviceNamespace,component.serviceProps)}namespace[componentNameWithoutCompat]=serviceNamespace;firebaseAppImpl.prototype[componentNameWithoutCompat]=function(...args){const serviceFxn=this._getService.bind(this,componentName);return serviceFxn.apply(this,component.multipleInstances?args:[])}}return component.type==="PUBLIC"?namespace[componentNameWithoutCompat]:null}function useAsService(app,name){if(name==="serverAuth"){return null}const useService=name;return useService}return namespace}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function createFirebaseNamespace(){const namespace=createFirebaseNamespaceCore(FirebaseAppImpl);namespace.INTERNAL=Object.assign(Object.assign({},namespace.INTERNAL),{createFirebaseNamespace:createFirebaseNamespace,extendNamespace:extendNamespace,createSubscribe:_util.createSubscribe,ErrorFactory:_util.ErrorFactory,deepExtend:_util.deepExtend});function extendNamespace(props){(0,_util.deepExtend)(namespace,props)}return namespace}const firebase$1=createFirebaseNamespace();
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const logger=new _logger.Logger("@firebase/app-compat");const name="@firebase/app-compat";const version="0.2.32";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function registerCoreComponents(variant){(0,modularAPIs.registerVersion)(name,version,variant)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */if((0,_util.isBrowser)()&&self.firebase!==undefined){logger.warn(`\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  `);const sdkVersion=self.firebase.SDK_VERSION;if(sdkVersion&&sdkVersion.indexOf("LITE")>=0){logger.warn(`\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    `)}}const firebase=firebase$1;exports.default=firebase;registerCoreComponents()},{"@firebase/app":4,"@firebase/component":8,"@firebase/logger":11,"@firebase/util":12}],4:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});Object.defineProperty(exports,"FirebaseError",{enumerable:true,get:function(){return _util.FirebaseError}});exports._DEFAULT_ENTRY_NAME=exports.SDK_VERSION=void 0;exports._addComponent=_addComponent;exports._addOrOverwriteComponent=_addOrOverwriteComponent;exports._apps=void 0;exports._clearComponents=_clearComponents;exports._components=void 0;exports._getProvider=_getProvider;exports._isFirebaseApp=_isFirebaseApp;exports._isFirebaseServerApp=_isFirebaseServerApp;exports._registerComponent=_registerComponent;exports._removeServiceInstance=_removeServiceInstance;exports._serverApps=void 0;exports.deleteApp=deleteApp;exports.getApp=getApp;exports.getApps=getApps;exports.initializeApp=initializeApp;exports.initializeServerApp=initializeServerApp;exports.onLog=onLog;exports.registerVersion=registerVersion;exports.setLogLevel=setLogLevel;var _component=require("@firebase/component");var _logger=require("@firebase/logger");var _util=require("@firebase/util");var _idb=require("idb");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class PlatformLoggerServiceImpl{constructor(container){this.container=container}getPlatformInfoString(){const providers=this.container.getProviders();return providers.map((provider=>{if(isVersionServiceProvider(provider)){const service=provider.getImmediate();return`${service.library}/${service.version}`}else{return null}})).filter((logString=>logString)).join(" ")}}function isVersionServiceProvider(provider){const component=provider.getComponent();return(component===null||component===void 0?void 0:component.type)==="VERSION"}const name$o="@firebase/app";const version$1="0.10.2";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const logger=new _logger.Logger("@firebase/app");const name$n="@firebase/app-compat";const name$m="@firebase/analytics-compat";const name$l="@firebase/analytics";const name$k="@firebase/app-check-compat";const name$j="@firebase/app-check";const name$i="@firebase/auth";const name$h="@firebase/auth-compat";const name$g="@firebase/database";const name$f="@firebase/database-compat";const name$e="@firebase/functions";const name$d="@firebase/functions-compat";const name$c="@firebase/installations";const name$b="@firebase/installations-compat";const name$a="@firebase/messaging";const name$9="@firebase/messaging-compat";const name$8="@firebase/performance";const name$7="@firebase/performance-compat";const name$6="@firebase/remote-config";const name$5="@firebase/remote-config-compat";const name$4="@firebase/storage";const name$3="@firebase/storage-compat";const name$2="@firebase/firestore";const name$1="@firebase/firestore-compat";const name="firebase";const version="10.11.1";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const DEFAULT_ENTRY_NAME="[DEFAULT]";exports._DEFAULT_ENTRY_NAME=DEFAULT_ENTRY_NAME;const PLATFORM_LOG_STRING={[name$o]:"fire-core",[name$n]:"fire-core-compat",[name$l]:"fire-analytics",[name$m]:"fire-analytics-compat",[name$j]:"fire-app-check",[name$k]:"fire-app-check-compat",[name$i]:"fire-auth",[name$h]:"fire-auth-compat",[name$g]:"fire-rtdb",[name$f]:"fire-rtdb-compat",[name$e]:"fire-fn",[name$d]:"fire-fn-compat",[name$c]:"fire-iid",[name$b]:"fire-iid-compat",[name$a]:"fire-fcm",[name$9]:"fire-fcm-compat",[name$8]:"fire-perf",[name$7]:"fire-perf-compat",[name$6]:"fire-rc",[name$5]:"fire-rc-compat",[name$4]:"fire-gcs",[name$3]:"fire-gcs-compat",[name$2]:"fire-fst",[name$1]:"fire-fst-compat","fire-js":"fire-js",[name]:"fire-js-all"};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _apps=new Map;exports._apps=_apps;const _serverApps=new Map;exports._serverApps=_serverApps;const _components=new Map;exports._components=_components;function _addComponent(app,component){try{app.container.addComponent(component)}catch(e){logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`,e)}}function _addOrOverwriteComponent(app,component){app.container.addOrOverwriteComponent(component)}function _registerComponent(component){const componentName=component.name;if(_components.has(componentName)){logger.debug(`There were multiple attempts to register component ${componentName}.`);return false}_components.set(componentName,component);for(const app of _apps.values()){_addComponent(app,component)}for(const serverApp of _serverApps.values()){_addComponent(serverApp,component)}return true}function _getProvider(app,name){const heartbeatController=app.container.getProvider("heartbeat").getImmediate({optional:true});if(heartbeatController){void heartbeatController.triggerHeartbeat()}return app.container.getProvider(name)}function _removeServiceInstance(app,name,instanceIdentifier=DEFAULT_ENTRY_NAME){_getProvider(app,name).clearInstance(instanceIdentifier)}function _isFirebaseApp(obj){return obj.options!==undefined}function _isFirebaseServerApp(obj){return obj.settings!==undefined}function _clearComponents(){_components.clear()}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ERRORS={["no-app"]:"No Firebase App '{$appName}' has been created - "+"call initializeApp() first",["bad-app-name"]:"Illegal App name: '{$appName}'",["duplicate-app"]:"Firebase App named '{$appName}' already exists with different options or config",["app-deleted"]:"Firebase App named '{$appName}' already deleted",["server-app-deleted"]:"Firebase Server App has been deleted",["no-options"]:"Need to provide options, when not being deployed to hosting via source.",["invalid-app-argument"]:"firebase.{$appName}() takes either no argument or a "+"Firebase App instance.",["invalid-log-argument"]:"First argument to `onLog` must be null or a function.",["idb-open"]:"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",["idb-get"]:"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",["idb-set"]:"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",["idb-delete"]:"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",["finalization-registry-not-supported"]:"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",["invalid-server-app-environment"]:"FirebaseServerApp is not for use in browser environments."};const ERROR_FACTORY=new _util.ErrorFactory("app","Firebase",ERRORS);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class FirebaseAppImpl{constructor(options,config,container){this._isDeleted=false;this._options=Object.assign({},options);this._config=Object.assign({},config);this._name=config.name;this._automaticDataCollectionEnabled=config.automaticDataCollectionEnabled;this._container=container;this.container.addComponent(new _component.Component("app",(()=>this),"PUBLIC"))}get automaticDataCollectionEnabled(){this.checkDestroyed();return this._automaticDataCollectionEnabled}set automaticDataCollectionEnabled(val){this.checkDestroyed();this._automaticDataCollectionEnabled=val}get name(){this.checkDestroyed();return this._name}get options(){this.checkDestroyed();return this._options}get config(){this.checkDestroyed();return this._config}get container(){return this._container}get isDeleted(){return this._isDeleted}set isDeleted(val){this._isDeleted=val}checkDestroyed(){if(this.isDeleted){throw ERROR_FACTORY.create("app-deleted",{appName:this._name})}}}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class FirebaseServerAppImpl extends FirebaseAppImpl{constructor(options,serverConfig,name,container){const automaticDataCollectionEnabled=serverConfig.automaticDataCollectionEnabled!==undefined?serverConfig.automaticDataCollectionEnabled:false;const config={name:name,automaticDataCollectionEnabled:automaticDataCollectionEnabled};if(options.apiKey!==undefined){super(options,config,container)}else{const appImpl=options;super(appImpl.options,config,container)}this._serverConfig=Object.assign({automaticDataCollectionEnabled:automaticDataCollectionEnabled},serverConfig);this._finalizationRegistry=new FinalizationRegistry((()=>{this.automaticCleanup()}));this._refCount=0;this.incRefCount(this._serverConfig.releaseOnDeref);this._serverConfig.releaseOnDeref=undefined;serverConfig.releaseOnDeref=undefined;registerVersion(name$o,version$1,"serverapp")}toJSON(){return undefined}get refCount(){return this._refCount}incRefCount(obj){if(this.isDeleted){return}this._refCount++;if(obj!==undefined){this._finalizationRegistry.register(obj,this)}}decRefCount(){if(this.isDeleted){return 0}return--this._refCount}automaticCleanup(){void deleteApp(this)}get settings(){this.checkDestroyed();return this._serverConfig}checkDestroyed(){if(this.isDeleted){throw ERROR_FACTORY.create("server-app-deleted")}}}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const SDK_VERSION=version;exports.SDK_VERSION=SDK_VERSION;function initializeApp(_options,rawConfig={}){let options=_options;if(typeof rawConfig!=="object"){const name=rawConfig;rawConfig={name:name}}const config=Object.assign({name:DEFAULT_ENTRY_NAME,automaticDataCollectionEnabled:false},rawConfig);const name=config.name;if(typeof name!=="string"||!name){throw ERROR_FACTORY.create("bad-app-name",{appName:String(name)})}options||(options=(0,_util.getDefaultAppConfig)());if(!options){throw ERROR_FACTORY.create("no-options")}const existingApp=_apps.get(name);if(existingApp){if((0,_util.deepEqual)(options,existingApp.options)&&(0,_util.deepEqual)(config,existingApp.config)){return existingApp}else{throw ERROR_FACTORY.create("duplicate-app",{appName:name})}}const container=new _component.ComponentContainer(name);for(const component of _components.values()){container.addComponent(component)}const newApp=new FirebaseAppImpl(options,config,container);_apps.set(name,newApp);return newApp}function initializeServerApp(_options,_serverAppConfig){if((0,_util.isBrowser)()){throw ERROR_FACTORY.create("invalid-server-app-environment")}if(_serverAppConfig.automaticDataCollectionEnabled===undefined){_serverAppConfig.automaticDataCollectionEnabled=false}let appOptions;if(_isFirebaseApp(_options)){appOptions=_options.options}else{appOptions=_options}const nameObj=Object.assign(Object.assign({},_serverAppConfig),appOptions);if(nameObj.releaseOnDeref!==undefined){delete nameObj.releaseOnDeref}const hashCode=s=>[...s].reduce(((hash,c)=>Math.imul(31,hash)+c.charCodeAt(0)|0),0);if(_serverAppConfig.releaseOnDeref!==undefined){if(typeof FinalizationRegistry==="undefined"){throw ERROR_FACTORY.create("finalization-registry-not-supported",{})}}const nameString=""+hashCode(JSON.stringify(nameObj));const existingApp=_serverApps.get(nameString);if(existingApp){existingApp.incRefCount(_serverAppConfig.releaseOnDeref);return existingApp}const container=new _component.ComponentContainer(nameString);for(const component of _components.values()){container.addComponent(component)}const newApp=new FirebaseServerAppImpl(appOptions,_serverAppConfig,nameString,container);_serverApps.set(nameString,newApp);return newApp}function getApp(name=DEFAULT_ENTRY_NAME){const app=_apps.get(name);if(!app&&name===DEFAULT_ENTRY_NAME&&(0,_util.getDefaultAppConfig)()){return initializeApp()}if(!app){throw ERROR_FACTORY.create("no-app",{appName:name})}return app}function getApps(){return Array.from(_apps.values())}async function deleteApp(app){let cleanupProviders=false;const name=app.name;if(_apps.has(name)){cleanupProviders=true;_apps.delete(name)}else if(_serverApps.has(name)){const firebaseServerApp=app;if(firebaseServerApp.decRefCount()<=0){_serverApps.delete(name);cleanupProviders=true}}if(cleanupProviders){await Promise.all(app.container.getProviders().map((provider=>provider.delete())));app.isDeleted=true}}function registerVersion(libraryKeyOrName,version,variant){var _a;let library=(_a=PLATFORM_LOG_STRING[libraryKeyOrName])!==null&&_a!==void 0?_a:libraryKeyOrName;if(variant){library+=`-${variant}`}const libraryMismatch=library.match(/\s|\//);const versionMismatch=version.match(/\s|\//);if(libraryMismatch||versionMismatch){const warning=[`Unable to register library "${library}" with version "${version}":`];if(libraryMismatch){warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`)}if(libraryMismatch&&versionMismatch){warning.push("and")}if(versionMismatch){warning.push(`version name "${version}" contains illegal characters (whitespace or "/")`)}logger.warn(warning.join(" "));return}_registerComponent(new _component.Component(`${library}-version`,(()=>({library:library,version:version})),"VERSION"))}function onLog(logCallback,options){if(logCallback!==null&&typeof logCallback!=="function"){throw ERROR_FACTORY.create("invalid-log-argument")}(0,_logger.setUserLogHandler)(logCallback,options)}function setLogLevel(logLevel){(0,_logger.setLogLevel)(logLevel)}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const DB_NAME="firebase-heartbeat-database";const DB_VERSION=1;const STORE_NAME="firebase-heartbeat-store";let dbPromise=null;function getDbPromise(){if(!dbPromise){dbPromise=(0,_idb.openDB)(DB_NAME,DB_VERSION,{upgrade:(db,oldVersion)=>{switch(oldVersion){case 0:try{db.createObjectStore(STORE_NAME)}catch(e){console.warn(e)}}}}).catch((e=>{throw ERROR_FACTORY.create("idb-open",{originalErrorMessage:e.message})}))}return dbPromise}async function readHeartbeatsFromIndexedDB(app){try{const db=await getDbPromise();const tx=db.transaction(STORE_NAME);const result=await tx.objectStore(STORE_NAME).get(computeKey(app));await tx.done;return result}catch(e){if(e instanceof _util.FirebaseError){logger.warn(e.message)}else{const idbGetError=ERROR_FACTORY.create("idb-get",{originalErrorMessage:e===null||e===void 0?void 0:e.message});logger.warn(idbGetError.message)}}}async function writeHeartbeatsToIndexedDB(app,heartbeatObject){try{const db=await getDbPromise();const tx=db.transaction(STORE_NAME,"readwrite");const objectStore=tx.objectStore(STORE_NAME);await objectStore.put(heartbeatObject,computeKey(app));await tx.done}catch(e){if(e instanceof _util.FirebaseError){logger.warn(e.message)}else{const idbGetError=ERROR_FACTORY.create("idb-set",{originalErrorMessage:e===null||e===void 0?void 0:e.message});logger.warn(idbGetError.message)}}}function computeKey(app){return`${app.name}!${app.options.appId}`}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const MAX_HEADER_BYTES=1024;const STORED_HEARTBEAT_RETENTION_MAX_MILLIS=30*24*60*60*1e3;class HeartbeatServiceImpl{constructor(container){this.container=container;this._heartbeatsCache=null;const app=this.container.getProvider("app").getImmediate();this._storage=new HeartbeatStorageImpl(app);this._heartbeatsCachePromise=this._storage.read().then((result=>{this._heartbeatsCache=result;return result}))}async triggerHeartbeat(){var _a,_b;const platformLogger=this.container.getProvider("platform-logger").getImmediate();const agent=platformLogger.getPlatformInfoString();const date=getUTCDateString();if(((_a=this._heartbeatsCache)===null||_a===void 0?void 0:_a.heartbeats)==null){this._heartbeatsCache=await this._heartbeatsCachePromise;if(((_b=this._heartbeatsCache)===null||_b===void 0?void 0:_b.heartbeats)==null){return}}if(this._heartbeatsCache.lastSentHeartbeatDate===date||this._heartbeatsCache.heartbeats.some((singleDateHeartbeat=>singleDateHeartbeat.date===date))){return}else{this._heartbeatsCache.heartbeats.push({date:date,agent:agent})}this._heartbeatsCache.heartbeats=this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat=>{const hbTimestamp=new Date(singleDateHeartbeat.date).valueOf();const now=Date.now();return now-hbTimestamp<=STORED_HEARTBEAT_RETENTION_MAX_MILLIS}));return this._storage.overwrite(this._heartbeatsCache)}async getHeartbeatsHeader(){var _a;if(this._heartbeatsCache===null){await this._heartbeatsCachePromise}if(((_a=this._heartbeatsCache)===null||_a===void 0?void 0:_a.heartbeats)==null||this._heartbeatsCache.heartbeats.length===0){return""}const date=getUTCDateString();const{heartbeatsToSend:heartbeatsToSend,unsentEntries:unsentEntries}=extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);const headerString=(0,_util.base64urlEncodeWithoutPadding)(JSON.stringify({version:2,heartbeats:heartbeatsToSend}));this._heartbeatsCache.lastSentHeartbeatDate=date;if(unsentEntries.length>0){this._heartbeatsCache.heartbeats=unsentEntries;await this._storage.overwrite(this._heartbeatsCache)}else{this._heartbeatsCache.heartbeats=[];void this._storage.overwrite(this._heartbeatsCache)}return headerString}}function getUTCDateString(){const today=new Date;return today.toISOString().substring(0,10)}function extractHeartbeatsForHeader(heartbeatsCache,maxSize=MAX_HEADER_BYTES){const heartbeatsToSend=[];let unsentEntries=heartbeatsCache.slice();for(const singleDateHeartbeat of heartbeatsCache){const heartbeatEntry=heartbeatsToSend.find((hb=>hb.agent===singleDateHeartbeat.agent));if(!heartbeatEntry){heartbeatsToSend.push({agent:singleDateHeartbeat.agent,dates:[singleDateHeartbeat.date]});if(countBytes(heartbeatsToSend)>maxSize){heartbeatsToSend.pop();break}}else{heartbeatEntry.dates.push(singleDateHeartbeat.date);if(countBytes(heartbeatsToSend)>maxSize){heartbeatEntry.dates.pop();break}}unsentEntries=unsentEntries.slice(1)}return{heartbeatsToSend:heartbeatsToSend,unsentEntries:unsentEntries}}class HeartbeatStorageImpl{constructor(app){this.app=app;this._canUseIndexedDBPromise=this.runIndexedDBEnvironmentCheck()}async runIndexedDBEnvironmentCheck(){if(!(0,_util.isIndexedDBAvailable)()){return false}else{return(0,_util.validateIndexedDBOpenable)().then((()=>true)).catch((()=>false))}}async read(){const canUseIndexedDB=await this._canUseIndexedDBPromise;if(!canUseIndexedDB){return{heartbeats:[]}}else{const idbHeartbeatObject=await readHeartbeatsFromIndexedDB(this.app);if(idbHeartbeatObject===null||idbHeartbeatObject===void 0?void 0:idbHeartbeatObject.heartbeats){return idbHeartbeatObject}else{return{heartbeats:[]}}}}async overwrite(heartbeatsObject){var _a;const canUseIndexedDB=await this._canUseIndexedDBPromise;if(!canUseIndexedDB){return}else{const existingHeartbeatsObject=await this.read();return writeHeartbeatsToIndexedDB(this.app,{lastSentHeartbeatDate:(_a=heartbeatsObject.lastSentHeartbeatDate)!==null&&_a!==void 0?_a:existingHeartbeatsObject.lastSentHeartbeatDate,heartbeats:heartbeatsObject.heartbeats})}}async add(heartbeatsObject){var _a;const canUseIndexedDB=await this._canUseIndexedDBPromise;if(!canUseIndexedDB){return}else{const existingHeartbeatsObject=await this.read();return writeHeartbeatsToIndexedDB(this.app,{lastSentHeartbeatDate:(_a=heartbeatsObject.lastSentHeartbeatDate)!==null&&_a!==void 0?_a:existingHeartbeatsObject.lastSentHeartbeatDate,heartbeats:[...existingHeartbeatsObject.heartbeats,...heartbeatsObject.heartbeats]})}}}function countBytes(heartbeatsCache){return(0,_util.base64urlEncodeWithoutPadding)(JSON.stringify({version:2,heartbeats:heartbeatsCache})).length}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function registerCoreComponents(variant){_registerComponent(new _component.Component("platform-logger",(container=>new PlatformLoggerServiceImpl(container)),"PRIVATE"));_registerComponent(new _component.Component("heartbeat",(container=>new HeartbeatServiceImpl(container)),"PRIVATE"));registerVersion(name$o,version$1,variant);registerVersion(name$o,version$1,"esm2017");registerVersion("fire-js","")}registerCoreComponents("")},{"@firebase/component":8,"@firebase/logger":11,"@firebase/util":12,idb:16}],5:[function(require,module,exports){(function(global){(function(){"use strict";var _appCompat=_interopRequireDefault(require("@firebase/app-compat"));var exp=_interopRequireWildcard(require("@firebase/auth/internal"));var _component=require("@firebase/component");var _util=require("@firebase/util");function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!=="function")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!=="object"&&typeof obj!=="function"){return{default:obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!=="default"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var name="@firebase/auth-compat";var version="0.5.7";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const CORDOVA_ONDEVICEREADY_TIMEOUT_MS=1e3;function _getCurrentScheme(){var _a;return((_a=self===null||self===void 0?void 0:self.location)===null||_a===void 0?void 0:_a.protocol)||null}function _isHttpOrHttps(){return _getCurrentScheme()==="http:"||_getCurrentScheme()==="https:"}function _isAndroidOrIosCordovaScheme(ua=(0,_util.getUA)()){return!!((_getCurrentScheme()==="file:"||_getCurrentScheme()==="ionic:"||_getCurrentScheme()==="capacitor:")&&ua.toLowerCase().match(/iphone|ipad|ipod|android/))}function _isNativeEnvironment(){return(0,_util.isReactNative)()||(0,_util.isNode)()}function _isIe11(){return(0,_util.isIE)()&&(document===null||document===void 0?void 0:document.documentMode)===11}function _isEdge(ua=(0,_util.getUA)()){return/Edge\/\d+/.test(ua)}function _isLocalStorageNotSynchronized(ua=(0,_util.getUA)()){return _isIe11()||_isEdge(ua)}function _isWebStorageSupported(){try{const storage=self.localStorage;const key=exp._generateEventId();if(storage){storage["setItem"](key,"1");storage["removeItem"](key);if(_isLocalStorageNotSynchronized()){return(0,_util.isIndexedDBAvailable)()}return true}}catch(e){return _isWorker()&&(0,_util.isIndexedDBAvailable)()}return false}function _isWorker(){return typeof global!=="undefined"&&"WorkerGlobalScope"in global&&"importScripts"in global}function _isPopupRedirectSupported(){return(_isHttpOrHttps()||(0,_util.isBrowserExtension)()||_isAndroidOrIosCordovaScheme())&&!_isNativeEnvironment()&&_isWebStorageSupported()&&!_isWorker()}function _isLikelyCordova(){return _isAndroidOrIosCordovaScheme()&&typeof document!=="undefined"}async function _isCordova(){if(!_isLikelyCordova()){return false}return new Promise((resolve=>{const timeoutId=setTimeout((()=>{resolve(false)}),CORDOVA_ONDEVICEREADY_TIMEOUT_MS);document.addEventListener("deviceready",(()=>{clearTimeout(timeoutId);resolve(true)}))}))}function _getSelfWindow(){return typeof window!=="undefined"?window:null}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Persistence={LOCAL:"local",NONE:"none",SESSION:"session"};const _assert$3=exp._assert;const PERSISTENCE_KEY="persistence";function _validatePersistenceArgument(auth,persistence){_assert$3(Object.values(Persistence).includes(persistence),auth,"invalid-persistence-type");if((0,_util.isReactNative)()){_assert$3(persistence!==Persistence.SESSION,auth,"unsupported-persistence-type");return}if((0,_util.isNode)()){_assert$3(persistence===Persistence.NONE,auth,"unsupported-persistence-type");return}if(_isWorker()){_assert$3(persistence===Persistence.NONE||persistence===Persistence.LOCAL&&(0,_util.isIndexedDBAvailable)(),auth,"unsupported-persistence-type");return}_assert$3(persistence===Persistence.NONE||_isWebStorageSupported(),auth,"unsupported-persistence-type")}async function _savePersistenceForRedirect(auth){await auth._initializationPromise;const session=getSessionStorageIfAvailable();const key=exp._persistenceKeyName(PERSISTENCE_KEY,auth.config.apiKey,auth.name);if(session){session.setItem(key,auth._getPersistence())}}function _getPersistencesFromRedirect(apiKey,appName){const session=getSessionStorageIfAvailable();if(!session){return[]}const key=exp._persistenceKeyName(PERSISTENCE_KEY,apiKey,appName);const persistence=session.getItem(key);switch(persistence){case Persistence.NONE:return[exp.inMemoryPersistence];case Persistence.LOCAL:return[exp.indexedDBLocalPersistence,exp.browserSessionPersistence];case Persistence.SESSION:return[exp.browserSessionPersistence];default:return[]}}function getSessionStorageIfAvailable(){var _a;try{return((_a=_getSelfWindow())===null||_a===void 0?void 0:_a.sessionStorage)||null}catch(e){return null}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _assert$2=exp._assert;class CompatPopupRedirectResolver{constructor(){this.browserResolver=exp._getInstance(exp.browserPopupRedirectResolver);this.cordovaResolver=exp._getInstance(exp.cordovaPopupRedirectResolver);this.underlyingResolver=null;this._redirectPersistence=exp.browserSessionPersistence;this._completeRedirectFn=exp._getRedirectResult;this._overrideRedirectResult=exp._overrideRedirectResult}async _initialize(auth){await this.selectUnderlyingResolver();return this.assertedUnderlyingResolver._initialize(auth)}async _openPopup(auth,provider,authType,eventId){await this.selectUnderlyingResolver();return this.assertedUnderlyingResolver._openPopup(auth,provider,authType,eventId)}async _openRedirect(auth,provider,authType,eventId){await this.selectUnderlyingResolver();return this.assertedUnderlyingResolver._openRedirect(auth,provider,authType,eventId)}_isIframeWebStorageSupported(auth,cb){this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth,cb)}_originValidation(auth){return this.assertedUnderlyingResolver._originValidation(auth)}get _shouldInitProactively(){return _isLikelyCordova()||this.browserResolver._shouldInitProactively}get assertedUnderlyingResolver(){_assert$2(this.underlyingResolver,"internal-error");return this.underlyingResolver}async selectUnderlyingResolver(){if(this.underlyingResolver){return}const isCordova=await _isCordova();this.underlyingResolver=isCordova?this.cordovaResolver:this.browserResolver}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function unwrap(object){return object.unwrap()}function wrapped(object){return object.wrapped()}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function credentialFromResponse(userCredential){return credentialFromObject(userCredential)}function attachExtraErrorFields(auth,e){var _a;const response=(_a=e.customData)===null||_a===void 0?void 0:_a._tokenResponse;if((e===null||e===void 0?void 0:e.code)==="auth/multi-factor-auth-required"){const mfaErr=e;mfaErr.resolver=new MultiFactorResolver(auth,exp.getMultiFactorResolver(auth,e))}else if(response){const credential=credentialFromObject(e);const credErr=e;if(credential){credErr.credential=credential;credErr.tenantId=response.tenantId||undefined;credErr.email=response.email||undefined;credErr.phoneNumber=response.phoneNumber||undefined}}}function credentialFromObject(object){const{_tokenResponse:_tokenResponse}=object instanceof _util.FirebaseError?object.customData:object;if(!_tokenResponse){return null}if(!(object instanceof _util.FirebaseError)){if("temporaryProof"in _tokenResponse&&"phoneNumber"in _tokenResponse){return exp.PhoneAuthProvider.credentialFromResult(object)}}const providerId=_tokenResponse.providerId;if(!providerId||providerId===exp.ProviderId.PASSWORD){return null}let provider;switch(providerId){case exp.ProviderId.GOOGLE:provider=exp.GoogleAuthProvider;break;case exp.ProviderId.FACEBOOK:provider=exp.FacebookAuthProvider;break;case exp.ProviderId.GITHUB:provider=exp.GithubAuthProvider;break;case exp.ProviderId.TWITTER:provider=exp.TwitterAuthProvider;break;default:const{oauthIdToken:oauthIdToken,oauthAccessToken:oauthAccessToken,oauthTokenSecret:oauthTokenSecret,pendingToken:pendingToken,nonce:nonce}=_tokenResponse;if(!oauthAccessToken&&!oauthTokenSecret&&!oauthIdToken&&!pendingToken){return null}if(pendingToken){if(providerId.startsWith("saml.")){return exp.SAMLAuthCredential._create(providerId,pendingToken)}else{return exp.OAuthCredential._fromParams({providerId:providerId,signInMethod:providerId,pendingToken:pendingToken,idToken:oauthIdToken,accessToken:oauthAccessToken})}}return new exp.OAuthProvider(providerId).credential({idToken:oauthIdToken,accessToken:oauthAccessToken,rawNonce:nonce})}return object instanceof _util.FirebaseError?provider.credentialFromError(object):provider.credentialFromResult(object)}function convertCredential(auth,credentialPromise){return credentialPromise.catch((e=>{if(e instanceof _util.FirebaseError){attachExtraErrorFields(auth,e)}throw e})).then((credential=>{const operationType=credential.operationType;const user=credential.user;return{operationType:operationType,credential:credentialFromResponse(credential),additionalUserInfo:exp.getAdditionalUserInfo(credential),user:User.getOrCreate(user)}}))}async function convertConfirmationResult(auth,confirmationResultPromise){const confirmationResultExp=await confirmationResultPromise;return{verificationId:confirmationResultExp.verificationId,confirm:verificationCode=>convertCredential(auth,confirmationResultExp.confirm(verificationCode))}}class MultiFactorResolver{constructor(auth,resolver){this.resolver=resolver;this.auth=wrapped(auth)}get session(){return this.resolver.session}get hints(){return this.resolver.hints}resolveSignIn(assertion){return convertCredential(unwrap(this.auth),this.resolver.resolveSignIn(assertion))}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class User{constructor(_delegate){this._delegate=_delegate;this.multiFactor=exp.multiFactor(_delegate)}static getOrCreate(user){if(!User.USER_MAP.has(user)){User.USER_MAP.set(user,new User(user))}return User.USER_MAP.get(user)}delete(){return this._delegate.delete()}reload(){return this._delegate.reload()}toJSON(){return this._delegate.toJSON()}getIdTokenResult(forceRefresh){return this._delegate.getIdTokenResult(forceRefresh)}getIdToken(forceRefresh){return this._delegate.getIdToken(forceRefresh)}linkAndRetrieveDataWithCredential(credential){return this.linkWithCredential(credential)}async linkWithCredential(credential){return convertCredential(this.auth,exp.linkWithCredential(this._delegate,credential))}async linkWithPhoneNumber(phoneNumber,applicationVerifier){return convertConfirmationResult(this.auth,exp.linkWithPhoneNumber(this._delegate,phoneNumber,applicationVerifier))}async linkWithPopup(provider){return convertCredential(this.auth,exp.linkWithPopup(this._delegate,provider,CompatPopupRedirectResolver))}async linkWithRedirect(provider){await _savePersistenceForRedirect(exp._castAuth(this.auth));return exp.linkWithRedirect(this._delegate,provider,CompatPopupRedirectResolver)}reauthenticateAndRetrieveDataWithCredential(credential){return this.reauthenticateWithCredential(credential)}async reauthenticateWithCredential(credential){return convertCredential(this.auth,exp.reauthenticateWithCredential(this._delegate,credential))}reauthenticateWithPhoneNumber(phoneNumber,applicationVerifier){return convertConfirmationResult(this.auth,exp.reauthenticateWithPhoneNumber(this._delegate,phoneNumber,applicationVerifier))}reauthenticateWithPopup(provider){return convertCredential(this.auth,exp.reauthenticateWithPopup(this._delegate,provider,CompatPopupRedirectResolver))}async reauthenticateWithRedirect(provider){await _savePersistenceForRedirect(exp._castAuth(this.auth));return exp.reauthenticateWithRedirect(this._delegate,provider,CompatPopupRedirectResolver)}sendEmailVerification(actionCodeSettings){return exp.sendEmailVerification(this._delegate,actionCodeSettings)}async unlink(providerId){await exp.unlink(this._delegate,providerId);return this}updateEmail(newEmail){return exp.updateEmail(this._delegate,newEmail)}updatePassword(newPassword){return exp.updatePassword(this._delegate,newPassword)}updatePhoneNumber(phoneCredential){return exp.updatePhoneNumber(this._delegate,phoneCredential)}updateProfile(profile){return exp.updateProfile(this._delegate,profile)}verifyBeforeUpdateEmail(newEmail,actionCodeSettings){return exp.verifyBeforeUpdateEmail(this._delegate,newEmail,actionCodeSettings)}get emailVerified(){return this._delegate.emailVerified}get isAnonymous(){return this._delegate.isAnonymous}get metadata(){return this._delegate.metadata}get phoneNumber(){return this._delegate.phoneNumber}get providerData(){return this._delegate.providerData}get refreshToken(){return this._delegate.refreshToken}get tenantId(){return this._delegate.tenantId}get displayName(){return this._delegate.displayName}get email(){return this._delegate.email}get photoURL(){return this._delegate.photoURL}get providerId(){return this._delegate.providerId}get uid(){return this._delegate.uid}get auth(){return this._delegate.auth}}User.USER_MAP=new WeakMap;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _assert$1=exp._assert;class Auth{constructor(app,provider){this.app=app;if(provider.isInitialized()){this._delegate=provider.getImmediate();this.linkUnderlyingAuth();return}const{apiKey:apiKey}=app.options;_assert$1(apiKey,"invalid-api-key",{appName:app.name});_assert$1(apiKey,"invalid-api-key",{appName:app.name});const resolver=typeof window!=="undefined"?CompatPopupRedirectResolver:undefined;this._delegate=provider.initialize({options:{persistence:buildPersistenceHierarchy(apiKey,app.name),popupRedirectResolver:resolver}});this._delegate._updateErrorMap(exp.debugErrorMap);this.linkUnderlyingAuth()}get emulatorConfig(){return this._delegate.emulatorConfig}get currentUser(){if(!this._delegate.currentUser){return null}return User.getOrCreate(this._delegate.currentUser)}get languageCode(){return this._delegate.languageCode}set languageCode(languageCode){this._delegate.languageCode=languageCode}get settings(){return this._delegate.settings}get tenantId(){return this._delegate.tenantId}set tenantId(tid){this._delegate.tenantId=tid}useDeviceLanguage(){this._delegate.useDeviceLanguage()}signOut(){return this._delegate.signOut()}useEmulator(url,options){exp.connectAuthEmulator(this._delegate,url,options)}applyActionCode(code){return exp.applyActionCode(this._delegate,code)}checkActionCode(code){return exp.checkActionCode(this._delegate,code)}confirmPasswordReset(code,newPassword){return exp.confirmPasswordReset(this._delegate,code,newPassword)}async createUserWithEmailAndPassword(email,password){return convertCredential(this._delegate,exp.createUserWithEmailAndPassword(this._delegate,email,password))}fetchProvidersForEmail(email){return this.fetchSignInMethodsForEmail(email)}fetchSignInMethodsForEmail(email){return exp.fetchSignInMethodsForEmail(this._delegate,email)}isSignInWithEmailLink(emailLink){return exp.isSignInWithEmailLink(this._delegate,emailLink)}async getRedirectResult(){_assert$1(_isPopupRedirectSupported(),this._delegate,"operation-not-supported-in-this-environment");const credential=await exp.getRedirectResult(this._delegate,CompatPopupRedirectResolver);if(!credential){return{credential:null,user:null}}return convertCredential(this._delegate,Promise.resolve(credential))}addFrameworkForLogging(framework){exp.addFrameworkForLogging(this._delegate,framework)}onAuthStateChanged(nextOrObserver,errorFn,completed){const{next:next,error:error,complete:complete}=wrapObservers(nextOrObserver,errorFn,completed);return this._delegate.onAuthStateChanged(next,error,complete)}onIdTokenChanged(nextOrObserver,errorFn,completed){const{next:next,error:error,complete:complete}=wrapObservers(nextOrObserver,errorFn,completed);return this._delegate.onIdTokenChanged(next,error,complete)}sendSignInLinkToEmail(email,actionCodeSettings){return exp.sendSignInLinkToEmail(this._delegate,email,actionCodeSettings)}sendPasswordResetEmail(email,actionCodeSettings){return exp.sendPasswordResetEmail(this._delegate,email,actionCodeSettings||undefined)}async setPersistence(persistence){_validatePersistenceArgument(this._delegate,persistence);let converted;switch(persistence){case Persistence.SESSION:converted=exp.browserSessionPersistence;break;case Persistence.LOCAL:const isIndexedDBFullySupported=await exp._getInstance(exp.indexedDBLocalPersistence)._isAvailable();converted=isIndexedDBFullySupported?exp.indexedDBLocalPersistence:exp.browserLocalPersistence;break;case Persistence.NONE:converted=exp.inMemoryPersistence;break;default:return exp._fail("argument-error",{appName:this._delegate.name})}return this._delegate.setPersistence(converted)}signInAndRetrieveDataWithCredential(credential){return this.signInWithCredential(credential)}signInAnonymously(){return convertCredential(this._delegate,exp.signInAnonymously(this._delegate))}signInWithCredential(credential){return convertCredential(this._delegate,exp.signInWithCredential(this._delegate,credential))}signInWithCustomToken(token){return convertCredential(this._delegate,exp.signInWithCustomToken(this._delegate,token))}signInWithEmailAndPassword(email,password){return convertCredential(this._delegate,exp.signInWithEmailAndPassword(this._delegate,email,password))}signInWithEmailLink(email,emailLink){return convertCredential(this._delegate,exp.signInWithEmailLink(this._delegate,email,emailLink))}signInWithPhoneNumber(phoneNumber,applicationVerifier){return convertConfirmationResult(this._delegate,exp.signInWithPhoneNumber(this._delegate,phoneNumber,applicationVerifier))}async signInWithPopup(provider){_assert$1(_isPopupRedirectSupported(),this._delegate,"operation-not-supported-in-this-environment");return convertCredential(this._delegate,exp.signInWithPopup(this._delegate,provider,CompatPopupRedirectResolver))}async signInWithRedirect(provider){_assert$1(_isPopupRedirectSupported(),this._delegate,"operation-not-supported-in-this-environment");await _savePersistenceForRedirect(this._delegate);return exp.signInWithRedirect(this._delegate,provider,CompatPopupRedirectResolver)}updateCurrentUser(user){return this._delegate.updateCurrentUser(user)}verifyPasswordResetCode(code){return exp.verifyPasswordResetCode(this._delegate,code)}unwrap(){return this._delegate}_delete(){return this._delegate._delete()}linkUnderlyingAuth(){this._delegate.wrapped=()=>this}}Auth.Persistence=Persistence;function wrapObservers(nextOrObserver,error,complete){let next=nextOrObserver;if(typeof nextOrObserver!=="function"){({next:next,error:error,complete:complete}=nextOrObserver)}const oldNext=next;const newNext=user=>oldNext(user&&User.getOrCreate(user));return{next:newNext,error:error,complete:complete}}function buildPersistenceHierarchy(apiKey,appName){const persistences=_getPersistencesFromRedirect(apiKey,appName);if(typeof self!=="undefined"&&!persistences.includes(exp.indexedDBLocalPersistence)){persistences.push(exp.indexedDBLocalPersistence)}if(typeof window!=="undefined"){for(const persistence of[exp.browserLocalPersistence,exp.browserSessionPersistence]){if(!persistences.includes(persistence)){persistences.push(persistence)}}}if(!persistences.includes(exp.inMemoryPersistence)){persistences.push(exp.inMemoryPersistence)}return persistences}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class PhoneAuthProvider{constructor(){this.providerId="phone";this._delegate=new exp.PhoneAuthProvider(unwrap(_appCompat.default.auth()))}static credential(verificationId,verificationCode){return exp.PhoneAuthProvider.credential(verificationId,verificationCode)}verifyPhoneNumber(phoneInfoOptions,applicationVerifier){return this._delegate.verifyPhoneNumber(phoneInfoOptions,applicationVerifier)}unwrap(){return this._delegate}}PhoneAuthProvider.PHONE_SIGN_IN_METHOD=exp.PhoneAuthProvider.PHONE_SIGN_IN_METHOD;PhoneAuthProvider.PROVIDER_ID=exp.PhoneAuthProvider.PROVIDER_ID;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _assert=exp._assert;class RecaptchaVerifier{constructor(container,parameters,app=_appCompat.default.app()){var _a;_assert((_a=app.options)===null||_a===void 0?void 0:_a.apiKey,"invalid-api-key",{appName:app.name});this._delegate=new exp.RecaptchaVerifier(app.auth(),container,parameters);this.type=this._delegate.type}clear(){this._delegate.clear()}render(){return this._delegate.render()}verify(){return this._delegate.verify()}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const AUTH_TYPE="auth-compat";function registerAuthCompat(instance){instance.INTERNAL.registerComponent(new _component.Component(AUTH_TYPE,(container=>{const app=container.getProvider("app-compat").getImmediate();const authProvider=container.getProvider("auth");return new Auth(app,authProvider)}),"PUBLIC").setServiceProps({ActionCodeInfo:{Operation:{EMAIL_SIGNIN:exp.ActionCodeOperation.EMAIL_SIGNIN,PASSWORD_RESET:exp.ActionCodeOperation.PASSWORD_RESET,RECOVER_EMAIL:exp.ActionCodeOperation.RECOVER_EMAIL,REVERT_SECOND_FACTOR_ADDITION:exp.ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION,VERIFY_AND_CHANGE_EMAIL:exp.ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL,VERIFY_EMAIL:exp.ActionCodeOperation.VERIFY_EMAIL}},EmailAuthProvider:exp.EmailAuthProvider,FacebookAuthProvider:exp.FacebookAuthProvider,GithubAuthProvider:exp.GithubAuthProvider,GoogleAuthProvider:exp.GoogleAuthProvider,OAuthProvider:exp.OAuthProvider,SAMLAuthProvider:exp.SAMLAuthProvider,PhoneAuthProvider:PhoneAuthProvider,PhoneMultiFactorGenerator:exp.PhoneMultiFactorGenerator,RecaptchaVerifier:RecaptchaVerifier,TwitterAuthProvider:exp.TwitterAuthProvider,Auth:Auth,AuthCredential:exp.AuthCredential,Error:_util.FirebaseError}).setInstantiationMode("LAZY").setMultipleInstances(false));instance.registerVersion(name,version)}registerAuthCompat(_appCompat.default)}).call(this)}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"@firebase/app-compat":3,"@firebase/auth/internal":7,"@firebase/component":8,"@firebase/util":12}],6:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.A=exports.$=void 0;exports.B=updateCurrentUser;exports.C=signOut;exports.D=revokeAccessToken;exports.E=deleteUser;exports.I=exports.H=exports.G=exports.F=void 0;exports.J=initializeAuth;exports.K=connectAuthEmulator;exports.a=exports._=exports.Z=exports.Y=exports.X=exports.W=exports.V=exports.U=exports.T=exports.S=exports.R=exports.Q=exports.P=exports.O=exports.N=exports.M=exports.L=void 0;exports.a0=signInAnonymously;exports.a1=signInWithCredential;exports.a2=linkWithCredential;exports.a3=reauthenticateWithCredential;exports.a4=signInWithCustomToken;exports.a5=sendPasswordResetEmail;exports.a6=confirmPasswordReset;exports.a7=applyActionCode;exports.a8=checkActionCode;exports.a9=verifyPasswordResetCode;exports.aA=_isIOS7Or8;exports.aB=_createError;exports.aC=_assert;exports.aD=void 0;exports.aE=_getInstance;exports.aF=_persistenceKeyName;exports.aG=_getRedirectResult;exports.aH=_overrideRedirectResult;exports.aI=_clearRedirectOutcomes;exports.aJ=_castAuth;exports.aL=exports.aK=void 0;exports.aM=_getClientVersion;exports.aN=_generateEventId;exports.aQ=exports.aP=exports.aO=void 0;exports.aa=createUserWithEmailAndPassword;exports.ab=signInWithEmailAndPassword;exports.ac=sendSignInLinkToEmail;exports.ad=isSignInWithEmailLink;exports.ae=signInWithEmailLink;exports.af=fetchSignInMethodsForEmail;exports.ag=sendEmailVerification;exports.ah=verifyBeforeUpdateEmail;exports.ai=void 0;exports.aj=parseActionCodeURL;exports.ak=updateProfile;exports.al=updateEmail;exports.am=updatePassword;exports.an=getIdToken;exports.ao=getIdTokenResult;exports.ap=unlink;exports.aq=getAdditionalUserInfo;exports.ar=reload;exports.as=getMultiFactorResolver;exports.at=multiFactor;exports.au=debugAssert;exports.av=_isIOS;exports.aw=_isAndroid;exports.ax=_fail;exports.ay=_getRedirectUrl;exports.az=_getProjectConfig;exports.b=void 0;exports.c=signInWithPopup;exports.d=linkWithPopup;exports.e=reauthenticateWithPopup;exports.f=signInWithRedirect;exports.g=linkWithRedirect;exports.h=reauthenticateWithRedirect;exports.i=void 0;exports.j=getRedirectResult;exports.k=void 0;exports.l=linkWithPhoneNumber;exports.n=exports.m=void 0;exports.o=getAuth;exports.p=void 0;exports.q=setPersistence;exports.r=reauthenticateWithPhoneNumber;exports.s=signInWithPhoneNumber;exports.t=initializeRecaptchaConfig;exports.u=updatePhoneNumber;exports.v=validatePassword;exports.w=onIdTokenChanged;exports.x=beforeAuthStateChanged;exports.y=onAuthStateChanged;exports.z=useDeviceLanguage;var _app=require("@firebase/app");var _util=require("@firebase/util");var _logger=require("@firebase/logger");var _tslib=require("tslib");var _component=require("@firebase/component");
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const FactorId={PHONE:"phone",TOTP:"totp"};exports.F=FactorId;const ProviderId={FACEBOOK:"facebook.com",GITHUB:"github.com",GOOGLE:"google.com",PASSWORD:"password",PHONE:"phone",TWITTER:"twitter.com"};exports.p=ProviderId;const SignInMethod={EMAIL_LINK:"emailLink",EMAIL_PASSWORD:"password",FACEBOOK:"facebook.com",GITHUB:"github.com",GOOGLE:"google.com",PHONE:"phone",TWITTER:"twitter.com"};exports.S=SignInMethod;const OperationType={LINK:"link",REAUTHENTICATE:"reauthenticate",SIGN_IN:"signIn"};exports.O=OperationType;const ActionCodeOperation={EMAIL_SIGNIN:"EMAIL_SIGNIN",PASSWORD_RESET:"PASSWORD_RESET",RECOVER_EMAIL:"RECOVER_EMAIL",REVERT_SECOND_FACTOR_ADDITION:"REVERT_SECOND_FACTOR_ADDITION",VERIFY_AND_CHANGE_EMAIL:"VERIFY_AND_CHANGE_EMAIL",VERIFY_EMAIL:"VERIFY_EMAIL"};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.A=ActionCodeOperation;function _debugErrorMap(){return{["admin-restricted-operation"]:"This operation is restricted to administrators only.",["argument-error"]:"",["app-not-authorized"]:"This app, identified by the domain where it's hosted, is not "+"authorized to use Firebase Authentication with the provided API key. "+"Review your key configuration in the Google API console.",["app-not-installed"]:"The requested mobile application corresponding to the identifier ("+"Android package name or iOS bundle ID) provided is not installed on "+"this device.",["captcha-check-failed"]:"The reCAPTCHA response token provided is either invalid, expired, "+"already used or the domain associated with it does not match the list "+"of whitelisted domains.",["code-expired"]:"The SMS code has expired. Please re-send the verification code to try "+"again.",["cordova-not-ready"]:"Cordova framework is not ready.",["cors-unsupported"]:"This browser is not supported.",["credential-already-in-use"]:"This credential is already associated with a different user account.",["custom-token-mismatch"]:"The custom token corresponds to a different audience.",["requires-recent-login"]:"This operation is sensitive and requires recent authentication. Log in "+"again before retrying this request.",["dependent-sdk-initialized-before-auth"]:"Another Firebase SDK was initialized and is trying to use Auth before Auth is "+"initialized. Please be sure to call `initializeAuth` or `getAuth` before "+"starting any other Firebase SDK.",["dynamic-link-not-activated"]:"Please activate Dynamic Links in the Firebase Console and agree to the terms and "+"conditions.",["email-change-needs-verification"]:"Multi-factor users must always have a verified email.",["email-already-in-use"]:"The email address is already in use by another account.",["emulator-config-failed"]:"Auth instance has already been used to make a network call. Auth can "+"no longer be configured to use the emulator. Try calling "+'"connectAuthEmulator()" sooner.',["expired-action-code"]:"The action code has expired.",["cancelled-popup-request"]:"This operation has been cancelled due to another conflicting popup being opened.",["internal-error"]:"An internal AuthError has occurred.",["invalid-app-credential"]:"The phone verification request contains an invalid application verifier."+" The reCAPTCHA token response is either invalid or expired.",["invalid-app-id"]:"The mobile app identifier is not registed for the current project.",["invalid-user-token"]:"This user's credential isn't valid for this project. This can happen "+"if the user's token has been tampered with, or if the user isn't for "+"the project associated with this API key.",["invalid-auth-event"]:"An internal AuthError has occurred.",["invalid-verification-code"]:"The SMS verification code used to create the phone auth credential is "+"invalid. Please resend the verification code sms and be sure to use the "+"verification code provided by the user.",["invalid-continue-uri"]:"The continue URL provided in the request is invalid.",["invalid-cordova-configuration"]:"The following Cordova plugins must be installed to enable OAuth sign-in: "+"cordova-plugin-buildinfo, cordova-universal-links-plugin, "+"cordova-plugin-browsertab, cordova-plugin-inappbrowser and "+"cordova-plugin-customurlscheme.",["invalid-custom-token"]:"The custom token format is incorrect. Please check the documentation.",["invalid-dynamic-link-domain"]:"The provided dynamic link domain is not configured or authorized for the current project.",["invalid-email"]:"The email address is badly formatted.",["invalid-emulator-scheme"]:"Emulator URL must start with a valid scheme (http:// or https://).",["invalid-api-key"]:"Your API key is invalid, please check you have copied it correctly.",["invalid-cert-hash"]:"The SHA-1 certificate hash provided is invalid.",["invalid-credential"]:"The supplied auth credential is incorrect, malformed or has expired.",["invalid-message-payload"]:"The email template corresponding to this action contains invalid characters in its message. "+"Please fix by going to the Auth email templates section in the Firebase Console.",["invalid-multi-factor-session"]:"The request does not contain a valid proof of first factor successful sign-in.",["invalid-oauth-provider"]:"EmailAuthProvider is not supported for this operation. This operation "+"only supports OAuth providers.",["invalid-oauth-client-id"]:"The OAuth client ID provided is either invalid or does not match the "+"specified API key.",["unauthorized-domain"]:"This domain is not authorized for OAuth operations for your Firebase "+"project. Edit the list of authorized domains from the Firebase console.",["invalid-action-code"]:"The action code is invalid. This can happen if the code is malformed, "+"expired, or has already been used.",["wrong-password"]:"The password is invalid or the user does not have a password.",["invalid-persistence-type"]:"The specified persistence type is invalid. It can only be local, session or none.",["invalid-phone-number"]:"The format of the phone number provided is incorrect. Please enter the "+"phone number in a format that can be parsed into E.164 format. E.164 "+"phone numbers are written in the format [+][country code][subscriber "+"number including area code].",["invalid-provider-id"]:"The specified provider ID is invalid.",["invalid-recipient-email"]:"The email corresponding to this action failed to send as the provided "+"recipient email address is invalid.",["invalid-sender"]:"The email template corresponding to this action contains an invalid sender email or name. "+"Please fix by going to the Auth email templates section in the Firebase Console.",["invalid-verification-id"]:"The verification ID used to create the phone auth credential is invalid.",["invalid-tenant-id"]:"The Auth instance's tenant ID is invalid.",["login-blocked"]:"Login blocked by user-provided method: {$originalMessage}",["missing-android-pkg-name"]:"An Android Package Name must be provided if the Android App is required to be installed.",["auth-domain-config-required"]:"Be sure to include authDomain when calling firebase.initializeApp(), "+"by following the instructions in the Firebase console.",["missing-app-credential"]:"The phone verification request is missing an application verifier "+"assertion. A reCAPTCHA response token needs to be provided.",["missing-verification-code"]:"The phone auth credential was created with an empty SMS verification code.",["missing-continue-uri"]:"A continue URL must be provided in the request.",["missing-iframe-start"]:"An internal AuthError has occurred.",["missing-ios-bundle-id"]:"An iOS Bundle ID must be provided if an App Store ID is provided.",["missing-or-invalid-nonce"]:"The request does not contain a valid nonce. This can occur if the "+"SHA-256 hash of the provided raw nonce does not match the hashed nonce "+"in the ID token payload.",["missing-password"]:"A non-empty password must be provided",["missing-multi-factor-info"]:"No second factor identifier is provided.",["missing-multi-factor-session"]:"The request is missing proof of first factor successful sign-in.",["missing-phone-number"]:"To send verification codes, provide a phone number for the recipient.",["missing-verification-id"]:"The phone auth credential was created with an empty verification ID.",["app-deleted"]:"This instance of FirebaseApp has been deleted.",["multi-factor-info-not-found"]:"The user does not have a second factor matching the identifier provided.",["multi-factor-auth-required"]:"Proof of ownership of a second factor is required to complete sign-in.",["account-exists-with-different-credential"]:"An account already exists with the same email address but different "+"sign-in credentials. Sign in using a provider associated with this "+"email address.",["network-request-failed"]:"A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.",["no-auth-event"]:"An internal AuthError has occurred.",["no-such-provider"]:"User was not linked to an account with the given provider.",["null-user"]:"A null user object was provided as the argument for an operation which "+"requires a non-null user object.",["operation-not-allowed"]:"The given sign-in provider is disabled for this Firebase project. "+"Enable it in the Firebase console, under the sign-in method tab of the "+"Auth section.",["operation-not-supported-in-this-environment"]:"This operation is not supported in the environment this application is "+'running on. "location.protocol" must be http, https or chrome-extension'+" and web storage must be enabled.",["popup-blocked"]:"Unable to establish a connection with the popup. It may have been blocked by the browser.",["popup-closed-by-user"]:"The popup has been closed by the user before finalizing the operation.",["provider-already-linked"]:"User can only be linked to one identity for the given provider.",["quota-exceeded"]:"The project's quota for this operation has been exceeded.",["redirect-cancelled-by-user"]:"The redirect operation has been cancelled by the user before finalizing.",["redirect-operation-pending"]:"A redirect sign-in operation is already pending.",["rejected-credential"]:"The request contains malformed or mismatching credentials.",["second-factor-already-in-use"]:"The second factor is already enrolled on this account.",["maximum-second-factor-count-exceeded"]:"The maximum allowed number of second factors on a user has been exceeded.",["tenant-id-mismatch"]:"The provided tenant ID does not match the Auth instance's tenant ID",["timeout"]:"The operation has timed out.",["user-token-expired"]:"The user's credential is no longer valid. The user must sign in again.",["too-many-requests"]:"We have blocked all requests from this device due to unusual activity. "+"Try again later.",["unauthorized-continue-uri"]:"The domain of the continue URL is not whitelisted.  Please whitelist "+"the domain in the Firebase console.",["unsupported-first-factor"]:"Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.",["unsupported-persistence-type"]:"The current environment does not support the specified persistence type.",["unsupported-tenant-operation"]:"This operation is not supported in a multi-tenant context.",["unverified-email"]:"The operation requires a verified email.",["user-cancelled"]:"The user did not grant your application the permissions it requested.",["user-not-found"]:"There is no user record corresponding to this identifier. The user may "+"have been deleted.",["user-disabled"]:"The user account has been disabled by an administrator.",["user-mismatch"]:"The supplied credentials do not correspond to the previously signed in user.",["user-signed-out"]:"",["weak-password"]:"The password must be 6 characters long or more.",["web-storage-unsupported"]:"This browser is not supported or 3rd party cookies and data may be disabled.",["already-initialized"]:"initializeAuth() has already been called with "+"different options. To avoid this error, call initializeAuth() with the "+"same options as when it was originally called, or call getAuth() to return the"+" already initialized instance.",["missing-recaptcha-token"]:"The reCAPTCHA token is missing when sending request to the backend.",["invalid-recaptcha-token"]:"The reCAPTCHA token is invalid when sending request to the backend.",["invalid-recaptcha-action"]:"The reCAPTCHA action is invalid when sending request to the backend.",["recaptcha-not-enabled"]:"reCAPTCHA Enterprise integration is not enabled for this project.",["missing-client-type"]:"The reCAPTCHA client type is missing when sending request to the backend.",["missing-recaptcha-version"]:"The reCAPTCHA version is missing when sending request to the backend.",["invalid-req-type"]:"Invalid request parameters.",["invalid-recaptcha-version"]:"The reCAPTCHA version is invalid when sending request to the backend.",["unsupported-password-policy-schema-version"]:"The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.",["password-does-not-meet-requirements"]:"The password does not meet the requirements."}}function _prodErrorMap(){return{["dependent-sdk-initialized-before-auth"]:"Another Firebase SDK was initialized and is trying to use Auth before Auth is "+"initialized. Please be sure to call `initializeAuth` or `getAuth` before "+"starting any other Firebase SDK."}}const debugErrorMap=_debugErrorMap;exports.G=debugErrorMap;const prodErrorMap=_prodErrorMap;exports.H=prodErrorMap;const _DEFAULT_AUTH_ERROR_FACTORY=new _util.ErrorFactory("auth","Firebase",_prodErrorMap());const AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY={ADMIN_ONLY_OPERATION:"auth/admin-restricted-operation",ARGUMENT_ERROR:"auth/argument-error",APP_NOT_AUTHORIZED:"auth/app-not-authorized",APP_NOT_INSTALLED:"auth/app-not-installed",CAPTCHA_CHECK_FAILED:"auth/captcha-check-failed",CODE_EXPIRED:"auth/code-expired",CORDOVA_NOT_READY:"auth/cordova-not-ready",CORS_UNSUPPORTED:"auth/cors-unsupported",CREDENTIAL_ALREADY_IN_USE:"auth/credential-already-in-use",CREDENTIAL_MISMATCH:"auth/custom-token-mismatch",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"auth/requires-recent-login",DEPENDENT_SDK_INIT_BEFORE_AUTH:"auth/dependent-sdk-initialized-before-auth",DYNAMIC_LINK_NOT_ACTIVATED:"auth/dynamic-link-not-activated",EMAIL_CHANGE_NEEDS_VERIFICATION:"auth/email-change-needs-verification",EMAIL_EXISTS:"auth/email-already-in-use",EMULATOR_CONFIG_FAILED:"auth/emulator-config-failed",EXPIRED_OOB_CODE:"auth/expired-action-code",EXPIRED_POPUP_REQUEST:"auth/cancelled-popup-request",INTERNAL_ERROR:"auth/internal-error",INVALID_API_KEY:"auth/invalid-api-key",INVALID_APP_CREDENTIAL:"auth/invalid-app-credential",INVALID_APP_ID:"auth/invalid-app-id",INVALID_AUTH:"auth/invalid-user-token",INVALID_AUTH_EVENT:"auth/invalid-auth-event",INVALID_CERT_HASH:"auth/invalid-cert-hash",INVALID_CODE:"auth/invalid-verification-code",INVALID_CONTINUE_URI:"auth/invalid-continue-uri",INVALID_CORDOVA_CONFIGURATION:"auth/invalid-cordova-configuration",INVALID_CUSTOM_TOKEN:"auth/invalid-custom-token",INVALID_DYNAMIC_LINK_DOMAIN:"auth/invalid-dynamic-link-domain",INVALID_EMAIL:"auth/invalid-email",INVALID_EMULATOR_SCHEME:"auth/invalid-emulator-scheme",INVALID_IDP_RESPONSE:"auth/invalid-credential",INVALID_LOGIN_CREDENTIALS:"auth/invalid-credential",INVALID_MESSAGE_PAYLOAD:"auth/invalid-message-payload",INVALID_MFA_SESSION:"auth/invalid-multi-factor-session",INVALID_OAUTH_CLIENT_ID:"auth/invalid-oauth-client-id",INVALID_OAUTH_PROVIDER:"auth/invalid-oauth-provider",INVALID_OOB_CODE:"auth/invalid-action-code",INVALID_ORIGIN:"auth/unauthorized-domain",INVALID_PASSWORD:"auth/wrong-password",INVALID_PERSISTENCE:"auth/invalid-persistence-type",INVALID_PHONE_NUMBER:"auth/invalid-phone-number",INVALID_PROVIDER_ID:"auth/invalid-provider-id",INVALID_RECIPIENT_EMAIL:"auth/invalid-recipient-email",INVALID_SENDER:"auth/invalid-sender",INVALID_SESSION_INFO:"auth/invalid-verification-id",INVALID_TENANT_ID:"auth/invalid-tenant-id",MFA_INFO_NOT_FOUND:"auth/multi-factor-info-not-found",MFA_REQUIRED:"auth/multi-factor-auth-required",MISSING_ANDROID_PACKAGE_NAME:"auth/missing-android-pkg-name",MISSING_APP_CREDENTIAL:"auth/missing-app-credential",MISSING_AUTH_DOMAIN:"auth/auth-domain-config-required",MISSING_CODE:"auth/missing-verification-code",MISSING_CONTINUE_URI:"auth/missing-continue-uri",MISSING_IFRAME_START:"auth/missing-iframe-start",MISSING_IOS_BUNDLE_ID:"auth/missing-ios-bundle-id",MISSING_OR_INVALID_NONCE:"auth/missing-or-invalid-nonce",MISSING_MFA_INFO:"auth/missing-multi-factor-info",MISSING_MFA_SESSION:"auth/missing-multi-factor-session",MISSING_PHONE_NUMBER:"auth/missing-phone-number",MISSING_SESSION_INFO:"auth/missing-verification-id",MODULE_DESTROYED:"auth/app-deleted",NEED_CONFIRMATION:"auth/account-exists-with-different-credential",NETWORK_REQUEST_FAILED:"auth/network-request-failed",NULL_USER:"auth/null-user",NO_AUTH_EVENT:"auth/no-auth-event",NO_SUCH_PROVIDER:"auth/no-such-provider",OPERATION_NOT_ALLOWED:"auth/operation-not-allowed",OPERATION_NOT_SUPPORTED:"auth/operation-not-supported-in-this-environment",POPUP_BLOCKED:"auth/popup-blocked",POPUP_CLOSED_BY_USER:"auth/popup-closed-by-user",PROVIDER_ALREADY_LINKED:"auth/provider-already-linked",QUOTA_EXCEEDED:"auth/quota-exceeded",REDIRECT_CANCELLED_BY_USER:"auth/redirect-cancelled-by-user",REDIRECT_OPERATION_PENDING:"auth/redirect-operation-pending",REJECTED_CREDENTIAL:"auth/rejected-credential",SECOND_FACTOR_ALREADY_ENROLLED:"auth/second-factor-already-in-use",SECOND_FACTOR_LIMIT_EXCEEDED:"auth/maximum-second-factor-count-exceeded",TENANT_ID_MISMATCH:"auth/tenant-id-mismatch",TIMEOUT:"auth/timeout",TOKEN_EXPIRED:"auth/user-token-expired",TOO_MANY_ATTEMPTS_TRY_LATER:"auth/too-many-requests",UNAUTHORIZED_DOMAIN:"auth/unauthorized-continue-uri",UNSUPPORTED_FIRST_FACTOR:"auth/unsupported-first-factor",UNSUPPORTED_PERSISTENCE:"auth/unsupported-persistence-type",UNSUPPORTED_TENANT_OPERATION:"auth/unsupported-tenant-operation",UNVERIFIED_EMAIL:"auth/unverified-email",USER_CANCELLED:"auth/user-cancelled",USER_DELETED:"auth/user-not-found",USER_DISABLED:"auth/user-disabled",USER_MISMATCH:"auth/user-mismatch",USER_SIGNED_OUT:"auth/user-signed-out",WEAK_PASSWORD:"auth/weak-password",WEB_STORAGE_UNSUPPORTED:"auth/web-storage-unsupported",ALREADY_INITIALIZED:"auth/already-initialized",RECAPTCHA_NOT_ENABLED:"auth/recaptcha-not-enabled",MISSING_RECAPTCHA_TOKEN:"auth/missing-recaptcha-token",INVALID_RECAPTCHA_TOKEN:"auth/invalid-recaptcha-token",INVALID_RECAPTCHA_ACTION:"auth/invalid-recaptcha-action",MISSING_CLIENT_TYPE:"auth/missing-client-type",MISSING_RECAPTCHA_VERSION:"auth/missing-recaptcha-version",INVALID_RECAPTCHA_VERSION:"auth/invalid-recaptcha-version",INVALID_REQ_TYPE:"auth/invalid-req-type"};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.I=AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY;const logClient=new _logger.Logger("@firebase/auth");function _logWarn(msg,...args){if(logClient.logLevel<=_logger.LogLevel.WARN){logClient.warn(`Auth (${_app.SDK_VERSION}): ${msg}`,...args)}}function _logError(msg,...args){if(logClient.logLevel<=_logger.LogLevel.ERROR){logClient.error(`Auth (${_app.SDK_VERSION}): ${msg}`,...args)}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _fail(authOrCode,...rest){throw createErrorInternal(authOrCode,...rest)}function _createError(authOrCode,...rest){return createErrorInternal(authOrCode,...rest)}function _errorWithCustomMessage(auth,code,message){const errorMap=Object.assign(Object.assign({},prodErrorMap()),{[code]:message});const factory=new _util.ErrorFactory("auth","Firebase",errorMap);return factory.create(code,{appName:auth.name})}function _serverAppCurrentUserOperationNotSupportedError(auth){return _errorWithCustomMessage(auth,"operation-not-supported-in-this-environment","Operations that alter the current user are not supported in conjunction with FirebaseServerApp")}function _assertInstanceOf(auth,object,instance){const constructorInstance=instance;if(!(object instanceof constructorInstance)){if(constructorInstance.name!==object.constructor.name){_fail(auth,"argument-error")}throw _errorWithCustomMessage(auth,"argument-error",`Type of ${object.constructor.name} does not match expected instance.`+`Did you pass a reference from a different Auth SDK?`)}}function createErrorInternal(authOrCode,...rest){if(typeof authOrCode!=="string"){const code=rest[0];const fullParams=[...rest.slice(1)];if(fullParams[0]){fullParams[0].appName=authOrCode.name}return authOrCode._errorFactory.create(code,...fullParams)}return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode,...rest)}function _assert(assertion,authOrCode,...rest){if(!assertion){throw createErrorInternal(authOrCode,...rest)}}function debugFail(failure){const message=`INTERNAL ASSERTION FAILED: `+failure;_logError(message);throw new Error(message)}function debugAssert(assertion,message){if(!assertion){debugFail(message)}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _getCurrentUrl(){var _a;return typeof self!=="undefined"&&((_a=self.location)===null||_a===void 0?void 0:_a.href)||""}function _isHttpOrHttps(){return _getCurrentScheme()==="http:"||_getCurrentScheme()==="https:"}function _getCurrentScheme(){var _a;return typeof self!=="undefined"&&((_a=self.location)===null||_a===void 0?void 0:_a.protocol)||null}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _isOnline(){if(typeof navigator!=="undefined"&&navigator&&"onLine"in navigator&&typeof navigator.onLine==="boolean"&&(_isHttpOrHttps()||(0,_util.isBrowserExtension)()||"connection"in navigator)){return navigator.onLine}return true}function _getUserLanguage(){if(typeof navigator==="undefined"){return null}const navigatorLanguage=navigator;return navigatorLanguage.languages&&navigatorLanguage.languages[0]||navigatorLanguage.language||null}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Delay{constructor(shortDelay,longDelay){this.shortDelay=shortDelay;this.longDelay=longDelay;debugAssert(longDelay>shortDelay,"Short delay should be less than long delay!");this.isMobile=(0,_util.isMobileCordova)()||(0,_util.isReactNative)()}get(){if(!_isOnline()){return Math.min(5e3,this.shortDelay)}return this.isMobile?this.longDelay:this.shortDelay}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _emulatorUrl(config,path){debugAssert(config.emulator,"Emulator should always be set here");const{url:url}=config.emulator;if(!path){return url}return`${url}${path.startsWith("/")?path.slice(1):path}`}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class FetchProvider{static initialize(fetchImpl,headersImpl,responseImpl){this.fetchImpl=fetchImpl;if(headersImpl){this.headersImpl=headersImpl}if(responseImpl){this.responseImpl=responseImpl}}static fetch(){if(this.fetchImpl){return this.fetchImpl}if(typeof self!=="undefined"&&"fetch"in self){return self.fetch}if(typeof globalThis!=="undefined"&&globalThis.fetch){return globalThis.fetch}if(typeof fetch!=="undefined"){return fetch}debugFail("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static headers(){if(this.headersImpl){return this.headersImpl}if(typeof self!=="undefined"&&"Headers"in self){return self.Headers}if(typeof globalThis!=="undefined"&&globalThis.Headers){return globalThis.Headers}if(typeof Headers!=="undefined"){return Headers}debugFail("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static response(){if(this.responseImpl){return this.responseImpl}if(typeof self!=="undefined"&&"Response"in self){return self.Response}if(typeof globalThis!=="undefined"&&globalThis.Response){return globalThis.Response}if(typeof Response!=="undefined"){return Response}debugFail("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.aP=FetchProvider;const SERVER_ERROR_MAP={["CREDENTIAL_MISMATCH"]:"custom-token-mismatch",["MISSING_CUSTOM_TOKEN"]:"internal-error",["INVALID_IDENTIFIER"]:"invalid-email",["MISSING_CONTINUE_URI"]:"internal-error",["INVALID_PASSWORD"]:"wrong-password",["MISSING_PASSWORD"]:"missing-password",["INVALID_LOGIN_CREDENTIALS"]:"invalid-credential",["EMAIL_EXISTS"]:"email-already-in-use",["PASSWORD_LOGIN_DISABLED"]:"operation-not-allowed",["INVALID_IDP_RESPONSE"]:"invalid-credential",["INVALID_PENDING_TOKEN"]:"invalid-credential",["FEDERATED_USER_ID_ALREADY_LINKED"]:"credential-already-in-use",["MISSING_REQ_TYPE"]:"internal-error",["EMAIL_NOT_FOUND"]:"user-not-found",["RESET_PASSWORD_EXCEED_LIMIT"]:"too-many-requests",["EXPIRED_OOB_CODE"]:"expired-action-code",["INVALID_OOB_CODE"]:"invalid-action-code",["MISSING_OOB_CODE"]:"internal-error",["CREDENTIAL_TOO_OLD_LOGIN_AGAIN"]:"requires-recent-login",["INVALID_ID_TOKEN"]:"invalid-user-token",["TOKEN_EXPIRED"]:"user-token-expired",["USER_NOT_FOUND"]:"user-token-expired",["TOO_MANY_ATTEMPTS_TRY_LATER"]:"too-many-requests",["PASSWORD_DOES_NOT_MEET_REQUIREMENTS"]:"password-does-not-meet-requirements",["INVALID_CODE"]:"invalid-verification-code",["INVALID_SESSION_INFO"]:"invalid-verification-id",["INVALID_TEMPORARY_PROOF"]:"invalid-credential",["MISSING_SESSION_INFO"]:"missing-verification-id",["SESSION_EXPIRED"]:"code-expired",["MISSING_ANDROID_PACKAGE_NAME"]:"missing-android-pkg-name",["UNAUTHORIZED_DOMAIN"]:"unauthorized-continue-uri",["INVALID_OAUTH_CLIENT_ID"]:"invalid-oauth-client-id",["ADMIN_ONLY_OPERATION"]:"admin-restricted-operation",["INVALID_MFA_PENDING_CREDENTIAL"]:"invalid-multi-factor-session",["MFA_ENROLLMENT_NOT_FOUND"]:"multi-factor-info-not-found",["MISSING_MFA_ENROLLMENT_ID"]:"missing-multi-factor-info",["MISSING_MFA_PENDING_CREDENTIAL"]:"missing-multi-factor-session",["SECOND_FACTOR_EXISTS"]:"second-factor-already-in-use",["SECOND_FACTOR_LIMIT_EXCEEDED"]:"maximum-second-factor-count-exceeded",["BLOCKING_FUNCTION_ERROR_RESPONSE"]:"internal-error",["RECAPTCHA_NOT_ENABLED"]:"recaptcha-not-enabled",["MISSING_RECAPTCHA_TOKEN"]:"missing-recaptcha-token",["INVALID_RECAPTCHA_TOKEN"]:"invalid-recaptcha-token",["INVALID_RECAPTCHA_ACTION"]:"invalid-recaptcha-action",["MISSING_CLIENT_TYPE"]:"missing-client-type",["MISSING_RECAPTCHA_VERSION"]:"missing-recaptcha-version",["INVALID_RECAPTCHA_VERSION"]:"invalid-recaptcha-version",["INVALID_REQ_TYPE"]:"invalid-req-type"};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const DEFAULT_API_TIMEOUT_MS=new Delay(3e4,6e4);function _addTidIfNecessary(auth,request){if(auth.tenantId&&!request.tenantId){return Object.assign(Object.assign({},request),{tenantId:auth.tenantId})}return request}async function _performApiRequest(auth,method,path,request,customErrorMap={}){return _performFetchWithErrorHandling(auth,customErrorMap,(async()=>{let body={};let params={};if(request){if(method==="GET"){params=request}else{body={body:JSON.stringify(request)}}}const query=(0,_util.querystring)(Object.assign({key:auth.config.apiKey},params)).slice(1);const headers=await auth._getAdditionalHeaders();headers["Content-Type"]="application/json";if(auth.languageCode){headers["X-Firebase-Locale"]=auth.languageCode}return FetchProvider.fetch()(_getFinalTarget(auth,auth.config.apiHost,path,query),Object.assign({method:method,headers:headers,referrerPolicy:"no-referrer"},body))}))}async function _performFetchWithErrorHandling(auth,customErrorMap,fetchFn){auth._canInitEmulator=false;const errorMap=Object.assign(Object.assign({},SERVER_ERROR_MAP),customErrorMap);try{const networkTimeout=new NetworkTimeout(auth);const response=await Promise.race([fetchFn(),networkTimeout.promise]);networkTimeout.clearNetworkTimeout();const json=await response.json();if("needConfirmation"in json){throw _makeTaggedError(auth,"account-exists-with-different-credential",json)}if(response.ok&&!("errorMessage"in json)){return json}else{const errorMessage=response.ok?json.errorMessage:json.error.message;const[serverErrorCode,serverErrorMessage]=errorMessage.split(" : ");if(serverErrorCode==="FEDERATED_USER_ID_ALREADY_LINKED"){throw _makeTaggedError(auth,"credential-already-in-use",json)}else if(serverErrorCode==="EMAIL_EXISTS"){throw _makeTaggedError(auth,"email-already-in-use",json)}else if(serverErrorCode==="USER_DISABLED"){throw _makeTaggedError(auth,"user-disabled",json)}const authError=errorMap[serverErrorCode]||serverErrorCode.toLowerCase().replace(/[_\s]+/g,"-");if(serverErrorMessage){throw _errorWithCustomMessage(auth,authError,serverErrorMessage)}else{_fail(auth,authError)}}}catch(e){if(e instanceof _util.FirebaseError){throw e}_fail(auth,"network-request-failed",{message:String(e)})}}async function _performSignInRequest(auth,method,path,request,customErrorMap={}){const serverResponse=await _performApiRequest(auth,method,path,request,customErrorMap);if("mfaPendingCredential"in serverResponse){_fail(auth,"multi-factor-auth-required",{_serverResponse:serverResponse})}return serverResponse}function _getFinalTarget(auth,host,path,query){const base=`${host}${path}?${query}`;if(!auth.config.emulator){return`${auth.config.apiScheme}://${base}`}return _emulatorUrl(auth.config,base)}function _parseEnforcementState(enforcementStateStr){switch(enforcementStateStr){case"ENFORCE":return"ENFORCE";case"AUDIT":return"AUDIT";case"OFF":return"OFF";default:return"ENFORCEMENT_STATE_UNSPECIFIED"}}class NetworkTimeout{constructor(auth){this.auth=auth;this.timer=null;this.promise=new Promise(((_,reject)=>{this.timer=setTimeout((()=>reject(_createError(this.auth,"network-request-failed"))),DEFAULT_API_TIMEOUT_MS.get())}))}clearNetworkTimeout(){clearTimeout(this.timer)}}function _makeTaggedError(auth,code,response){const errorParams={appName:auth.name};if(response.email){errorParams.email=response.email}if(response.phoneNumber){errorParams.phoneNumber=response.phoneNumber}const error=_createError(auth,code,errorParams);error.customData._tokenResponse=response;return error}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function isV2(grecaptcha){return grecaptcha!==undefined&&grecaptcha.getResponse!==undefined}function isEnterprise(grecaptcha){return grecaptcha!==undefined&&grecaptcha.enterprise!==undefined}class RecaptchaConfig{constructor(response){this.siteKey="";this.recaptchaEnforcementState=[];if(response.recaptchaKey===undefined){throw new Error("recaptchaKey undefined")}this.siteKey=response.recaptchaKey.split("/")[3];this.recaptchaEnforcementState=response.recaptchaEnforcementState}getProviderEnforcementState(providerStr){if(!this.recaptchaEnforcementState||this.recaptchaEnforcementState.length===0){return null}for(const recaptchaEnforcementState of this.recaptchaEnforcementState){if(recaptchaEnforcementState.provider&&recaptchaEnforcementState.provider===providerStr){return _parseEnforcementState(recaptchaEnforcementState.enforcementState)}}return null}isProviderEnabled(providerStr){return this.getProviderEnforcementState(providerStr)==="ENFORCE"||this.getProviderEnforcementState(providerStr)==="AUDIT"}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function getRecaptchaParams(auth){return(await _performApiRequest(auth,"GET","/v1/recaptchaParams")).recaptchaSiteKey||""}async function getRecaptchaConfig(auth,request){return _performApiRequest(auth,"GET","/v2/recaptchaConfig",_addTidIfNecessary(auth,request))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function deleteAccount(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:delete",request)}async function deleteLinkedAccounts(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:update",request)}async function getAccountInfo(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:lookup",request)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function utcTimestampToDateString(utcTimestamp){if(!utcTimestamp){return undefined}try{const date=new Date(Number(utcTimestamp));if(!isNaN(date.getTime())){return date.toUTCString()}}catch(e){}return undefined}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function getIdToken(user,forceRefresh=false){return(0,_util.getModularInstance)(user).getIdToken(forceRefresh)}async function getIdTokenResult(user,forceRefresh=false){const userInternal=(0,_util.getModularInstance)(user);const token=await userInternal.getIdToken(forceRefresh);const claims=_parseToken(token);_assert(claims&&claims.exp&&claims.auth_time&&claims.iat,userInternal.auth,"internal-error");const firebase=typeof claims.firebase==="object"?claims.firebase:undefined;const signInProvider=firebase===null||firebase===void 0?void 0:firebase["sign_in_provider"];return{claims:claims,token:token,authTime:utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),issuedAtTime:utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),expirationTime:utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),signInProvider:signInProvider||null,signInSecondFactor:(firebase===null||firebase===void 0?void 0:firebase["sign_in_second_factor"])||null}}function secondsStringToMilliseconds(seconds){return Number(seconds)*1e3}function _parseToken(token){const[algorithm,payload,signature]=token.split(".");if(algorithm===undefined||payload===undefined||signature===undefined){_logError("JWT malformed, contained fewer than 3 sections");return null}try{const decoded=(0,_util.base64Decode)(payload);if(!decoded){_logError("Failed to decode base64 JWT payload");return null}return JSON.parse(decoded)}catch(e){_logError("Caught error parsing JWT payload as JSON",e===null||e===void 0?void 0:e.toString());return null}}function _tokenExpiresIn(token){const parsedToken=_parseToken(token);_assert(parsedToken,"internal-error");_assert(typeof parsedToken.exp!=="undefined","internal-error");_assert(typeof parsedToken.iat!=="undefined","internal-error");return Number(parsedToken.exp)-Number(parsedToken.iat)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function _logoutIfInvalidated(user,promise,bypassAuthState=false){if(bypassAuthState){return promise}try{return await promise}catch(e){if(e instanceof _util.FirebaseError&&isUserInvalidated(e)){if(user.auth.currentUser===user){await user.auth.signOut()}}throw e}}function isUserInvalidated({code:code}){return code===`auth/${"user-disabled"}`||code===`auth/${"user-token-expired"}`}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ProactiveRefresh{constructor(user){this.user=user;this.isRunning=false;this.timerId=null;this.errorBackoff=3e4}_start(){if(this.isRunning){return}this.isRunning=true;this.schedule()}_stop(){if(!this.isRunning){return}this.isRunning=false;if(this.timerId!==null){clearTimeout(this.timerId)}}getInterval(wasError){var _a;if(wasError){const interval=this.errorBackoff;this.errorBackoff=Math.min(this.errorBackoff*2,96e4);return interval}else{this.errorBackoff=3e4;const expTime=(_a=this.user.stsTokenManager.expirationTime)!==null&&_a!==void 0?_a:0;const interval=expTime-Date.now()-3e5;return Math.max(0,interval)}}schedule(wasError=false){if(!this.isRunning){return}const interval=this.getInterval(wasError);this.timerId=setTimeout((async()=>{await this.iteration()}),interval)}async iteration(){try{await this.user.getIdToken(true)}catch(e){if((e===null||e===void 0?void 0:e.code)===`auth/${"network-request-failed"}`){this.schedule(true)}return}this.schedule()}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class UserMetadata{constructor(createdAt,lastLoginAt){this.createdAt=createdAt;this.lastLoginAt=lastLoginAt;this._initializeTime()}_initializeTime(){this.lastSignInTime=utcTimestampToDateString(this.lastLoginAt);this.creationTime=utcTimestampToDateString(this.createdAt)}_copy(metadata){this.createdAt=metadata.createdAt;this.lastLoginAt=metadata.lastLoginAt;this._initializeTime()}toJSON(){return{createdAt:this.createdAt,lastLoginAt:this.lastLoginAt}}}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function _reloadWithoutSaving(user){var _a;const auth=user.auth;const idToken=await user.getIdToken();const response=await _logoutIfInvalidated(user,getAccountInfo(auth,{idToken:idToken}));_assert(response===null||response===void 0?void 0:response.users.length,auth,"internal-error");const coreAccount=response.users[0];user._notifyReloadListener(coreAccount);const newProviderData=((_a=coreAccount.providerUserInfo)===null||_a===void 0?void 0:_a.length)?extractProviderData(coreAccount.providerUserInfo):[];const providerData=mergeProviderData(user.providerData,newProviderData);const oldIsAnonymous=user.isAnonymous;const newIsAnonymous=!(user.email&&coreAccount.passwordHash)&&!(providerData===null||providerData===void 0?void 0:providerData.length);const isAnonymous=!oldIsAnonymous?false:newIsAnonymous;const updates={uid:coreAccount.localId,displayName:coreAccount.displayName||null,photoURL:coreAccount.photoUrl||null,email:coreAccount.email||null,emailVerified:coreAccount.emailVerified||false,phoneNumber:coreAccount.phoneNumber||null,tenantId:coreAccount.tenantId||null,providerData:providerData,metadata:new UserMetadata(coreAccount.createdAt,coreAccount.lastLoginAt),isAnonymous:isAnonymous};Object.assign(user,updates)}async function reload(user){const userInternal=(0,_util.getModularInstance)(user);await _reloadWithoutSaving(userInternal);await userInternal.auth._persistUserIfCurrent(userInternal);userInternal.auth._notifyListenersIfCurrent(userInternal)}function mergeProviderData(original,newData){const deduped=original.filter((o=>!newData.some((n=>n.providerId===o.providerId))));return[...deduped,...newData]}function extractProviderData(providers){return providers.map((_a=>{var{providerId:providerId}=_a,provider=(0,_tslib.__rest)(_a,["providerId"]);return{providerId:providerId,uid:provider.rawId||"",displayName:provider.displayName||null,email:provider.email||null,phoneNumber:provider.phoneNumber||null,photoURL:provider.photoUrl||null}}))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function requestStsToken(auth,refreshToken){const response=await _performFetchWithErrorHandling(auth,{},(async()=>{const body=(0,_util.querystring)({grant_type:"refresh_token",refresh_token:refreshToken}).slice(1);const{tokenApiHost:tokenApiHost,apiKey:apiKey}=auth.config;const url=_getFinalTarget(auth,tokenApiHost,"/v1/token",`key=${apiKey}`);const headers=await auth._getAdditionalHeaders();headers["Content-Type"]="application/x-www-form-urlencoded";return FetchProvider.fetch()(url,{method:"POST",headers:headers,body:body})}));return{accessToken:response.access_token,expiresIn:response.expires_in,refreshToken:response.refresh_token}}async function revokeToken(auth,request){return _performApiRequest(auth,"POST","/v2/accounts:revokeToken",_addTidIfNecessary(auth,request))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class StsTokenManager{constructor(){this.refreshToken=null;this.accessToken=null;this.expirationTime=null}get isExpired(){return!this.expirationTime||Date.now()>this.expirationTime-3e4}updateFromServerResponse(response){_assert(response.idToken,"internal-error");_assert(typeof response.idToken!=="undefined","internal-error");_assert(typeof response.refreshToken!=="undefined","internal-error");const expiresIn="expiresIn"in response&&typeof response.expiresIn!=="undefined"?Number(response.expiresIn):_tokenExpiresIn(response.idToken);this.updateTokensAndExpiration(response.idToken,response.refreshToken,expiresIn)}updateFromIdToken(idToken){_assert(idToken.length!==0,"internal-error");const expiresIn=_tokenExpiresIn(idToken);this.updateTokensAndExpiration(idToken,null,expiresIn)}async getToken(auth,forceRefresh=false){if(!forceRefresh&&this.accessToken&&!this.isExpired){return this.accessToken}_assert(this.refreshToken,auth,"user-token-expired");if(this.refreshToken){await this.refresh(auth,this.refreshToken);return this.accessToken}return null}clearRefreshToken(){this.refreshToken=null}async refresh(auth,oldToken){const{accessToken:accessToken,refreshToken:refreshToken,expiresIn:expiresIn}=await requestStsToken(auth,oldToken);this.updateTokensAndExpiration(accessToken,refreshToken,Number(expiresIn))}updateTokensAndExpiration(accessToken,refreshToken,expiresInSec){this.refreshToken=refreshToken||null;this.accessToken=accessToken||null;this.expirationTime=Date.now()+expiresInSec*1e3}static fromJSON(appName,object){const{refreshToken:refreshToken,accessToken:accessToken,expirationTime:expirationTime}=object;const manager=new StsTokenManager;if(refreshToken){_assert(typeof refreshToken==="string","internal-error",{appName:appName});manager.refreshToken=refreshToken}if(accessToken){_assert(typeof accessToken==="string","internal-error",{appName:appName});manager.accessToken=accessToken}if(expirationTime){_assert(typeof expirationTime==="number","internal-error",{appName:appName});manager.expirationTime=expirationTime}return manager}toJSON(){return{refreshToken:this.refreshToken,accessToken:this.accessToken,expirationTime:this.expirationTime}}_assign(stsTokenManager){this.accessToken=stsTokenManager.accessToken;this.refreshToken=stsTokenManager.refreshToken;this.expirationTime=stsTokenManager.expirationTime}_clone(){return Object.assign(new StsTokenManager,this.toJSON())}_performRefresh(){return debugFail("not implemented")}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function assertStringOrUndefined(assertion,appName){_assert(typeof assertion==="string"||typeof assertion==="undefined","internal-error",{appName:appName})}class UserImpl{constructor(_a){var{uid:uid,auth:auth,stsTokenManager:stsTokenManager}=_a,opt=(0,_tslib.__rest)(_a,["uid","auth","stsTokenManager"]);this.providerId="firebase";this.proactiveRefresh=new ProactiveRefresh(this);this.reloadUserInfo=null;this.reloadListener=null;this.uid=uid;this.auth=auth;this.stsTokenManager=stsTokenManager;this.accessToken=stsTokenManager.accessToken;this.displayName=opt.displayName||null;this.email=opt.email||null;this.emailVerified=opt.emailVerified||false;this.phoneNumber=opt.phoneNumber||null;this.photoURL=opt.photoURL||null;this.isAnonymous=opt.isAnonymous||false;this.tenantId=opt.tenantId||null;this.providerData=opt.providerData?[...opt.providerData]:[];this.metadata=new UserMetadata(opt.createdAt||undefined,opt.lastLoginAt||undefined)}async getIdToken(forceRefresh){const accessToken=await _logoutIfInvalidated(this,this.stsTokenManager.getToken(this.auth,forceRefresh));_assert(accessToken,this.auth,"internal-error");if(this.accessToken!==accessToken){this.accessToken=accessToken;await this.auth._persistUserIfCurrent(this);this.auth._notifyListenersIfCurrent(this)}return accessToken}getIdTokenResult(forceRefresh){return getIdTokenResult(this,forceRefresh)}reload(){return reload(this)}_assign(user){if(this===user){return}_assert(this.uid===user.uid,this.auth,"internal-error");this.displayName=user.displayName;this.photoURL=user.photoURL;this.email=user.email;this.emailVerified=user.emailVerified;this.phoneNumber=user.phoneNumber;this.isAnonymous=user.isAnonymous;this.tenantId=user.tenantId;this.providerData=user.providerData.map((userInfo=>Object.assign({},userInfo)));this.metadata._copy(user.metadata);this.stsTokenManager._assign(user.stsTokenManager)}_clone(auth){const newUser=new UserImpl(Object.assign(Object.assign({},this),{auth:auth,stsTokenManager:this.stsTokenManager._clone()}));newUser.metadata._copy(this.metadata);return newUser}_onReload(callback){_assert(!this.reloadListener,this.auth,"internal-error");this.reloadListener=callback;if(this.reloadUserInfo){this._notifyReloadListener(this.reloadUserInfo);this.reloadUserInfo=null}}_notifyReloadListener(userInfo){if(this.reloadListener){this.reloadListener(userInfo)}else{this.reloadUserInfo=userInfo}}_startProactiveRefresh(){this.proactiveRefresh._start()}_stopProactiveRefresh(){this.proactiveRefresh._stop()}async _updateTokensIfNecessary(response,reload=false){let tokensRefreshed=false;if(response.idToken&&response.idToken!==this.stsTokenManager.accessToken){this.stsTokenManager.updateFromServerResponse(response);tokensRefreshed=true}if(reload){await _reloadWithoutSaving(this)}await this.auth._persistUserIfCurrent(this);if(tokensRefreshed){this.auth._notifyListenersIfCurrent(this)}}async delete(){if((0,_app._isFirebaseServerApp)(this.auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this.auth))}const idToken=await this.getIdToken();await _logoutIfInvalidated(this,deleteAccount(this.auth,{idToken:idToken}));this.stsTokenManager.clearRefreshToken();return this.auth.signOut()}toJSON(){return Object.assign(Object.assign({uid:this.uid,email:this.email||undefined,emailVerified:this.emailVerified,displayName:this.displayName||undefined,isAnonymous:this.isAnonymous,photoURL:this.photoURL||undefined,phoneNumber:this.phoneNumber||undefined,tenantId:this.tenantId||undefined,providerData:this.providerData.map((userInfo=>Object.assign({},userInfo))),stsTokenManager:this.stsTokenManager.toJSON(),_redirectEventId:this._redirectEventId},this.metadata.toJSON()),{apiKey:this.auth.config.apiKey,appName:this.auth.name})}get refreshToken(){return this.stsTokenManager.refreshToken||""}static _fromJSON(auth,object){var _a,_b,_c,_d,_e,_f,_g,_h;const displayName=(_a=object.displayName)!==null&&_a!==void 0?_a:undefined;const email=(_b=object.email)!==null&&_b!==void 0?_b:undefined;const phoneNumber=(_c=object.phoneNumber)!==null&&_c!==void 0?_c:undefined;const photoURL=(_d=object.photoURL)!==null&&_d!==void 0?_d:undefined;const tenantId=(_e=object.tenantId)!==null&&_e!==void 0?_e:undefined;const _redirectEventId=(_f=object._redirectEventId)!==null&&_f!==void 0?_f:undefined;const createdAt=(_g=object.createdAt)!==null&&_g!==void 0?_g:undefined;const lastLoginAt=(_h=object.lastLoginAt)!==null&&_h!==void 0?_h:undefined;const{uid:uid,emailVerified:emailVerified,isAnonymous:isAnonymous,providerData:providerData,stsTokenManager:plainObjectTokenManager}=object;_assert(uid&&plainObjectTokenManager,auth,"internal-error");const stsTokenManager=StsTokenManager.fromJSON(this.name,plainObjectTokenManager);_assert(typeof uid==="string",auth,"internal-error");assertStringOrUndefined(displayName,auth.name);assertStringOrUndefined(email,auth.name);_assert(typeof emailVerified==="boolean",auth,"internal-error");_assert(typeof isAnonymous==="boolean",auth,"internal-error");assertStringOrUndefined(phoneNumber,auth.name);assertStringOrUndefined(photoURL,auth.name);assertStringOrUndefined(tenantId,auth.name);assertStringOrUndefined(_redirectEventId,auth.name);assertStringOrUndefined(createdAt,auth.name);assertStringOrUndefined(lastLoginAt,auth.name);const user=new UserImpl({uid:uid,auth:auth,email:email,emailVerified:emailVerified,displayName:displayName,isAnonymous:isAnonymous,photoURL:photoURL,phoneNumber:phoneNumber,tenantId:tenantId,stsTokenManager:stsTokenManager,createdAt:createdAt,lastLoginAt:lastLoginAt});if(providerData&&Array.isArray(providerData)){user.providerData=providerData.map((userInfo=>Object.assign({},userInfo)))}if(_redirectEventId){user._redirectEventId=_redirectEventId}return user}static async _fromIdTokenResponse(auth,idTokenResponse,isAnonymous=false){const stsTokenManager=new StsTokenManager;stsTokenManager.updateFromServerResponse(idTokenResponse);const user=new UserImpl({uid:idTokenResponse.localId,auth:auth,stsTokenManager:stsTokenManager,isAnonymous:isAnonymous});await _reloadWithoutSaving(user);return user}static async _fromGetAccountInfoResponse(auth,response,idToken){const coreAccount=response.users[0];_assert(coreAccount.localId!==undefined,"internal-error");const providerData=coreAccount.providerUserInfo!==undefined?extractProviderData(coreAccount.providerUserInfo):[];const isAnonymous=!(coreAccount.email&&coreAccount.passwordHash)&&!(providerData===null||providerData===void 0?void 0:providerData.length);const stsTokenManager=new StsTokenManager;stsTokenManager.updateFromIdToken(idToken);const user=new UserImpl({uid:coreAccount.localId,auth:auth,stsTokenManager:stsTokenManager,isAnonymous:isAnonymous});const updates={uid:coreAccount.localId,displayName:coreAccount.displayName||null,photoURL:coreAccount.photoUrl||null,email:coreAccount.email||null,emailVerified:coreAccount.emailVerified||false,phoneNumber:coreAccount.phoneNumber||null,tenantId:coreAccount.tenantId||null,providerData:providerData,metadata:new UserMetadata(coreAccount.createdAt,coreAccount.lastLoginAt),isAnonymous:!(coreAccount.email&&coreAccount.passwordHash)&&!(providerData===null||providerData===void 0?void 0:providerData.length)};Object.assign(user,updates);return user}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.aK=UserImpl;const instanceCache=new Map;function _getInstance(cls){debugAssert(cls instanceof Function,"Expected a class definition");let instance=instanceCache.get(cls);if(instance){debugAssert(instance instanceof cls,"Instance stored in cache mismatched with class");return instance}instance=new cls;instanceCache.set(cls,instance);return instance}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class InMemoryPersistence{constructor(){this.type="NONE";this.storage={}}async _isAvailable(){return true}async _set(key,value){this.storage[key]=value}async _get(key){const value=this.storage[key];return value===undefined?null:value}async _remove(key){delete this.storage[key]}_addListener(_key,_listener){return}_removeListener(_key,_listener){return}}InMemoryPersistence.type="NONE";const inMemoryPersistence=InMemoryPersistence;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.U=inMemoryPersistence;function _persistenceKeyName(key,apiKey,appName){return`${"firebase"}:${key}:${apiKey}:${appName}`}class PersistenceUserManager{constructor(persistence,auth,userKey){this.persistence=persistence;this.auth=auth;this.userKey=userKey;const{config:config,name:name}=this.auth;this.fullUserKey=_persistenceKeyName(this.userKey,config.apiKey,name);this.fullPersistenceKey=_persistenceKeyName("persistence",config.apiKey,name);this.boundEventHandler=auth._onStorageEvent.bind(auth);this.persistence._addListener(this.fullUserKey,this.boundEventHandler)}setCurrentUser(user){return this.persistence._set(this.fullUserKey,user.toJSON())}async getCurrentUser(){const blob=await this.persistence._get(this.fullUserKey);return blob?UserImpl._fromJSON(this.auth,blob):null}removeCurrentUser(){return this.persistence._remove(this.fullUserKey)}savePersistenceForRedirect(){return this.persistence._set(this.fullPersistenceKey,this.persistence.type)}async setPersistence(newPersistence){if(this.persistence===newPersistence){return}const currentUser=await this.getCurrentUser();await this.removeCurrentUser();this.persistence=newPersistence;if(currentUser){return this.setCurrentUser(currentUser)}}delete(){this.persistence._removeListener(this.fullUserKey,this.boundEventHandler)}static async create(auth,persistenceHierarchy,userKey="authUser"){if(!persistenceHierarchy.length){return new PersistenceUserManager(_getInstance(inMemoryPersistence),auth,userKey)}const availablePersistences=(await Promise.all(persistenceHierarchy.map((async persistence=>{if(await persistence._isAvailable()){return persistence}return undefined})))).filter((persistence=>persistence));let selectedPersistence=availablePersistences[0]||_getInstance(inMemoryPersistence);const key=_persistenceKeyName(userKey,auth.config.apiKey,auth.name);let userToMigrate=null;for(const persistence of persistenceHierarchy){try{const blob=await persistence._get(key);if(blob){const user=UserImpl._fromJSON(auth,blob);if(persistence!==selectedPersistence){userToMigrate=user}selectedPersistence=persistence;break}}catch(_a){}}const migrationHierarchy=availablePersistences.filter((p=>p._shouldAllowMigration));if(!selectedPersistence._shouldAllowMigration||!migrationHierarchy.length){return new PersistenceUserManager(selectedPersistence,auth,userKey)}selectedPersistence=migrationHierarchy[0];if(userToMigrate){await selectedPersistence._set(key,userToMigrate.toJSON())}await Promise.all(persistenceHierarchy.map((async persistence=>{if(persistence!==selectedPersistence){try{await persistence._remove(key)}catch(_a){}}})));return new PersistenceUserManager(selectedPersistence,auth,userKey)}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _getBrowserName(userAgent){const ua=userAgent.toLowerCase();if(ua.includes("opera/")||ua.includes("opr/")||ua.includes("opios/")){return"Opera"}else if(_isIEMobile(ua)){return"IEMobile"}else if(ua.includes("msie")||ua.includes("trident/")){return"IE"}else if(ua.includes("edge/")){return"Edge"}else if(_isFirefox(ua)){return"Firefox"}else if(ua.includes("silk/")){return"Silk"}else if(_isBlackBerry(ua)){return"Blackberry"}else if(_isWebOS(ua)){return"Webos"}else if(_isSafari(ua)){return"Safari"}else if((ua.includes("chrome/")||_isChromeIOS(ua))&&!ua.includes("edge/")){return"Chrome"}else if(_isAndroid(ua)){return"Android"}else{const re=/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;const matches=userAgent.match(re);if((matches===null||matches===void 0?void 0:matches.length)===2){return matches[1]}}return"Other"}function _isFirefox(ua=(0,_util.getUA)()){return/firefox\//i.test(ua)}function _isSafari(userAgent=(0,_util.getUA)()){const ua=userAgent.toLowerCase();return ua.includes("safari/")&&!ua.includes("chrome/")&&!ua.includes("crios/")&&!ua.includes("android")}function _isChromeIOS(ua=(0,_util.getUA)()){return/crios\//i.test(ua)}function _isIEMobile(ua=(0,_util.getUA)()){return/iemobile/i.test(ua)}function _isAndroid(ua=(0,_util.getUA)()){return/android/i.test(ua)}function _isBlackBerry(ua=(0,_util.getUA)()){return/blackberry/i.test(ua)}function _isWebOS(ua=(0,_util.getUA)()){return/webos/i.test(ua)}function _isIOS(ua=(0,_util.getUA)()){return/iphone|ipad|ipod/i.test(ua)||/macintosh/i.test(ua)&&/mobile/i.test(ua)}function _isIOS7Or8(ua=(0,_util.getUA)()){return/(iPad|iPhone|iPod).*OS 7_\d/i.test(ua)||/(iPad|iPhone|iPod).*OS 8_\d/i.test(ua)}function _isIOSStandalone(ua=(0,_util.getUA)()){var _a;return _isIOS(ua)&&!!((_a=window.navigator)===null||_a===void 0?void 0:_a.standalone)}function _isIE10(){return(0,_util.isIE)()&&document.documentMode===10}function _isMobileBrowser(ua=(0,_util.getUA)()){return _isIOS(ua)||_isAndroid(ua)||_isWebOS(ua)||_isBlackBerry(ua)||/windows phone/i.test(ua)||_isIEMobile(ua)}function _isIframe(){try{return!!(window&&window!==window.top)}catch(e){return false}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _getClientVersion(clientPlatform,frameworks=[]){let reportedPlatform;switch(clientPlatform){case"Browser":reportedPlatform=_getBrowserName((0,_util.getUA)());break;case"Worker":reportedPlatform=`${_getBrowserName((0,_util.getUA)())}-${clientPlatform}`;break;default:reportedPlatform=clientPlatform}const reportedFrameworks=frameworks.length?frameworks.join(","):"FirebaseCore-web";return`${reportedPlatform}/${"JsCore"}/${_app.SDK_VERSION}/${reportedFrameworks}`}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class AuthMiddlewareQueue{constructor(auth){this.auth=auth;this.queue=[]}pushCallback(callback,onAbort){const wrappedCallback=user=>new Promise(((resolve,reject)=>{try{const result=callback(user);resolve(result)}catch(e){reject(e)}}));wrappedCallback.onAbort=onAbort;this.queue.push(wrappedCallback);const index=this.queue.length-1;return()=>{this.queue[index]=()=>Promise.resolve()}}async runMiddleware(nextUser){if(this.auth.currentUser===nextUser){return}const onAbortStack=[];try{for(const beforeStateCallback of this.queue){await beforeStateCallback(nextUser);if(beforeStateCallback.onAbort){onAbortStack.push(beforeStateCallback.onAbort)}}}catch(e){onAbortStack.reverse();for(const onAbort of onAbortStack){try{onAbort()}catch(_){}}throw this.auth._errorFactory.create("login-blocked",{originalMessage:e===null||e===void 0?void 0:e.message})}}}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function _getPasswordPolicy(auth,request={}){return _performApiRequest(auth,"GET","/v2/passwordPolicy",_addTidIfNecessary(auth,request))}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const MINIMUM_MIN_PASSWORD_LENGTH=6;class PasswordPolicyImpl{constructor(response){var _a,_b,_c,_d;const responseOptions=response.customStrengthOptions;this.customStrengthOptions={};this.customStrengthOptions.minPasswordLength=(_a=responseOptions.minPasswordLength)!==null&&_a!==void 0?_a:MINIMUM_MIN_PASSWORD_LENGTH;if(responseOptions.maxPasswordLength){this.customStrengthOptions.maxPasswordLength=responseOptions.maxPasswordLength}if(responseOptions.containsLowercaseCharacter!==undefined){this.customStrengthOptions.containsLowercaseLetter=responseOptions.containsLowercaseCharacter}if(responseOptions.containsUppercaseCharacter!==undefined){this.customStrengthOptions.containsUppercaseLetter=responseOptions.containsUppercaseCharacter}if(responseOptions.containsNumericCharacter!==undefined){this.customStrengthOptions.containsNumericCharacter=responseOptions.containsNumericCharacter}if(responseOptions.containsNonAlphanumericCharacter!==undefined){this.customStrengthOptions.containsNonAlphanumericCharacter=responseOptions.containsNonAlphanumericCharacter}this.enforcementState=response.enforcementState;if(this.enforcementState==="ENFORCEMENT_STATE_UNSPECIFIED"){this.enforcementState="OFF"}this.allowedNonAlphanumericCharacters=(_c=(_b=response.allowedNonAlphanumericCharacters)===null||_b===void 0?void 0:_b.join(""))!==null&&_c!==void 0?_c:"";this.forceUpgradeOnSignin=(_d=response.forceUpgradeOnSignin)!==null&&_d!==void 0?_d:false;this.schemaVersion=response.schemaVersion}validatePassword(password){var _a,_b,_c,_d,_e,_f;const status={isValid:true,passwordPolicy:this};this.validatePasswordLengthOptions(password,status);this.validatePasswordCharacterOptions(password,status);status.isValid&&(status.isValid=(_a=status.meetsMinPasswordLength)!==null&&_a!==void 0?_a:true);status.isValid&&(status.isValid=(_b=status.meetsMaxPasswordLength)!==null&&_b!==void 0?_b:true);status.isValid&&(status.isValid=(_c=status.containsLowercaseLetter)!==null&&_c!==void 0?_c:true);status.isValid&&(status.isValid=(_d=status.containsUppercaseLetter)!==null&&_d!==void 0?_d:true);status.isValid&&(status.isValid=(_e=status.containsNumericCharacter)!==null&&_e!==void 0?_e:true);status.isValid&&(status.isValid=(_f=status.containsNonAlphanumericCharacter)!==null&&_f!==void 0?_f:true);return status}validatePasswordLengthOptions(password,status){const minPasswordLength=this.customStrengthOptions.minPasswordLength;const maxPasswordLength=this.customStrengthOptions.maxPasswordLength;if(minPasswordLength){status.meetsMinPasswordLength=password.length>=minPasswordLength}if(maxPasswordLength){status.meetsMaxPasswordLength=password.length<=maxPasswordLength}}validatePasswordCharacterOptions(password,status){this.updatePasswordCharacterOptionsStatuses(status,false,false,false,false);let passwordChar;for(let i=0;i<password.length;i++){passwordChar=password.charAt(i);this.updatePasswordCharacterOptionsStatuses(status,passwordChar>="a"&&passwordChar<="z",passwordChar>="A"&&passwordChar<="Z",passwordChar>="0"&&passwordChar<="9",this.allowedNonAlphanumericCharacters.includes(passwordChar))}}updatePasswordCharacterOptionsStatuses(status,containsLowercaseCharacter,containsUppercaseCharacter,containsNumericCharacter,containsNonAlphanumericCharacter){if(this.customStrengthOptions.containsLowercaseLetter){status.containsLowercaseLetter||(status.containsLowercaseLetter=containsLowercaseCharacter)}if(this.customStrengthOptions.containsUppercaseLetter){status.containsUppercaseLetter||(status.containsUppercaseLetter=containsUppercaseCharacter)}if(this.customStrengthOptions.containsNumericCharacter){status.containsNumericCharacter||(status.containsNumericCharacter=containsNumericCharacter)}if(this.customStrengthOptions.containsNonAlphanumericCharacter){status.containsNonAlphanumericCharacter||(status.containsNonAlphanumericCharacter=containsNonAlphanumericCharacter)}}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class AuthImpl{constructor(app,heartbeatServiceProvider,appCheckServiceProvider,config){this.app=app;this.heartbeatServiceProvider=heartbeatServiceProvider;this.appCheckServiceProvider=appCheckServiceProvider;this.config=config;this.currentUser=null;this.emulatorConfig=null;this.operations=Promise.resolve();this.authStateSubscription=new Subscription(this);this.idTokenSubscription=new Subscription(this);this.beforeStateQueue=new AuthMiddlewareQueue(this);this.redirectUser=null;this.isProactiveRefreshEnabled=false;this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION=1;this._canInitEmulator=true;this._isInitialized=false;this._deleted=false;this._initializationPromise=null;this._popupRedirectResolver=null;this._errorFactory=_DEFAULT_AUTH_ERROR_FACTORY;this._agentRecaptchaConfig=null;this._tenantRecaptchaConfigs={};this._projectPasswordPolicy=null;this._tenantPasswordPolicies={};this.lastNotifiedUid=undefined;this.languageCode=null;this.tenantId=null;this.settings={appVerificationDisabledForTesting:false};this.frameworks=[];this.name=app.name;this.clientVersion=config.sdkClientVersion}_initializeWithPersistence(persistenceHierarchy,popupRedirectResolver){if(popupRedirectResolver){this._popupRedirectResolver=_getInstance(popupRedirectResolver)}this._initializationPromise=this.queue((async()=>{var _a,_b;if(this._deleted){return}this.persistenceManager=await PersistenceUserManager.create(this,persistenceHierarchy);if(this._deleted){return}if((_a=this._popupRedirectResolver)===null||_a===void 0?void 0:_a._shouldInitProactively){try{await this._popupRedirectResolver._initialize(this)}catch(e){}}await this.initializeCurrentUser(popupRedirectResolver);this.lastNotifiedUid=((_b=this.currentUser)===null||_b===void 0?void 0:_b.uid)||null;if(this._deleted){return}this._isInitialized=true}));return this._initializationPromise}async _onStorageEvent(){if(this._deleted){return}const user=await this.assertedPersistence.getCurrentUser();if(!this.currentUser&&!user){return}if(this.currentUser&&user&&this.currentUser.uid===user.uid){this._currentUser._assign(user);await this.currentUser.getIdToken();return}await this._updateCurrentUser(user,true)}async initializeCurrentUserFromIdToken(idToken){try{const response=await getAccountInfo(this,{idToken:idToken});const user=await UserImpl._fromGetAccountInfoResponse(this,response,idToken);await this.directlySetCurrentUser(user)}catch(err){console.warn("FirebaseServerApp could not login user with provided authIdToken: ",err);await this.directlySetCurrentUser(null)}}async initializeCurrentUser(popupRedirectResolver){var _a;if((0,_app._isFirebaseServerApp)(this.app)){const idToken=this.app.settings.authIdToken;if(idToken){return new Promise((resolve=>{setTimeout((()=>this.initializeCurrentUserFromIdToken(idToken).then(resolve,resolve)))}))}else{return this.directlySetCurrentUser(null)}}const previouslyStoredUser=await this.assertedPersistence.getCurrentUser();let futureCurrentUser=previouslyStoredUser;let needsTocheckMiddleware=false;if(popupRedirectResolver&&this.config.authDomain){await this.getOrInitRedirectPersistenceManager();const redirectUserEventId=(_a=this.redirectUser)===null||_a===void 0?void 0:_a._redirectEventId;const storedUserEventId=futureCurrentUser===null||futureCurrentUser===void 0?void 0:futureCurrentUser._redirectEventId;const result=await this.tryRedirectSignIn(popupRedirectResolver);if((!redirectUserEventId||redirectUserEventId===storedUserEventId)&&(result===null||result===void 0?void 0:result.user)){futureCurrentUser=result.user;needsTocheckMiddleware=true}}if(!futureCurrentUser){return this.directlySetCurrentUser(null)}if(!futureCurrentUser._redirectEventId){if(needsTocheckMiddleware){try{await this.beforeStateQueue.runMiddleware(futureCurrentUser)}catch(e){futureCurrentUser=previouslyStoredUser;this._popupRedirectResolver._overrideRedirectResult(this,(()=>Promise.reject(e)))}}if(futureCurrentUser){return this.reloadAndSetCurrentUserOrClear(futureCurrentUser)}else{return this.directlySetCurrentUser(null)}}_assert(this._popupRedirectResolver,this,"argument-error");await this.getOrInitRedirectPersistenceManager();if(this.redirectUser&&this.redirectUser._redirectEventId===futureCurrentUser._redirectEventId){return this.directlySetCurrentUser(futureCurrentUser)}return this.reloadAndSetCurrentUserOrClear(futureCurrentUser)}async tryRedirectSignIn(redirectResolver){let result=null;try{result=await this._popupRedirectResolver._completeRedirectFn(this,redirectResolver,true)}catch(e){await this._setRedirectUser(null)}return result}async reloadAndSetCurrentUserOrClear(user){try{await _reloadWithoutSaving(user)}catch(e){if((e===null||e===void 0?void 0:e.code)!==`auth/${"network-request-failed"}`){return this.directlySetCurrentUser(null)}}return this.directlySetCurrentUser(user)}useDeviceLanguage(){this.languageCode=_getUserLanguage()}async _delete(){this._deleted=true}async updateCurrentUser(userExtern){if((0,_app._isFirebaseServerApp)(this.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this))}const user=userExtern?(0,_util.getModularInstance)(userExtern):null;if(user){_assert(user.auth.config.apiKey===this.config.apiKey,this,"invalid-user-token")}return this._updateCurrentUser(user&&user._clone(this))}async _updateCurrentUser(user,skipBeforeStateCallbacks=false){if(this._deleted){return}if(user){_assert(this.tenantId===user.tenantId,this,"tenant-id-mismatch")}if(!skipBeforeStateCallbacks){await this.beforeStateQueue.runMiddleware(user)}return this.queue((async()=>{await this.directlySetCurrentUser(user);this.notifyAuthListeners()}))}async signOut(){if((0,_app._isFirebaseServerApp)(this.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this))}await this.beforeStateQueue.runMiddleware(null);if(this.redirectPersistenceManager||this._popupRedirectResolver){await this._setRedirectUser(null)}return this._updateCurrentUser(null,true)}setPersistence(persistence){if((0,_app._isFirebaseServerApp)(this.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this))}return this.queue((async()=>{await this.assertedPersistence.setPersistence(_getInstance(persistence))}))}_getRecaptchaConfig(){if(this.tenantId==null){return this._agentRecaptchaConfig}else{return this._tenantRecaptchaConfigs[this.tenantId]}}async validatePassword(password){if(!this._getPasswordPolicyInternal()){await this._updatePasswordPolicy()}const passwordPolicy=this._getPasswordPolicyInternal();if(passwordPolicy.schemaVersion!==this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION){return Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version",{}))}return passwordPolicy.validatePassword(password)}_getPasswordPolicyInternal(){if(this.tenantId===null){return this._projectPasswordPolicy}else{return this._tenantPasswordPolicies[this.tenantId]}}async _updatePasswordPolicy(){const response=await _getPasswordPolicy(this);const passwordPolicy=new PasswordPolicyImpl(response);if(this.tenantId===null){this._projectPasswordPolicy=passwordPolicy}else{this._tenantPasswordPolicies[this.tenantId]=passwordPolicy}}_getPersistence(){return this.assertedPersistence.persistence.type}_updateErrorMap(errorMap){this._errorFactory=new _util.ErrorFactory("auth","Firebase",errorMap())}onAuthStateChanged(nextOrObserver,error,completed){return this.registerStateListener(this.authStateSubscription,nextOrObserver,error,completed)}beforeAuthStateChanged(callback,onAbort){return this.beforeStateQueue.pushCallback(callback,onAbort)}onIdTokenChanged(nextOrObserver,error,completed){return this.registerStateListener(this.idTokenSubscription,nextOrObserver,error,completed)}authStateReady(){return new Promise(((resolve,reject)=>{if(this.currentUser){resolve()}else{const unsubscribe=this.onAuthStateChanged((()=>{unsubscribe();resolve()}),reject)}}))}async revokeAccessToken(token){if(this.currentUser){const idToken=await this.currentUser.getIdToken();const request={providerId:"apple.com",tokenType:"ACCESS_TOKEN",token:token,idToken:idToken};if(this.tenantId!=null){request.tenantId=this.tenantId}await revokeToken(this,request)}}toJSON(){var _a;return{apiKey:this.config.apiKey,authDomain:this.config.authDomain,appName:this.name,currentUser:(_a=this._currentUser)===null||_a===void 0?void 0:_a.toJSON()}}async _setRedirectUser(user,popupRedirectResolver){const redirectManager=await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);return user===null?redirectManager.removeCurrentUser():redirectManager.setCurrentUser(user)}async getOrInitRedirectPersistenceManager(popupRedirectResolver){if(!this.redirectPersistenceManager){const resolver=popupRedirectResolver&&_getInstance(popupRedirectResolver)||this._popupRedirectResolver;_assert(resolver,this,"argument-error");this.redirectPersistenceManager=await PersistenceUserManager.create(this,[_getInstance(resolver._redirectPersistence)],"redirectUser");this.redirectUser=await this.redirectPersistenceManager.getCurrentUser()}return this.redirectPersistenceManager}async _redirectUserForId(id){var _a,_b;if(this._isInitialized){await this.queue((async()=>{}))}if(((_a=this._currentUser)===null||_a===void 0?void 0:_a._redirectEventId)===id){return this._currentUser}if(((_b=this.redirectUser)===null||_b===void 0?void 0:_b._redirectEventId)===id){return this.redirectUser}return null}async _persistUserIfCurrent(user){if(user===this.currentUser){return this.queue((async()=>this.directlySetCurrentUser(user)))}}_notifyListenersIfCurrent(user){if(user===this.currentUser){this.notifyAuthListeners()}}_key(){return`${this.config.authDomain}:${this.config.apiKey}:${this.name}`}_startProactiveRefresh(){this.isProactiveRefreshEnabled=true;if(this.currentUser){this._currentUser._startProactiveRefresh()}}_stopProactiveRefresh(){this.isProactiveRefreshEnabled=false;if(this.currentUser){this._currentUser._stopProactiveRefresh()}}get _currentUser(){return this.currentUser}notifyAuthListeners(){var _a,_b;if(!this._isInitialized){return}this.idTokenSubscription.next(this.currentUser);const currentUid=(_b=(_a=this.currentUser)===null||_a===void 0?void 0:_a.uid)!==null&&_b!==void 0?_b:null;if(this.lastNotifiedUid!==currentUid){this.lastNotifiedUid=currentUid;this.authStateSubscription.next(this.currentUser)}}registerStateListener(subscription,nextOrObserver,error,completed){if(this._deleted){return()=>{}}const cb=typeof nextOrObserver==="function"?nextOrObserver:nextOrObserver.next.bind(nextOrObserver);let isUnsubscribed=false;const promise=this._isInitialized?Promise.resolve():this._initializationPromise;_assert(promise,this,"internal-error");promise.then((()=>{if(isUnsubscribed){return}cb(this.currentUser)}));if(typeof nextOrObserver==="function"){const unsubscribe=subscription.addObserver(nextOrObserver,error,completed);return()=>{isUnsubscribed=true;unsubscribe()}}else{const unsubscribe=subscription.addObserver(nextOrObserver);return()=>{isUnsubscribed=true;unsubscribe()}}}async directlySetCurrentUser(user){if(this.currentUser&&this.currentUser!==user){this._currentUser._stopProactiveRefresh()}if(user&&this.isProactiveRefreshEnabled){user._startProactiveRefresh()}this.currentUser=user;if(user){await this.assertedPersistence.setCurrentUser(user)}else{await this.assertedPersistence.removeCurrentUser()}}queue(action){this.operations=this.operations.then(action,action);return this.operations}get assertedPersistence(){_assert(this.persistenceManager,this,"internal-error");return this.persistenceManager}_logFramework(framework){if(!framework||this.frameworks.includes(framework)){return}this.frameworks.push(framework);this.frameworks.sort();this.clientVersion=_getClientVersion(this.config.clientPlatform,this._getFrameworks())}_getFrameworks(){return this.frameworks}async _getAdditionalHeaders(){var _a;const headers={["X-Client-Version"]:this.clientVersion};if(this.app.options.appId){headers["X-Firebase-gmpid"]=this.app.options.appId}const heartbeatsHeader=await((_a=this.heartbeatServiceProvider.getImmediate({optional:true}))===null||_a===void 0?void 0:_a.getHeartbeatsHeader());if(heartbeatsHeader){headers["X-Firebase-Client"]=heartbeatsHeader}const appCheckToken=await this._getAppCheckToken();if(appCheckToken){headers["X-Firebase-AppCheck"]=appCheckToken}return headers}async _getAppCheckToken(){var _a;const appCheckTokenResult=await((_a=this.appCheckServiceProvider.getImmediate({optional:true}))===null||_a===void 0?void 0:_a.getToken());if(appCheckTokenResult===null||appCheckTokenResult===void 0?void 0:appCheckTokenResult.error){_logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`)}return appCheckTokenResult===null||appCheckTokenResult===void 0?void 0:appCheckTokenResult.token}}exports.aL=AuthImpl;function _castAuth(auth){return(0,_util.getModularInstance)(auth)}class Subscription{constructor(auth){this.auth=auth;this.observer=null;this.addObserver=(0,_util.createSubscribe)((observer=>this.observer=observer))}get next(){_assert(this.observer,this.auth,"internal-error");return this.observer.next.bind(this.observer)}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let externalJSProvider={async loadJS(){throw new Error("Unable to load external scripts")},recaptchaV2Script:"",recaptchaEnterpriseScript:"",gapiScript:""};function _setExternalJSProvider(p){externalJSProvider=p}function _loadJS(url){return externalJSProvider.loadJS(url)}function _recaptchaV2ScriptUrl(){return externalJSProvider.recaptchaV2Script}function _recaptchaEnterpriseScriptUrl(){return externalJSProvider.recaptchaEnterpriseScript}function _gapiScriptUrl(){return externalJSProvider.gapiScript}function _generateCallbackName(prefix){return`__${prefix}${Math.floor(Math.random()*1e6)}`}const RECAPTCHA_ENTERPRISE_VERIFIER_TYPE="recaptcha-enterprise";const FAKE_TOKEN="NO_RECAPTCHA";class RecaptchaEnterpriseVerifier{constructor(authExtern){this.type=RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;this.auth=_castAuth(authExtern)}async verify(action="verify",forceRefresh=false){async function retrieveSiteKey(auth){if(!forceRefresh){if(auth.tenantId==null&&auth._agentRecaptchaConfig!=null){return auth._agentRecaptchaConfig.siteKey}if(auth.tenantId!=null&&auth._tenantRecaptchaConfigs[auth.tenantId]!==undefined){return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey}}return new Promise((async(resolve,reject)=>{getRecaptchaConfig(auth,{clientType:"CLIENT_TYPE_WEB",version:"RECAPTCHA_ENTERPRISE"}).then((response=>{if(response.recaptchaKey===undefined){reject(new Error("recaptcha Enterprise site key undefined"))}else{const config=new RecaptchaConfig(response);if(auth.tenantId==null){auth._agentRecaptchaConfig=config}else{auth._tenantRecaptchaConfigs[auth.tenantId]=config}return resolve(config.siteKey)}})).catch((error=>{reject(error)}))}))}function retrieveRecaptchaToken(siteKey,resolve,reject){const grecaptcha=window.grecaptcha;if(isEnterprise(grecaptcha)){grecaptcha.enterprise.ready((()=>{grecaptcha.enterprise.execute(siteKey,{action:action}).then((token=>{resolve(token)})).catch((()=>{resolve(FAKE_TOKEN)}))}))}else{reject(Error("No reCAPTCHA enterprise script loaded."))}}return new Promise(((resolve,reject)=>{retrieveSiteKey(this.auth).then((siteKey=>{if(!forceRefresh&&isEnterprise(window.grecaptcha)){retrieveRecaptchaToken(siteKey,resolve,reject)}else{if(typeof window==="undefined"){reject(new Error("RecaptchaVerifier is only supported in browser"));return}let url=_recaptchaEnterpriseScriptUrl();if(url.length!==0){url+=siteKey}_loadJS(url).then((()=>{retrieveRecaptchaToken(siteKey,resolve,reject)})).catch((error=>{reject(error)}))}})).catch((error=>{reject(error)}))}))}}async function injectRecaptchaFields(auth,request,action,captchaResp=false){const verifier=new RecaptchaEnterpriseVerifier(auth);let captchaResponse;try{captchaResponse=await verifier.verify(action)}catch(error){captchaResponse=await verifier.verify(action,true)}const newRequest=Object.assign({},request);if(!captchaResp){Object.assign(newRequest,{captchaResponse:captchaResponse})}else{Object.assign(newRequest,{captchaResp:captchaResponse})}Object.assign(newRequest,{clientType:"CLIENT_TYPE_WEB"});Object.assign(newRequest,{recaptchaVersion:"RECAPTCHA_ENTERPRISE"});return newRequest}async function handleRecaptchaFlow(authInstance,request,actionName,actionMethod){var _a;if((_a=authInstance._getRecaptchaConfig())===null||_a===void 0?void 0:_a.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")){const requestWithRecaptcha=await injectRecaptchaFields(authInstance,request,actionName,actionName==="getOobCode");return actionMethod(authInstance,requestWithRecaptcha)}else{return actionMethod(authInstance,request).catch((async error=>{if(error.code===`auth/${"missing-recaptcha-token"}`){console.log(`${actionName} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);const requestWithRecaptcha=await injectRecaptchaFields(authInstance,request,actionName,actionName==="getOobCode");return actionMethod(authInstance,requestWithRecaptcha)}else{return Promise.reject(error)}}))}}async function _initializeRecaptchaConfig(auth){const authInternal=_castAuth(auth);const response=await getRecaptchaConfig(authInternal,{clientType:"CLIENT_TYPE_WEB",version:"RECAPTCHA_ENTERPRISE"});const config=new RecaptchaConfig(response);if(authInternal.tenantId==null){authInternal._agentRecaptchaConfig=config}else{authInternal._tenantRecaptchaConfigs[authInternal.tenantId]=config}if(config.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")){const verifier=new RecaptchaEnterpriseVerifier(authInternal);void verifier.verify()}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function initializeAuth(app,deps){const provider=(0,_app._getProvider)(app,"auth");if(provider.isInitialized()){const auth=provider.getImmediate();const initialOptions=provider.getOptions();if((0,_util.deepEqual)(initialOptions,deps!==null&&deps!==void 0?deps:{})){return auth}else{_fail(auth,"already-initialized")}}const auth=provider.initialize({options:deps});return auth}function _initializeAuthInstance(auth,deps){const persistence=(deps===null||deps===void 0?void 0:deps.persistence)||[];const hierarchy=(Array.isArray(persistence)?persistence:[persistence]).map(_getInstance);if(deps===null||deps===void 0?void 0:deps.errorMap){auth._updateErrorMap(deps.errorMap)}auth._initializeWithPersistence(hierarchy,deps===null||deps===void 0?void 0:deps.popupRedirectResolver)}function connectAuthEmulator(auth,url,options){const authInternal=_castAuth(auth);_assert(authInternal._canInitEmulator,authInternal,"emulator-config-failed");_assert(/^https?:\/\//.test(url),authInternal,"invalid-emulator-scheme");const disableWarnings=!!(options===null||options===void 0?void 0:options.disableWarnings);const protocol=extractProtocol(url);const{host:host,port:port}=extractHostAndPort(url);const portStr=port===null?"":`:${port}`;authInternal.config.emulator={url:`${protocol}//${host}${portStr}/`};authInternal.settings.appVerificationDisabledForTesting=true;authInternal.emulatorConfig=Object.freeze({host:host,port:port,protocol:protocol.replace(":",""),options:Object.freeze({disableWarnings:disableWarnings})});if(!disableWarnings){emitEmulatorWarning()}}function extractProtocol(url){const protocolEnd=url.indexOf(":");return protocolEnd<0?"":url.substr(0,protocolEnd+1)}function extractHostAndPort(url){const protocol=extractProtocol(url);const authority=/(\/\/)?([^?#/]+)/.exec(url.substr(protocol.length));if(!authority){return{host:"",port:null}}const hostAndPort=authority[2].split("@").pop()||"";const bracketedIPv6=/^(\[[^\]]+\])(:|$)/.exec(hostAndPort);if(bracketedIPv6){const host=bracketedIPv6[1];return{host:host,port:parsePort(hostAndPort.substr(host.length+1))}}else{const[host,port]=hostAndPort.split(":");return{host:host,port:parsePort(port)}}}function parsePort(portStr){if(!portStr){return null}const port=Number(portStr);if(isNaN(port)){return null}return port}function emitEmulatorWarning(){function attachBanner(){const el=document.createElement("p");const sty=el.style;el.innerText="Running in emulator mode. Do not use with production credentials.";sty.position="fixed";sty.width="100%";sty.backgroundColor="#ffffff";sty.border=".1em solid #000000";sty.color="#b50000";sty.bottom="0px";sty.left="0px";sty.margin="0px";sty.zIndex="10000";sty.textAlign="center";el.classList.add("firebase-emulator-warning");document.body.appendChild(el)}if(typeof console!=="undefined"&&typeof console.info==="function"){console.info("WARNING: You are using the Auth Emulator,"+" which is intended for local testing only.  Do not use with"+" production credentials.")}if(typeof window!=="undefined"&&typeof document!=="undefined"){if(document.readyState==="loading"){window.addEventListener("DOMContentLoaded",attachBanner)}else{attachBanner()}}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class AuthCredential{constructor(providerId,signInMethod){this.providerId=providerId;this.signInMethod=signInMethod}toJSON(){return debugFail("not implemented")}_getIdTokenResponse(_auth){return debugFail("not implemented")}_linkToIdToken(_auth,_idToken){return debugFail("not implemented")}_getReauthenticationResolver(_auth){return debugFail("not implemented")}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.L=AuthCredential;async function resetPassword(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:resetPassword",_addTidIfNecessary(auth,request))}async function updateEmailPassword(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:update",request)}async function linkEmailPassword(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:signUp",request)}async function applyActionCode$1(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:update",_addTidIfNecessary(auth,request))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function signInWithPassword(auth,request){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithPassword",_addTidIfNecessary(auth,request))}async function sendOobCode(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:sendOobCode",_addTidIfNecessary(auth,request))}async function sendEmailVerification$1(auth,request){return sendOobCode(auth,request)}async function sendPasswordResetEmail$1(auth,request){return sendOobCode(auth,request)}async function sendSignInLinkToEmail$1(auth,request){return sendOobCode(auth,request)}async function verifyAndChangeEmail(auth,request){return sendOobCode(auth,request)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function signInWithEmailLink$1(auth,request){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithEmailLink",_addTidIfNecessary(auth,request))}async function signInWithEmailLinkForLinking(auth,request){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithEmailLink",_addTidIfNecessary(auth,request))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class EmailAuthCredential extends AuthCredential{constructor(_email,_password,signInMethod,_tenantId=null){super("password",signInMethod);this._email=_email;this._password=_password;this._tenantId=_tenantId}static _fromEmailAndPassword(email,password){return new EmailAuthCredential(email,password,"password")}static _fromEmailAndCode(email,oobCode,tenantId=null){return new EmailAuthCredential(email,oobCode,"emailLink",tenantId)}toJSON(){return{email:this._email,password:this._password,signInMethod:this.signInMethod,tenantId:this._tenantId}}static fromJSON(json){const obj=typeof json==="string"?JSON.parse(json):json;if((obj===null||obj===void 0?void 0:obj.email)&&(obj===null||obj===void 0?void 0:obj.password)){if(obj.signInMethod==="password"){return this._fromEmailAndPassword(obj.email,obj.password)}else if(obj.signInMethod==="emailLink"){return this._fromEmailAndCode(obj.email,obj.password,obj.tenantId)}}return null}async _getIdTokenResponse(auth){switch(this.signInMethod){case"password":const request={returnSecureToken:true,email:this._email,password:this._password,clientType:"CLIENT_TYPE_WEB"};return handleRecaptchaFlow(auth,request,"signInWithPassword",signInWithPassword);case"emailLink":return signInWithEmailLink$1(auth,{email:this._email,oobCode:this._password});default:_fail(auth,"internal-error")}}async _linkToIdToken(auth,idToken){switch(this.signInMethod){case"password":const request={idToken:idToken,returnSecureToken:true,email:this._email,password:this._password,clientType:"CLIENT_TYPE_WEB"};return handleRecaptchaFlow(auth,request,"signUpPassword",linkEmailPassword);case"emailLink":return signInWithEmailLinkForLinking(auth,{idToken:idToken,email:this._email,oobCode:this._password});default:_fail(auth,"internal-error")}}_getReauthenticationResolver(auth){return this._getIdTokenResponse(auth)}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.M=EmailAuthCredential;async function signInWithIdp(auth,request){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithIdp",_addTidIfNecessary(auth,request))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const IDP_REQUEST_URI$1="http://localhost";class OAuthCredential extends AuthCredential{constructor(){super(...arguments);this.pendingToken=null}static _fromParams(params){const cred=new OAuthCredential(params.providerId,params.signInMethod);if(params.idToken||params.accessToken){if(params.idToken){cred.idToken=params.idToken}if(params.accessToken){cred.accessToken=params.accessToken}if(params.nonce&&!params.pendingToken){cred.nonce=params.nonce}if(params.pendingToken){cred.pendingToken=params.pendingToken}}else if(params.oauthToken&&params.oauthTokenSecret){cred.accessToken=params.oauthToken;cred.secret=params.oauthTokenSecret}else{_fail("argument-error")}return cred}toJSON(){return{idToken:this.idToken,accessToken:this.accessToken,secret:this.secret,nonce:this.nonce,pendingToken:this.pendingToken,providerId:this.providerId,signInMethod:this.signInMethod}}static fromJSON(json){const obj=typeof json==="string"?JSON.parse(json):json;const{providerId:providerId,signInMethod:signInMethod}=obj,rest=(0,_tslib.__rest)(obj,["providerId","signInMethod"]);if(!providerId||!signInMethod){return null}const cred=new OAuthCredential(providerId,signInMethod);cred.idToken=rest.idToken||undefined;cred.accessToken=rest.accessToken||undefined;cred.secret=rest.secret;cred.nonce=rest.nonce;cred.pendingToken=rest.pendingToken||null;return cred}_getIdTokenResponse(auth){const request=this.buildRequest();return signInWithIdp(auth,request)}_linkToIdToken(auth,idToken){const request=this.buildRequest();request.idToken=idToken;return signInWithIdp(auth,request)}_getReauthenticationResolver(auth){const request=this.buildRequest();request.autoCreate=false;return signInWithIdp(auth,request)}buildRequest(){const request={requestUri:IDP_REQUEST_URI$1,returnSecureToken:true};if(this.pendingToken){request.pendingToken=this.pendingToken}else{const postBody={};if(this.idToken){postBody["id_token"]=this.idToken}if(this.accessToken){postBody["access_token"]=this.accessToken}if(this.secret){postBody["oauth_token_secret"]=this.secret}postBody["providerId"]=this.providerId;if(this.nonce&&!this.pendingToken){postBody["nonce"]=this.nonce}request.postBody=(0,_util.querystring)(postBody)}return request}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.N=OAuthCredential;async function sendPhoneVerificationCode(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:sendVerificationCode",_addTidIfNecessary(auth,request))}async function signInWithPhoneNumber$1(auth,request){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithPhoneNumber",_addTidIfNecessary(auth,request))}async function linkWithPhoneNumber$1(auth,request){const response=await _performSignInRequest(auth,"POST","/v1/accounts:signInWithPhoneNumber",_addTidIfNecessary(auth,request));if(response.temporaryProof){throw _makeTaggedError(auth,"account-exists-with-different-credential",response)}return response}const VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_={["USER_NOT_FOUND"]:"user-not-found"};async function verifyPhoneNumberForExisting(auth,request){const apiRequest=Object.assign(Object.assign({},request),{operation:"REAUTH"});return _performSignInRequest(auth,"POST","/v1/accounts:signInWithPhoneNumber",_addTidIfNecessary(auth,apiRequest),VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class PhoneAuthCredential extends AuthCredential{constructor(params){super("phone","phone");this.params=params}static _fromVerification(verificationId,verificationCode){return new PhoneAuthCredential({verificationId:verificationId,verificationCode:verificationCode})}static _fromTokenResponse(phoneNumber,temporaryProof){return new PhoneAuthCredential({phoneNumber:phoneNumber,temporaryProof:temporaryProof})}_getIdTokenResponse(auth){return signInWithPhoneNumber$1(auth,this._makeVerificationRequest())}_linkToIdToken(auth,idToken){return linkWithPhoneNumber$1(auth,Object.assign({idToken:idToken},this._makeVerificationRequest()))}_getReauthenticationResolver(auth){return verifyPhoneNumberForExisting(auth,this._makeVerificationRequest())}_makeVerificationRequest(){const{temporaryProof:temporaryProof,phoneNumber:phoneNumber,verificationId:verificationId,verificationCode:verificationCode}=this.params;if(temporaryProof&&phoneNumber){return{temporaryProof:temporaryProof,phoneNumber:phoneNumber}}return{sessionInfo:verificationId,code:verificationCode}}toJSON(){const obj={providerId:this.providerId};if(this.params.phoneNumber){obj.phoneNumber=this.params.phoneNumber}if(this.params.temporaryProof){obj.temporaryProof=this.params.temporaryProof}if(this.params.verificationCode){obj.verificationCode=this.params.verificationCode}if(this.params.verificationId){obj.verificationId=this.params.verificationId}return obj}static fromJSON(json){if(typeof json==="string"){json=JSON.parse(json)}const{verificationId:verificationId,verificationCode:verificationCode,phoneNumber:phoneNumber,temporaryProof:temporaryProof}=json;if(!verificationCode&&!verificationId&&!phoneNumber&&!temporaryProof){return null}return new PhoneAuthCredential({verificationId:verificationId,verificationCode:verificationCode,phoneNumber:phoneNumber,temporaryProof:temporaryProof})}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.Q=PhoneAuthCredential;function parseMode(mode){switch(mode){case"recoverEmail":return"RECOVER_EMAIL";case"resetPassword":return"PASSWORD_RESET";case"signIn":return"EMAIL_SIGNIN";case"verifyEmail":return"VERIFY_EMAIL";case"verifyAndChangeEmail":return"VERIFY_AND_CHANGE_EMAIL";case"revertSecondFactorAddition":return"REVERT_SECOND_FACTOR_ADDITION";default:return null}}function parseDeepLink(url){const link=(0,_util.querystringDecode)((0,_util.extractQuerystring)(url))["link"];const doubleDeepLink=link?(0,_util.querystringDecode)((0,_util.extractQuerystring)(link))["deep_link_id"]:null;const iOSDeepLink=(0,_util.querystringDecode)((0,_util.extractQuerystring)(url))["deep_link_id"];const iOSDoubleDeepLink=iOSDeepLink?(0,_util.querystringDecode)((0,_util.extractQuerystring)(iOSDeepLink))["link"]:null;return iOSDoubleDeepLink||iOSDeepLink||doubleDeepLink||link||url}class ActionCodeURL{constructor(actionLink){var _a,_b,_c,_d,_e,_f;const searchParams=(0,_util.querystringDecode)((0,_util.extractQuerystring)(actionLink));const apiKey=(_a=searchParams["apiKey"])!==null&&_a!==void 0?_a:null;const code=(_b=searchParams["oobCode"])!==null&&_b!==void 0?_b:null;const operation=parseMode((_c=searchParams["mode"])!==null&&_c!==void 0?_c:null);_assert(apiKey&&code&&operation,"argument-error");this.apiKey=apiKey;this.operation=operation;this.code=code;this.continueUrl=(_d=searchParams["continueUrl"])!==null&&_d!==void 0?_d:null;this.languageCode=(_e=searchParams["languageCode"])!==null&&_e!==void 0?_e:null;this.tenantId=(_f=searchParams["tenantId"])!==null&&_f!==void 0?_f:null}static parseLink(link){const actionLink=parseDeepLink(link);try{return new ActionCodeURL(actionLink)}catch(_a){return null}}}exports.ai=ActionCodeURL;function parseActionCodeURL(link){return ActionCodeURL.parseLink(link)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class EmailAuthProvider{constructor(){this.providerId=EmailAuthProvider.PROVIDER_ID}static credential(email,password){return EmailAuthCredential._fromEmailAndPassword(email,password)}static credentialWithLink(email,emailLink){const actionCodeUrl=ActionCodeURL.parseLink(emailLink);_assert(actionCodeUrl,"argument-error");return EmailAuthCredential._fromEmailAndCode(email,actionCodeUrl.code,actionCodeUrl.tenantId)}}exports.V=EmailAuthProvider;EmailAuthProvider.PROVIDER_ID="password";EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD="password";EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD="emailLink";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class FederatedAuthProvider{constructor(providerId){this.providerId=providerId;this.defaultLanguageCode=null;this.customParameters={}}setDefaultLanguage(languageCode){this.defaultLanguageCode=languageCode}setCustomParameters(customOAuthParameters){this.customParameters=customOAuthParameters;return this}getCustomParameters(){return this.customParameters}}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class BaseOAuthProvider extends FederatedAuthProvider{constructor(){super(...arguments);this.scopes=[]}addScope(scope){if(!this.scopes.includes(scope)){this.scopes.push(scope)}return this}getScopes(){return[...this.scopes]}}class OAuthProvider extends BaseOAuthProvider{static credentialFromJSON(json){const obj=typeof json==="string"?JSON.parse(json):json;_assert("providerId"in obj&&"signInMethod"in obj,"argument-error");return OAuthCredential._fromParams(obj)}credential(params){return this._credential(Object.assign(Object.assign({},params),{nonce:params.rawNonce}))}_credential(params){_assert(params.idToken||params.accessToken,"argument-error");return OAuthCredential._fromParams(Object.assign(Object.assign({},params),{providerId:this.providerId,signInMethod:this.providerId}))}static credentialFromResult(userCredential){return OAuthProvider.oauthCredentialFromTaggedObject(userCredential)}static credentialFromError(error){return OAuthProvider.oauthCredentialFromTaggedObject(error.customData||{})}static oauthCredentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse){return null}const{oauthIdToken:oauthIdToken,oauthAccessToken:oauthAccessToken,oauthTokenSecret:oauthTokenSecret,pendingToken:pendingToken,nonce:nonce,providerId:providerId}=tokenResponse;if(!oauthAccessToken&&!oauthTokenSecret&&!oauthIdToken&&!pendingToken){return null}if(!providerId){return null}try{return new OAuthProvider(providerId)._credential({idToken:oauthIdToken,accessToken:oauthAccessToken,nonce:nonce,pendingToken:pendingToken})}catch(e){return null}}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.Z=OAuthProvider;class FacebookAuthProvider extends BaseOAuthProvider{constructor(){super("facebook.com")}static credential(accessToken){return OAuthCredential._fromParams({providerId:FacebookAuthProvider.PROVIDER_ID,signInMethod:FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,accessToken:accessToken})}static credentialFromResult(userCredential){return FacebookAuthProvider.credentialFromTaggedObject(userCredential)}static credentialFromError(error){return FacebookAuthProvider.credentialFromTaggedObject(error.customData||{})}static credentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse||!("oauthAccessToken"in tokenResponse)){return null}if(!tokenResponse.oauthAccessToken){return null}try{return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken)}catch(_a){return null}}}exports.W=FacebookAuthProvider;FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD="facebook.com";FacebookAuthProvider.PROVIDER_ID="facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class GoogleAuthProvider extends BaseOAuthProvider{constructor(){super("google.com");this.addScope("profile")}static credential(idToken,accessToken){return OAuthCredential._fromParams({providerId:GoogleAuthProvider.PROVIDER_ID,signInMethod:GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,idToken:idToken,accessToken:accessToken})}static credentialFromResult(userCredential){return GoogleAuthProvider.credentialFromTaggedObject(userCredential)}static credentialFromError(error){return GoogleAuthProvider.credentialFromTaggedObject(error.customData||{})}static credentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse){return null}const{oauthIdToken:oauthIdToken,oauthAccessToken:oauthAccessToken}=tokenResponse;if(!oauthIdToken&&!oauthAccessToken){return null}try{return GoogleAuthProvider.credential(oauthIdToken,oauthAccessToken)}catch(_a){return null}}}exports.X=GoogleAuthProvider;GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD="google.com";GoogleAuthProvider.PROVIDER_ID="google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class GithubAuthProvider extends BaseOAuthProvider{constructor(){super("github.com")}static credential(accessToken){return OAuthCredential._fromParams({providerId:GithubAuthProvider.PROVIDER_ID,signInMethod:GithubAuthProvider.GITHUB_SIGN_IN_METHOD,accessToken:accessToken})}static credentialFromResult(userCredential){return GithubAuthProvider.credentialFromTaggedObject(userCredential)}static credentialFromError(error){return GithubAuthProvider.credentialFromTaggedObject(error.customData||{})}static credentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse||!("oauthAccessToken"in tokenResponse)){return null}if(!tokenResponse.oauthAccessToken){return null}try{return GithubAuthProvider.credential(tokenResponse.oauthAccessToken)}catch(_a){return null}}}exports.Y=GithubAuthProvider;GithubAuthProvider.GITHUB_SIGN_IN_METHOD="github.com";GithubAuthProvider.PROVIDER_ID="github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const IDP_REQUEST_URI="http://localhost";class SAMLAuthCredential extends AuthCredential{constructor(providerId,pendingToken){super(providerId,providerId);this.pendingToken=pendingToken}_getIdTokenResponse(auth){const request=this.buildRequest();return signInWithIdp(auth,request)}_linkToIdToken(auth,idToken){const request=this.buildRequest();request.idToken=idToken;return signInWithIdp(auth,request)}_getReauthenticationResolver(auth){const request=this.buildRequest();request.autoCreate=false;return signInWithIdp(auth,request)}toJSON(){return{signInMethod:this.signInMethod,providerId:this.providerId,pendingToken:this.pendingToken}}static fromJSON(json){const obj=typeof json==="string"?JSON.parse(json):json;const{providerId:providerId,signInMethod:signInMethod,pendingToken:pendingToken}=obj;if(!providerId||!signInMethod||!pendingToken||providerId!==signInMethod){return null}return new SAMLAuthCredential(providerId,pendingToken)}static _create(providerId,pendingToken){return new SAMLAuthCredential(providerId,pendingToken)}buildRequest(){return{requestUri:IDP_REQUEST_URI,returnSecureToken:true,pendingToken:this.pendingToken}}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.aQ=SAMLAuthCredential;const SAML_PROVIDER_PREFIX="saml.";class SAMLAuthProvider extends FederatedAuthProvider{constructor(providerId){_assert(providerId.startsWith(SAML_PROVIDER_PREFIX),"argument-error");super(providerId)}static credentialFromResult(userCredential){return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential)}static credentialFromError(error){return SAMLAuthProvider.samlCredentialFromTaggedObject(error.customData||{})}static credentialFromJSON(json){const credential=SAMLAuthCredential.fromJSON(json);_assert(credential,"argument-error");return credential}static samlCredentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse){return null}const{pendingToken:pendingToken,providerId:providerId}=tokenResponse;if(!pendingToken||!providerId){return null}try{return SAMLAuthCredential._create(providerId,pendingToken)}catch(e){return null}}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports._=SAMLAuthProvider;class TwitterAuthProvider extends BaseOAuthProvider{constructor(){super("twitter.com")}static credential(token,secret){return OAuthCredential._fromParams({providerId:TwitterAuthProvider.PROVIDER_ID,signInMethod:TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,oauthToken:token,oauthTokenSecret:secret})}static credentialFromResult(userCredential){return TwitterAuthProvider.credentialFromTaggedObject(userCredential)}static credentialFromError(error){return TwitterAuthProvider.credentialFromTaggedObject(error.customData||{})}static credentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse){return null}const{oauthAccessToken:oauthAccessToken,oauthTokenSecret:oauthTokenSecret}=tokenResponse;if(!oauthAccessToken||!oauthTokenSecret){return null}try{return TwitterAuthProvider.credential(oauthAccessToken,oauthTokenSecret)}catch(_a){return null}}}exports.$=TwitterAuthProvider;TwitterAuthProvider.TWITTER_SIGN_IN_METHOD="twitter.com";TwitterAuthProvider.PROVIDER_ID="twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function signUp(auth,request){return _performSignInRequest(auth,"POST","/v1/accounts:signUp",_addTidIfNecessary(auth,request))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class UserCredentialImpl{constructor(params){this.user=params.user;this.providerId=params.providerId;this._tokenResponse=params._tokenResponse;this.operationType=params.operationType}static async _fromIdTokenResponse(auth,operationType,idTokenResponse,isAnonymous=false){const user=await UserImpl._fromIdTokenResponse(auth,idTokenResponse,isAnonymous);const providerId=providerIdForResponse(idTokenResponse);const userCred=new UserCredentialImpl({user:user,providerId:providerId,_tokenResponse:idTokenResponse,operationType:operationType});return userCred}static async _forOperation(user,operationType,response){await user._updateTokensIfNecessary(response,true);const providerId=providerIdForResponse(response);return new UserCredentialImpl({user:user,providerId:providerId,_tokenResponse:response,operationType:operationType})}}function providerIdForResponse(response){if(response.providerId){return response.providerId}if("phoneNumber"in response){return"phone"}return null}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function signInAnonymously(auth){var _a;if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth))}const authInternal=_castAuth(auth);await authInternal._initializationPromise;if((_a=authInternal.currentUser)===null||_a===void 0?void 0:_a.isAnonymous){return new UserCredentialImpl({user:authInternal.currentUser,providerId:null,operationType:"signIn"})}const response=await signUp(authInternal,{returnSecureToken:true});const userCredential=await UserCredentialImpl._fromIdTokenResponse(authInternal,"signIn",response,true);await authInternal._updateCurrentUser(userCredential.user);return userCredential}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class MultiFactorError extends _util.FirebaseError{constructor(auth,error,operationType,user){var _a;super(error.code,error.message);this.operationType=operationType;this.user=user;Object.setPrototypeOf(this,MultiFactorError.prototype);this.customData={appName:auth.name,tenantId:(_a=auth.tenantId)!==null&&_a!==void 0?_a:undefined,_serverResponse:error.customData._serverResponse,operationType:operationType}}static _fromErrorAndOperation(auth,error,operationType,user){return new MultiFactorError(auth,error,operationType,user)}}function _processCredentialSavingMfaContextIfNecessary(auth,operationType,credential,user){const idTokenProvider=operationType==="reauthenticate"?credential._getReauthenticationResolver(auth):credential._getIdTokenResponse(auth);return idTokenProvider.catch((error=>{if(error.code===`auth/${"multi-factor-auth-required"}`){throw MultiFactorError._fromErrorAndOperation(auth,error,operationType,user)}throw error}))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function providerDataAsNames(providerData){return new Set(providerData.map((({providerId:providerId})=>providerId)).filter((pid=>!!pid)))}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function unlink(user,providerId){const userInternal=(0,_util.getModularInstance)(user);await _assertLinkedStatus(true,userInternal,providerId);const{providerUserInfo:providerUserInfo}=await deleteLinkedAccounts(userInternal.auth,{idToken:await userInternal.getIdToken(),deleteProvider:[providerId]});const providersLeft=providerDataAsNames(providerUserInfo||[]);userInternal.providerData=userInternal.providerData.filter((pd=>providersLeft.has(pd.providerId)));if(!providersLeft.has("phone")){userInternal.phoneNumber=null}await userInternal.auth._persistUserIfCurrent(userInternal);return userInternal}async function _link$1(user,credential,bypassAuthState=false){const response=await _logoutIfInvalidated(user,credential._linkToIdToken(user.auth,await user.getIdToken()),bypassAuthState);return UserCredentialImpl._forOperation(user,"link",response)}async function _assertLinkedStatus(expected,user,provider){await _reloadWithoutSaving(user);const providerIds=providerDataAsNames(user.providerData);const code=expected===false?"provider-already-linked":"no-such-provider";_assert(providerIds.has(provider)===expected,user.auth,code)}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function _reauthenticate(user,credential,bypassAuthState=false){const{auth:auth}=user;if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth))}const operationType="reauthenticate";try{const response=await _logoutIfInvalidated(user,_processCredentialSavingMfaContextIfNecessary(auth,operationType,credential,user),bypassAuthState);_assert(response.idToken,auth,"internal-error");const parsed=_parseToken(response.idToken);_assert(parsed,auth,"internal-error");const{sub:localId}=parsed;_assert(user.uid===localId,auth,"user-mismatch");return UserCredentialImpl._forOperation(user,operationType,response)}catch(e){if((e===null||e===void 0?void 0:e.code)===`auth/${"user-not-found"}`){_fail(auth,"user-mismatch")}throw e}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function _signInWithCredential(auth,credential,bypassAuthState=false){if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth))}const operationType="signIn";const response=await _processCredentialSavingMfaContextIfNecessary(auth,operationType,credential);const userCredential=await UserCredentialImpl._fromIdTokenResponse(auth,operationType,response);if(!bypassAuthState){await auth._updateCurrentUser(userCredential.user)}return userCredential}async function signInWithCredential(auth,credential){return _signInWithCredential(_castAuth(auth),credential)}async function linkWithCredential(user,credential){const userInternal=(0,_util.getModularInstance)(user);await _assertLinkedStatus(false,userInternal,credential.providerId);return _link$1(userInternal,credential)}async function reauthenticateWithCredential(user,credential){return _reauthenticate((0,_util.getModularInstance)(user),credential)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function signInWithCustomToken$1(auth,request){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithCustomToken",_addTidIfNecessary(auth,request))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function signInWithCustomToken(auth,customToken){if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth))}const authInternal=_castAuth(auth);const response=await signInWithCustomToken$1(authInternal,{token:customToken,returnSecureToken:true});const cred=await UserCredentialImpl._fromIdTokenResponse(authInternal,"signIn",response);await authInternal._updateCurrentUser(cred.user);return cred}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class MultiFactorInfoImpl{constructor(factorId,response){this.factorId=factorId;this.uid=response.mfaEnrollmentId;this.enrollmentTime=new Date(response.enrolledAt).toUTCString();this.displayName=response.displayName}static _fromServerResponse(auth,enrollment){if("phoneInfo"in enrollment){return PhoneMultiFactorInfoImpl._fromServerResponse(auth,enrollment)}else if("totpInfo"in enrollment){return TotpMultiFactorInfoImpl._fromServerResponse(auth,enrollment)}return _fail(auth,"internal-error")}}class PhoneMultiFactorInfoImpl extends MultiFactorInfoImpl{constructor(response){super("phone",response);this.phoneNumber=response.phoneInfo}static _fromServerResponse(_auth,enrollment){return new PhoneMultiFactorInfoImpl(enrollment)}}class TotpMultiFactorInfoImpl extends MultiFactorInfoImpl{constructor(response){super("totp",response)}static _fromServerResponse(_auth,enrollment){return new TotpMultiFactorInfoImpl(enrollment)}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _setActionCodeSettingsOnRequest(auth,request,actionCodeSettings){var _a;_assert(((_a=actionCodeSettings.url)===null||_a===void 0?void 0:_a.length)>0,auth,"invalid-continue-uri");_assert(typeof actionCodeSettings.dynamicLinkDomain==="undefined"||actionCodeSettings.dynamicLinkDomain.length>0,auth,"invalid-dynamic-link-domain");request.continueUrl=actionCodeSettings.url;request.dynamicLinkDomain=actionCodeSettings.dynamicLinkDomain;request.canHandleCodeInApp=actionCodeSettings.handleCodeInApp;if(actionCodeSettings.iOS){_assert(actionCodeSettings.iOS.bundleId.length>0,auth,"missing-ios-bundle-id");request.iOSBundleId=actionCodeSettings.iOS.bundleId}if(actionCodeSettings.android){_assert(actionCodeSettings.android.packageName.length>0,auth,"missing-android-pkg-name");request.androidInstallApp=actionCodeSettings.android.installApp;request.androidMinimumVersionCode=actionCodeSettings.android.minimumVersion;request.androidPackageName=actionCodeSettings.android.packageName}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function recachePasswordPolicy(auth){const authInternal=_castAuth(auth);if(authInternal._getPasswordPolicyInternal()){await authInternal._updatePasswordPolicy()}}async function sendPasswordResetEmail(auth,email,actionCodeSettings){const authInternal=_castAuth(auth);const request={requestType:"PASSWORD_RESET",email:email,clientType:"CLIENT_TYPE_WEB"};if(actionCodeSettings){_setActionCodeSettingsOnRequest(authInternal,request,actionCodeSettings)}await handleRecaptchaFlow(authInternal,request,"getOobCode",sendPasswordResetEmail$1)}async function confirmPasswordReset(auth,oobCode,newPassword){await resetPassword((0,_util.getModularInstance)(auth),{oobCode:oobCode,newPassword:newPassword}).catch((async error=>{if(error.code===`auth/${"password-does-not-meet-requirements"}`){void recachePasswordPolicy(auth)}throw error}))}async function applyActionCode(auth,oobCode){await applyActionCode$1((0,_util.getModularInstance)(auth),{oobCode:oobCode})}async function checkActionCode(auth,oobCode){const authModular=(0,_util.getModularInstance)(auth);const response=await resetPassword(authModular,{oobCode:oobCode});const operation=response.requestType;_assert(operation,authModular,"internal-error");switch(operation){case"EMAIL_SIGNIN":break;case"VERIFY_AND_CHANGE_EMAIL":_assert(response.newEmail,authModular,"internal-error");break;case"REVERT_SECOND_FACTOR_ADDITION":_assert(response.mfaInfo,authModular,"internal-error");default:_assert(response.email,authModular,"internal-error")}let multiFactorInfo=null;if(response.mfaInfo){multiFactorInfo=MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular),response.mfaInfo)}return{data:{email:(response.requestType==="VERIFY_AND_CHANGE_EMAIL"?response.newEmail:response.email)||null,previousEmail:(response.requestType==="VERIFY_AND_CHANGE_EMAIL"?response.email:response.newEmail)||null,multiFactorInfo:multiFactorInfo},operation:operation}}async function verifyPasswordResetCode(auth,code){const{data:data}=await checkActionCode((0,_util.getModularInstance)(auth),code);return data.email}async function createUserWithEmailAndPassword(auth,email,password){if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth))}const authInternal=_castAuth(auth);const request={returnSecureToken:true,email:email,password:password,clientType:"CLIENT_TYPE_WEB"};const signUpResponse=handleRecaptchaFlow(authInternal,request,"signUpPassword",signUp);const response=await signUpResponse.catch((error=>{if(error.code===`auth/${"password-does-not-meet-requirements"}`){void recachePasswordPolicy(auth)}throw error}));const userCredential=await UserCredentialImpl._fromIdTokenResponse(authInternal,"signIn",response);await authInternal._updateCurrentUser(userCredential.user);return userCredential}function signInWithEmailAndPassword(auth,email,password){if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth))}return signInWithCredential((0,_util.getModularInstance)(auth),EmailAuthProvider.credential(email,password)).catch((async error=>{if(error.code===`auth/${"password-does-not-meet-requirements"}`){void recachePasswordPolicy(auth)}throw error}))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function sendSignInLinkToEmail(auth,email,actionCodeSettings){const authInternal=_castAuth(auth);const request={requestType:"EMAIL_SIGNIN",email:email,clientType:"CLIENT_TYPE_WEB"};function setActionCodeSettings(request,actionCodeSettings){_assert(actionCodeSettings.handleCodeInApp,authInternal,"argument-error");if(actionCodeSettings){_setActionCodeSettingsOnRequest(authInternal,request,actionCodeSettings)}}setActionCodeSettings(request,actionCodeSettings);await handleRecaptchaFlow(authInternal,request,"getOobCode",sendSignInLinkToEmail$1)}function isSignInWithEmailLink(auth,emailLink){const actionCodeUrl=ActionCodeURL.parseLink(emailLink);return(actionCodeUrl===null||actionCodeUrl===void 0?void 0:actionCodeUrl.operation)==="EMAIL_SIGNIN"}async function signInWithEmailLink(auth,email,emailLink){if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth))}const authModular=(0,_util.getModularInstance)(auth);const credential=EmailAuthProvider.credentialWithLink(email,emailLink||_getCurrentUrl());_assert(credential._tenantId===(authModular.tenantId||null),authModular,"tenant-id-mismatch");return signInWithCredential(authModular,credential)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function createAuthUri(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:createAuthUri",_addTidIfNecessary(auth,request))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function fetchSignInMethodsForEmail(auth,email){const continueUri=_isHttpOrHttps()?_getCurrentUrl():"http://localhost";const request={identifier:email,continueUri:continueUri};const{signinMethods:signinMethods}=await createAuthUri((0,_util.getModularInstance)(auth),request);return signinMethods||[]}async function sendEmailVerification(user,actionCodeSettings){const userInternal=(0,_util.getModularInstance)(user);const idToken=await user.getIdToken();const request={requestType:"VERIFY_EMAIL",idToken:idToken};if(actionCodeSettings){_setActionCodeSettingsOnRequest(userInternal.auth,request,actionCodeSettings)}const{email:email}=await sendEmailVerification$1(userInternal.auth,request);if(email!==user.email){await user.reload()}}async function verifyBeforeUpdateEmail(user,newEmail,actionCodeSettings){const userInternal=(0,_util.getModularInstance)(user);const idToken=await user.getIdToken();const request={requestType:"VERIFY_AND_CHANGE_EMAIL",idToken:idToken,newEmail:newEmail};if(actionCodeSettings){_setActionCodeSettingsOnRequest(userInternal.auth,request,actionCodeSettings)}const{email:email}=await verifyAndChangeEmail(userInternal.auth,request);if(email!==user.email){await user.reload()}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function updateProfile$1(auth,request){return _performApiRequest(auth,"POST","/v1/accounts:update",request)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function updateProfile(user,{displayName:displayName,photoURL:photoUrl}){if(displayName===undefined&&photoUrl===undefined){return}const userInternal=(0,_util.getModularInstance)(user);const idToken=await userInternal.getIdToken();const profileRequest={idToken:idToken,displayName:displayName,photoUrl:photoUrl,returnSecureToken:true};const response=await _logoutIfInvalidated(userInternal,updateProfile$1(userInternal.auth,profileRequest));userInternal.displayName=response.displayName||null;userInternal.photoURL=response.photoUrl||null;const passwordProvider=userInternal.providerData.find((({providerId:providerId})=>providerId==="password"));if(passwordProvider){passwordProvider.displayName=userInternal.displayName;passwordProvider.photoURL=userInternal.photoURL}await userInternal._updateTokensIfNecessary(response)}function updateEmail(user,newEmail){const userInternal=(0,_util.getModularInstance)(user);if((0,_app._isFirebaseServerApp)(userInternal.auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth))}return updateEmailOrPassword(userInternal,newEmail,null)}function updatePassword(user,newPassword){return updateEmailOrPassword((0,_util.getModularInstance)(user),null,newPassword)}async function updateEmailOrPassword(user,email,password){const{auth:auth}=user;const idToken=await user.getIdToken();const request={idToken:idToken,returnSecureToken:true};if(email){request.email=email}if(password){request.password=password}const response=await _logoutIfInvalidated(user,updateEmailPassword(auth,request));await user._updateTokensIfNecessary(response,true)}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _fromIdTokenResponse(idTokenResponse){var _a,_b;if(!idTokenResponse){return null}const{providerId:providerId}=idTokenResponse;const profile=idTokenResponse.rawUserInfo?JSON.parse(idTokenResponse.rawUserInfo):{};const isNewUser=idTokenResponse.isNewUser||idTokenResponse.kind==="identitytoolkit#SignupNewUserResponse";if(!providerId&&(idTokenResponse===null||idTokenResponse===void 0?void 0:idTokenResponse.idToken)){const signInProvider=(_b=(_a=_parseToken(idTokenResponse.idToken))===null||_a===void 0?void 0:_a.firebase)===null||_b===void 0?void 0:_b["sign_in_provider"];if(signInProvider){const filteredProviderId=signInProvider!=="anonymous"&&signInProvider!=="custom"?signInProvider:null;return new GenericAdditionalUserInfo(isNewUser,filteredProviderId)}}if(!providerId){return null}switch(providerId){case"facebook.com":return new FacebookAdditionalUserInfo(isNewUser,profile);case"github.com":return new GithubAdditionalUserInfo(isNewUser,profile);case"google.com":return new GoogleAdditionalUserInfo(isNewUser,profile);case"twitter.com":return new TwitterAdditionalUserInfo(isNewUser,profile,idTokenResponse.screenName||null);case"custom":case"anonymous":return new GenericAdditionalUserInfo(isNewUser,null);default:return new GenericAdditionalUserInfo(isNewUser,providerId,profile)}}class GenericAdditionalUserInfo{constructor(isNewUser,providerId,profile={}){this.isNewUser=isNewUser;this.providerId=providerId;this.profile=profile}}class FederatedAdditionalUserInfoWithUsername extends GenericAdditionalUserInfo{constructor(isNewUser,providerId,profile,username){super(isNewUser,providerId,profile);this.username=username}}class FacebookAdditionalUserInfo extends GenericAdditionalUserInfo{constructor(isNewUser,profile){super(isNewUser,"facebook.com",profile)}}class GithubAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername{constructor(isNewUser,profile){super(isNewUser,"github.com",profile,typeof(profile===null||profile===void 0?void 0:profile.login)==="string"?profile===null||profile===void 0?void 0:profile.login:null)}}class GoogleAdditionalUserInfo extends GenericAdditionalUserInfo{constructor(isNewUser,profile){super(isNewUser,"google.com",profile)}}class TwitterAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername{constructor(isNewUser,profile,screenName){super(isNewUser,"twitter.com",profile,screenName)}}function getAdditionalUserInfo(userCredential){const{user:user,_tokenResponse:_tokenResponse}=userCredential;if(user.isAnonymous&&!_tokenResponse){return{providerId:null,isNewUser:false,profile:null}}return _fromIdTokenResponse(_tokenResponse)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function setPersistence(auth,persistence){return(0,_util.getModularInstance)(auth).setPersistence(persistence)}function initializeRecaptchaConfig(auth){return _initializeRecaptchaConfig(auth)}async function validatePassword(auth,password){const authInternal=_castAuth(auth);return authInternal.validatePassword(password)}function onIdTokenChanged(auth,nextOrObserver,error,completed){return(0,_util.getModularInstance)(auth).onIdTokenChanged(nextOrObserver,error,completed)}function beforeAuthStateChanged(auth,callback,onAbort){return(0,_util.getModularInstance)(auth).beforeAuthStateChanged(callback,onAbort)}function onAuthStateChanged(auth,nextOrObserver,error,completed){return(0,_util.getModularInstance)(auth).onAuthStateChanged(nextOrObserver,error,completed)}function useDeviceLanguage(auth){(0,_util.getModularInstance)(auth).useDeviceLanguage()}function updateCurrentUser(auth,user){return(0,_util.getModularInstance)(auth).updateCurrentUser(user)}function signOut(auth){return(0,_util.getModularInstance)(auth).signOut()}function revokeAccessToken(auth,token){const authInternal=_castAuth(auth);return authInternal.revokeAccessToken(token)}async function deleteUser(user){return(0,_util.getModularInstance)(user).delete()}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class MultiFactorSessionImpl{constructor(type,credential,user){this.type=type;this.credential=credential;this.user=user}static _fromIdtoken(idToken,user){return new MultiFactorSessionImpl("enroll",idToken,user)}static _fromMfaPendingCredential(mfaPendingCredential){return new MultiFactorSessionImpl("signin",mfaPendingCredential)}toJSON(){const key=this.type==="enroll"?"idToken":"pendingCredential";return{multiFactorSession:{[key]:this.credential}}}static fromJSON(obj){var _a,_b;if(obj===null||obj===void 0?void 0:obj.multiFactorSession){if((_a=obj.multiFactorSession)===null||_a===void 0?void 0:_a.pendingCredential){return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential)}else if((_b=obj.multiFactorSession)===null||_b===void 0?void 0:_b.idToken){return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken)}}return null}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class MultiFactorResolverImpl{constructor(session,hints,signInResolver){this.session=session;this.hints=hints;this.signInResolver=signInResolver}static _fromError(authExtern,error){const auth=_castAuth(authExtern);const serverResponse=error.customData._serverResponse;const hints=(serverResponse.mfaInfo||[]).map((enrollment=>MultiFactorInfoImpl._fromServerResponse(auth,enrollment)));_assert(serverResponse.mfaPendingCredential,auth,"internal-error");const session=MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);return new MultiFactorResolverImpl(session,hints,(async assertion=>{const mfaResponse=await assertion._process(auth,session);delete serverResponse.mfaInfo;delete serverResponse.mfaPendingCredential;const idTokenResponse=Object.assign(Object.assign({},serverResponse),{idToken:mfaResponse.idToken,refreshToken:mfaResponse.refreshToken});switch(error.operationType){case"signIn":const userCredential=await UserCredentialImpl._fromIdTokenResponse(auth,error.operationType,idTokenResponse);await auth._updateCurrentUser(userCredential.user);return userCredential;case"reauthenticate":_assert(error.user,auth,"internal-error");return UserCredentialImpl._forOperation(error.user,error.operationType,idTokenResponse);default:_fail(auth,"internal-error")}}))}async resolveSignIn(assertionExtern){const assertion=assertionExtern;return this.signInResolver(assertion)}}function getMultiFactorResolver(auth,error){var _a;const authModular=(0,_util.getModularInstance)(auth);const errorInternal=error;_assert(error.customData.operationType,authModular,"argument-error");_assert((_a=errorInternal.customData._serverResponse)===null||_a===void 0?void 0:_a.mfaPendingCredential,authModular,"argument-error");return MultiFactorResolverImpl._fromError(authModular,errorInternal)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function startEnrollPhoneMfa(auth,request){return _performApiRequest(auth,"POST","/v2/accounts/mfaEnrollment:start",_addTidIfNecessary(auth,request))}function finalizeEnrollPhoneMfa(auth,request){return _performApiRequest(auth,"POST","/v2/accounts/mfaEnrollment:finalize",_addTidIfNecessary(auth,request))}function startEnrollTotpMfa(auth,request){return _performApiRequest(auth,"POST","/v2/accounts/mfaEnrollment:start",_addTidIfNecessary(auth,request))}function finalizeEnrollTotpMfa(auth,request){return _performApiRequest(auth,"POST","/v2/accounts/mfaEnrollment:finalize",_addTidIfNecessary(auth,request))}function withdrawMfa(auth,request){return _performApiRequest(auth,"POST","/v2/accounts/mfaEnrollment:withdraw",_addTidIfNecessary(auth,request))}class MultiFactorUserImpl{constructor(user){this.user=user;this.enrolledFactors=[];user._onReload((userInfo=>{if(userInfo.mfaInfo){this.enrolledFactors=userInfo.mfaInfo.map((enrollment=>MultiFactorInfoImpl._fromServerResponse(user.auth,enrollment)))}}))}static _fromUser(user){return new MultiFactorUserImpl(user)}async getSession(){return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(),this.user)}async enroll(assertionExtern,displayName){const assertion=assertionExtern;const session=await this.getSession();const finalizeMfaResponse=await _logoutIfInvalidated(this.user,assertion._process(this.user.auth,session,displayName));await this.user._updateTokensIfNecessary(finalizeMfaResponse);return this.user.reload()}async unenroll(infoOrUid){const mfaEnrollmentId=typeof infoOrUid==="string"?infoOrUid:infoOrUid.uid;const idToken=await this.user.getIdToken();try{const idTokenResponse=await _logoutIfInvalidated(this.user,withdrawMfa(this.user.auth,{idToken:idToken,mfaEnrollmentId:mfaEnrollmentId}));this.enrolledFactors=this.enrolledFactors.filter((({uid:uid})=>uid!==mfaEnrollmentId));await this.user._updateTokensIfNecessary(idTokenResponse);await this.user.reload()}catch(e){throw e}}}const multiFactorUserCache=new WeakMap;function multiFactor(user){const userModular=(0,_util.getModularInstance)(user);if(!multiFactorUserCache.has(userModular)){multiFactorUserCache.set(userModular,MultiFactorUserImpl._fromUser(userModular))}return multiFactorUserCache.get(userModular)}const STORAGE_AVAILABLE_KEY="__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class BrowserPersistenceClass{constructor(storageRetriever,type){this.storageRetriever=storageRetriever;this.type=type}_isAvailable(){try{if(!this.storage){return Promise.resolve(false)}this.storage.setItem(STORAGE_AVAILABLE_KEY,"1");this.storage.removeItem(STORAGE_AVAILABLE_KEY);return Promise.resolve(true)}catch(_a){return Promise.resolve(false)}}_set(key,value){this.storage.setItem(key,JSON.stringify(value));return Promise.resolve()}_get(key){const json=this.storage.getItem(key);return Promise.resolve(json?JSON.parse(json):null)}_remove(key){this.storage.removeItem(key);return Promise.resolve()}get storage(){return this.storageRetriever()}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _iframeCannotSyncWebStorage(){const ua=(0,_util.getUA)();return _isSafari(ua)||_isIOS(ua)}const _POLLING_INTERVAL_MS$1=1e3;const IE10_LOCAL_STORAGE_SYNC_DELAY=10;class BrowserLocalPersistence extends BrowserPersistenceClass{constructor(){super((()=>window.localStorage),"LOCAL");this.boundEventHandler=(event,poll)=>this.onStorageEvent(event,poll);this.listeners={};this.localCache={};this.pollTimer=null;this.safariLocalStorageNotSynced=_iframeCannotSyncWebStorage()&&_isIframe();this.fallbackToPolling=_isMobileBrowser();this._shouldAllowMigration=true}forAllChangedKeys(cb){for(const key of Object.keys(this.listeners)){const newValue=this.storage.getItem(key);const oldValue=this.localCache[key];if(newValue!==oldValue){cb(key,oldValue,newValue)}}}onStorageEvent(event,poll=false){if(!event.key){this.forAllChangedKeys(((key,_oldValue,newValue)=>{this.notifyListeners(key,newValue)}));return}const key=event.key;if(poll){this.detachListener()}else{this.stopPolling()}if(this.safariLocalStorageNotSynced){const storedValue=this.storage.getItem(key);if(event.newValue!==storedValue){if(event.newValue!==null){this.storage.setItem(key,event.newValue)}else{this.storage.removeItem(key)}}else if(this.localCache[key]===event.newValue&&!poll){return}}const triggerListeners=()=>{const storedValue=this.storage.getItem(key);if(!poll&&this.localCache[key]===storedValue){return}this.notifyListeners(key,storedValue)};const storedValue=this.storage.getItem(key);if(_isIE10()&&storedValue!==event.newValue&&event.newValue!==event.oldValue){setTimeout(triggerListeners,IE10_LOCAL_STORAGE_SYNC_DELAY)}else{triggerListeners()}}notifyListeners(key,value){this.localCache[key]=value;const listeners=this.listeners[key];if(listeners){for(const listener of Array.from(listeners)){listener(value?JSON.parse(value):value)}}}startPolling(){this.stopPolling();this.pollTimer=setInterval((()=>{this.forAllChangedKeys(((key,oldValue,newValue)=>{this.onStorageEvent(new StorageEvent("storage",{key:key,oldValue:oldValue,newValue:newValue}),true)}))}),_POLLING_INTERVAL_MS$1)}stopPolling(){if(this.pollTimer){clearInterval(this.pollTimer);this.pollTimer=null}}attachListener(){window.addEventListener("storage",this.boundEventHandler)}detachListener(){window.removeEventListener("storage",this.boundEventHandler)}_addListener(key,listener){if(Object.keys(this.listeners).length===0){if(this.fallbackToPolling){this.startPolling()}else{this.attachListener()}}if(!this.listeners[key]){this.listeners[key]=new Set;this.localCache[key]=this.storage.getItem(key)}this.listeners[key].add(listener)}_removeListener(key,listener){if(this.listeners[key]){this.listeners[key].delete(listener);if(this.listeners[key].size===0){delete this.listeners[key]}}if(Object.keys(this.listeners).length===0){this.detachListener();this.stopPolling()}}async _set(key,value){await super._set(key,value);this.localCache[key]=JSON.stringify(value)}async _get(key){const value=await super._get(key);this.localCache[key]=JSON.stringify(value);return value}async _remove(key){await super._remove(key);delete this.localCache[key]}}BrowserLocalPersistence.type="LOCAL";const browserLocalPersistence=BrowserLocalPersistence;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.b=browserLocalPersistence;class BrowserSessionPersistence extends BrowserPersistenceClass{constructor(){super((()=>window.sessionStorage),"SESSION")}_addListener(_key,_listener){return}_removeListener(_key,_listener){return}}BrowserSessionPersistence.type="SESSION";const browserSessionPersistence=BrowserSessionPersistence;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.a=browserSessionPersistence;function _allSettled(promises){return Promise.all(promises.map((async promise=>{try{const value=await promise;return{fulfilled:true,value:value}}catch(reason){return{fulfilled:false,reason:reason}}})))}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Receiver{constructor(eventTarget){this.eventTarget=eventTarget;this.handlersMap={};this.boundEventHandler=this.handleEvent.bind(this)}static _getInstance(eventTarget){const existingInstance=this.receivers.find((receiver=>receiver.isListeningto(eventTarget)));if(existingInstance){return existingInstance}const newInstance=new Receiver(eventTarget);this.receivers.push(newInstance);return newInstance}isListeningto(eventTarget){return this.eventTarget===eventTarget}async handleEvent(event){const messageEvent=event;const{eventId:eventId,eventType:eventType,data:data}=messageEvent.data;const handlers=this.handlersMap[eventType];if(!(handlers===null||handlers===void 0?void 0:handlers.size)){return}messageEvent.ports[0].postMessage({status:"ack",eventId:eventId,eventType:eventType});const promises=Array.from(handlers).map((async handler=>handler(messageEvent.origin,data)));const response=await _allSettled(promises);messageEvent.ports[0].postMessage({status:"done",eventId:eventId,eventType:eventType,response:response})}_subscribe(eventType,eventHandler){if(Object.keys(this.handlersMap).length===0){this.eventTarget.addEventListener("message",this.boundEventHandler)}if(!this.handlersMap[eventType]){this.handlersMap[eventType]=new Set}this.handlersMap[eventType].add(eventHandler)}_unsubscribe(eventType,eventHandler){if(this.handlersMap[eventType]&&eventHandler){this.handlersMap[eventType].delete(eventHandler)}if(!eventHandler||this.handlersMap[eventType].size===0){delete this.handlersMap[eventType]}if(Object.keys(this.handlersMap).length===0){this.eventTarget.removeEventListener("message",this.boundEventHandler)}}}Receiver.receivers=[];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _generateEventId(prefix="",digits=10){let random="";for(let i=0;i<digits;i++){random+=Math.floor(Math.random()*10)}return prefix+random}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Sender{constructor(target){this.target=target;this.handlers=new Set}removeMessageHandler(handler){if(handler.messageChannel){handler.messageChannel.port1.removeEventListener("message",handler.onMessage);handler.messageChannel.port1.close()}this.handlers.delete(handler)}async _send(eventType,data,timeout=50){const messageChannel=typeof MessageChannel!=="undefined"?new MessageChannel:null;if(!messageChannel){throw new Error("connection_unavailable")}let completionTimer;let handler;return new Promise(((resolve,reject)=>{const eventId=_generateEventId("",20);messageChannel.port1.start();const ackTimer=setTimeout((()=>{reject(new Error("unsupported_event"))}),timeout);handler={messageChannel:messageChannel,onMessage(event){const messageEvent=event;if(messageEvent.data.eventId!==eventId){return}switch(messageEvent.data.status){case"ack":clearTimeout(ackTimer);completionTimer=setTimeout((()=>{reject(new Error("timeout"))}),3e3);break;case"done":clearTimeout(completionTimer);resolve(messageEvent.data.response);break;default:clearTimeout(ackTimer);clearTimeout(completionTimer);reject(new Error("invalid_response"));break}}};this.handlers.add(handler);messageChannel.port1.addEventListener("message",handler.onMessage);this.target.postMessage({eventType:eventType,eventId:eventId,data:data},[messageChannel.port2])})).finally((()=>{if(handler){this.removeMessageHandler(handler)}}))}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _window(){return window}function _setWindowLocation(url){_window().location.href=url}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _isWorker(){return typeof _window()["WorkerGlobalScope"]!=="undefined"&&typeof _window()["importScripts"]==="function"}async function _getActiveServiceWorker(){if(!(navigator===null||navigator===void 0?void 0:navigator.serviceWorker)){return null}try{const registration=await navigator.serviceWorker.ready;return registration.active}catch(_a){return null}}function _getServiceWorkerController(){var _a;return((_a=navigator===null||navigator===void 0?void 0:navigator.serviceWorker)===null||_a===void 0?void 0:_a.controller)||null}function _getWorkerGlobalScope(){return _isWorker()?self:null}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const DB_NAME="firebaseLocalStorageDb";const DB_VERSION=1;const DB_OBJECTSTORE_NAME="firebaseLocalStorage";const DB_DATA_KEYPATH="fbase_key";class DBPromise{constructor(request){this.request=request}toPromise(){return new Promise(((resolve,reject)=>{this.request.addEventListener("success",(()=>{resolve(this.request.result)}));this.request.addEventListener("error",(()=>{reject(this.request.error)}))}))}}function getObjectStore(db,isReadWrite){return db.transaction([DB_OBJECTSTORE_NAME],isReadWrite?"readwrite":"readonly").objectStore(DB_OBJECTSTORE_NAME)}function _deleteDatabase(){const request=indexedDB.deleteDatabase(DB_NAME);return new DBPromise(request).toPromise()}function _openDatabase(){const request=indexedDB.open(DB_NAME,DB_VERSION);return new Promise(((resolve,reject)=>{request.addEventListener("error",(()=>{reject(request.error)}));request.addEventListener("upgradeneeded",(()=>{const db=request.result;try{db.createObjectStore(DB_OBJECTSTORE_NAME,{keyPath:DB_DATA_KEYPATH})}catch(e){reject(e)}}));request.addEventListener("success",(async()=>{const db=request.result;if(!db.objectStoreNames.contains(DB_OBJECTSTORE_NAME)){db.close();await _deleteDatabase();resolve(await _openDatabase())}else{resolve(db)}}))}))}async function _putObject(db,key,value){const request=getObjectStore(db,true).put({[DB_DATA_KEYPATH]:key,value:value});return new DBPromise(request).toPromise()}async function getObject(db,key){const request=getObjectStore(db,false).get(key);const data=await new DBPromise(request).toPromise();return data===undefined?null:data.value}function _deleteObject(db,key){const request=getObjectStore(db,true).delete(key);return new DBPromise(request).toPromise()}const _POLLING_INTERVAL_MS=800;const _TRANSACTION_RETRY_COUNT=3;class IndexedDBLocalPersistence{constructor(){this.type="LOCAL";this._shouldAllowMigration=true;this.listeners={};this.localCache={};this.pollTimer=null;this.pendingWrites=0;this.receiver=null;this.sender=null;this.serviceWorkerReceiverAvailable=false;this.activeServiceWorker=null;this._workerInitializationPromise=this.initializeServiceWorkerMessaging().then((()=>{}),(()=>{}))}async _openDb(){if(this.db){return this.db}this.db=await _openDatabase();return this.db}async _withRetries(op){let numAttempts=0;while(true){try{const db=await this._openDb();return await op(db)}catch(e){if(numAttempts++>_TRANSACTION_RETRY_COUNT){throw e}if(this.db){this.db.close();this.db=undefined}}}}async initializeServiceWorkerMessaging(){return _isWorker()?this.initializeReceiver():this.initializeSender()}async initializeReceiver(){this.receiver=Receiver._getInstance(_getWorkerGlobalScope());this.receiver._subscribe("keyChanged",(async(_origin,data)=>{const keys=await this._poll();return{keyProcessed:keys.includes(data.key)}}));this.receiver._subscribe("ping",(async(_origin,_data)=>["keyChanged"]))}async initializeSender(){var _a,_b;this.activeServiceWorker=await _getActiveServiceWorker();if(!this.activeServiceWorker){return}this.sender=new Sender(this.activeServiceWorker);const results=await this.sender._send("ping",{},800);if(!results){return}if(((_a=results[0])===null||_a===void 0?void 0:_a.fulfilled)&&((_b=results[0])===null||_b===void 0?void 0:_b.value.includes("keyChanged"))){this.serviceWorkerReceiverAvailable=true}}async notifyServiceWorker(key){if(!this.sender||!this.activeServiceWorker||_getServiceWorkerController()!==this.activeServiceWorker){return}try{await this.sender._send("keyChanged",{key:key},this.serviceWorkerReceiverAvailable?800:50)}catch(_a){}}async _isAvailable(){try{if(!indexedDB){return false}const db=await _openDatabase();await _putObject(db,STORAGE_AVAILABLE_KEY,"1");await _deleteObject(db,STORAGE_AVAILABLE_KEY);return true}catch(_a){}return false}async _withPendingWrite(write){this.pendingWrites++;try{await write()}finally{this.pendingWrites--}}async _set(key,value){return this._withPendingWrite((async()=>{await this._withRetries((db=>_putObject(db,key,value)));this.localCache[key]=value;return this.notifyServiceWorker(key)}))}async _get(key){const obj=await this._withRetries((db=>getObject(db,key)));this.localCache[key]=obj;return obj}async _remove(key){return this._withPendingWrite((async()=>{await this._withRetries((db=>_deleteObject(db,key)));delete this.localCache[key];return this.notifyServiceWorker(key)}))}async _poll(){const result=await this._withRetries((db=>{const getAllRequest=getObjectStore(db,false).getAll();return new DBPromise(getAllRequest).toPromise()}));if(!result){return[]}if(this.pendingWrites!==0){return[]}const keys=[];const keysInResult=new Set;if(result.length!==0){for(const{fbase_key:key,value:value}of result){keysInResult.add(key);if(JSON.stringify(this.localCache[key])!==JSON.stringify(value)){this.notifyListeners(key,value);keys.push(key)}}}for(const localKey of Object.keys(this.localCache)){if(this.localCache[localKey]&&!keysInResult.has(localKey)){this.notifyListeners(localKey,null);keys.push(localKey)}}return keys}notifyListeners(key,newValue){this.localCache[key]=newValue;const listeners=this.listeners[key];if(listeners){for(const listener of Array.from(listeners)){listener(newValue)}}}startPolling(){this.stopPolling();this.pollTimer=setInterval((async()=>this._poll()),_POLLING_INTERVAL_MS)}stopPolling(){if(this.pollTimer){clearInterval(this.pollTimer);this.pollTimer=null}}_addListener(key,listener){if(Object.keys(this.listeners).length===0){this.startPolling()}if(!this.listeners[key]){this.listeners[key]=new Set;void this._get(key)}this.listeners[key].add(listener)}_removeListener(key,listener){if(this.listeners[key]){this.listeners[key].delete(listener);if(this.listeners[key].size===0){delete this.listeners[key]}}if(Object.keys(this.listeners).length===0){this.stopPolling()}}}IndexedDBLocalPersistence.type="LOCAL";const indexedDBLocalPersistence=IndexedDBLocalPersistence;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.i=indexedDBLocalPersistence;function startSignInPhoneMfa(auth,request){return _performApiRequest(auth,"POST","/v2/accounts/mfaSignIn:start",_addTidIfNecessary(auth,request))}function finalizeSignInPhoneMfa(auth,request){return _performApiRequest(auth,"POST","/v2/accounts/mfaSignIn:finalize",_addTidIfNecessary(auth,request))}function finalizeSignInTotpMfa(auth,request){return _performApiRequest(auth,"POST","/v2/accounts/mfaSignIn:finalize",_addTidIfNecessary(auth,request))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _SOLVE_TIME_MS=500;const _EXPIRATION_TIME_MS=6e4;const _WIDGET_ID_START=1e12;class MockReCaptcha{constructor(auth){this.auth=auth;this.counter=_WIDGET_ID_START;this._widgets=new Map}render(container,parameters){const id=this.counter;this._widgets.set(id,new MockWidget(container,this.auth.name,parameters||{}));this.counter++;return id}reset(optWidgetId){var _a;const id=optWidgetId||_WIDGET_ID_START;void((_a=this._widgets.get(id))===null||_a===void 0?void 0:_a.delete());this._widgets.delete(id)}getResponse(optWidgetId){var _a;const id=optWidgetId||_WIDGET_ID_START;return((_a=this._widgets.get(id))===null||_a===void 0?void 0:_a.getResponse())||""}async execute(optWidgetId){var _a;const id=optWidgetId||_WIDGET_ID_START;void((_a=this._widgets.get(id))===null||_a===void 0?void 0:_a.execute());return""}}class MockWidget{constructor(containerOrId,appName,params){this.params=params;this.timerId=null;this.deleted=false;this.responseToken=null;this.clickHandler=()=>{this.execute()};const container=typeof containerOrId==="string"?document.getElementById(containerOrId):containerOrId;_assert(container,"argument-error",{appName:appName});this.container=container;this.isVisible=this.params.size!=="invisible";if(this.isVisible){this.execute()}else{this.container.addEventListener("click",this.clickHandler)}}getResponse(){this.checkIfDeleted();return this.responseToken}delete(){this.checkIfDeleted();this.deleted=true;if(this.timerId){clearTimeout(this.timerId);this.timerId=null}this.container.removeEventListener("click",this.clickHandler)}execute(){this.checkIfDeleted();if(this.timerId){return}this.timerId=window.setTimeout((()=>{this.responseToken=generateRandomAlphaNumericString(50);const{callback:callback,"expired-callback":expiredCallback}=this.params;if(callback){try{callback(this.responseToken)}catch(e){}}this.timerId=window.setTimeout((()=>{this.timerId=null;this.responseToken=null;if(expiredCallback){try{expiredCallback()}catch(e){}}if(this.isVisible){this.execute()}}),_EXPIRATION_TIME_MS)}),_SOLVE_TIME_MS)}checkIfDeleted(){if(this.deleted){throw new Error("reCAPTCHA mock was already deleted!")}}}function generateRandomAlphaNumericString(len){const chars=[];const allowedChars="1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";for(let i=0;i<len;i++){chars.push(allowedChars.charAt(Math.floor(Math.random()*allowedChars.length)))}return chars.join("")}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _JSLOAD_CALLBACK=_generateCallbackName("rcb");const NETWORK_TIMEOUT_DELAY=new Delay(3e4,6e4);class ReCaptchaLoaderImpl{constructor(){var _a;this.hostLanguage="";this.counter=0;this.librarySeparatelyLoaded=!!((_a=_window().grecaptcha)===null||_a===void 0?void 0:_a.render)}load(auth,hl=""){_assert(isHostLanguageValid(hl),auth,"argument-error");if(this.shouldResolveImmediately(hl)&&isV2(_window().grecaptcha)){return Promise.resolve(_window().grecaptcha)}return new Promise(((resolve,reject)=>{const networkTimeout=_window().setTimeout((()=>{reject(_createError(auth,"network-request-failed"))}),NETWORK_TIMEOUT_DELAY.get());_window()[_JSLOAD_CALLBACK]=()=>{_window().clearTimeout(networkTimeout);delete _window()[_JSLOAD_CALLBACK];const recaptcha=_window().grecaptcha;if(!recaptcha||!isV2(recaptcha)){reject(_createError(auth,"internal-error"));return}const render=recaptcha.render;recaptcha.render=(container,params)=>{const widgetId=render(container,params);this.counter++;return widgetId};this.hostLanguage=hl;resolve(recaptcha)};const url=`${_recaptchaV2ScriptUrl()}?${(0,_util.querystring)({onload:_JSLOAD_CALLBACK,render:"explicit",hl:hl})}`;_loadJS(url).catch((()=>{clearTimeout(networkTimeout);reject(_createError(auth,"internal-error"))}))}))}clearedOneInstance(){this.counter--}shouldResolveImmediately(hl){var _a;return!!((_a=_window().grecaptcha)===null||_a===void 0?void 0:_a.render)&&(hl===this.hostLanguage||this.counter>0||this.librarySeparatelyLoaded)}}function isHostLanguageValid(hl){return hl.length<=6&&/^\s*[a-zA-Z0-9\-]*\s*$/.test(hl)}class MockReCaptchaLoaderImpl{async load(auth){return new MockReCaptcha(auth)}clearedOneInstance(){}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const RECAPTCHA_VERIFIER_TYPE="recaptcha";const DEFAULT_PARAMS={theme:"light",type:"image"};class RecaptchaVerifier{constructor(authExtern,containerOrId,parameters=Object.assign({},DEFAULT_PARAMS)){this.parameters=parameters;this.type=RECAPTCHA_VERIFIER_TYPE;this.destroyed=false;this.widgetId=null;this.tokenChangeListeners=new Set;this.renderPromise=null;this.recaptcha=null;this.auth=_castAuth(authExtern);this.isInvisible=this.parameters.size==="invisible";_assert(typeof document!=="undefined",this.auth,"operation-not-supported-in-this-environment");const container=typeof containerOrId==="string"?document.getElementById(containerOrId):containerOrId;_assert(container,this.auth,"argument-error");this.container=container;this.parameters.callback=this.makeTokenCallback(this.parameters.callback);this._recaptchaLoader=this.auth.settings.appVerificationDisabledForTesting?new MockReCaptchaLoaderImpl:new ReCaptchaLoaderImpl;this.validateStartingState()}async verify(){this.assertNotDestroyed();const id=await this.render();const recaptcha=this.getAssertedRecaptcha();const response=recaptcha.getResponse(id);if(response){return response}return new Promise((resolve=>{const tokenChange=token=>{if(!token){return}this.tokenChangeListeners.delete(tokenChange);resolve(token)};this.tokenChangeListeners.add(tokenChange);if(this.isInvisible){recaptcha.execute(id)}}))}render(){try{this.assertNotDestroyed()}catch(e){return Promise.reject(e)}if(this.renderPromise){return this.renderPromise}this.renderPromise=this.makeRenderPromise().catch((e=>{this.renderPromise=null;throw e}));return this.renderPromise}_reset(){this.assertNotDestroyed();if(this.widgetId!==null){this.getAssertedRecaptcha().reset(this.widgetId)}}clear(){this.assertNotDestroyed();this.destroyed=true;this._recaptchaLoader.clearedOneInstance();if(!this.isInvisible){this.container.childNodes.forEach((node=>{this.container.removeChild(node)}))}}validateStartingState(){_assert(!this.parameters.sitekey,this.auth,"argument-error");_assert(this.isInvisible||!this.container.hasChildNodes(),this.auth,"argument-error");_assert(typeof document!=="undefined",this.auth,"operation-not-supported-in-this-environment")}makeTokenCallback(existing){return token=>{this.tokenChangeListeners.forEach((listener=>listener(token)));if(typeof existing==="function"){existing(token)}else if(typeof existing==="string"){const globalFunc=_window()[existing];if(typeof globalFunc==="function"){globalFunc(token)}}}}assertNotDestroyed(){_assert(!this.destroyed,this.auth,"internal-error")}async makeRenderPromise(){await this.init();if(!this.widgetId){let container=this.container;if(!this.isInvisible){const guaranteedEmpty=document.createElement("div");container.appendChild(guaranteedEmpty);container=guaranteedEmpty}this.widgetId=this.getAssertedRecaptcha().render(container,this.parameters)}return this.widgetId}async init(){_assert(_isHttpOrHttps()&&!_isWorker(),this.auth,"internal-error");await domReady();this.recaptcha=await this._recaptchaLoader.load(this.auth,this.auth.languageCode||undefined);const siteKey=await getRecaptchaParams(this.auth);_assert(siteKey,this.auth,"internal-error");this.parameters.sitekey=siteKey}getAssertedRecaptcha(){_assert(this.recaptcha,this.auth,"internal-error");return this.recaptcha}}exports.R=RecaptchaVerifier;function domReady(){let resolver=null;return new Promise((resolve=>{if(document.readyState==="complete"){resolve();return}resolver=()=>resolve();window.addEventListener("load",resolver)})).catch((e=>{if(resolver){window.removeEventListener("load",resolver)}throw e}))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ConfirmationResultImpl{constructor(verificationId,onConfirmation){this.verificationId=verificationId;this.onConfirmation=onConfirmation}confirm(verificationCode){const authCredential=PhoneAuthCredential._fromVerification(this.verificationId,verificationCode);return this.onConfirmation(authCredential)}}async function signInWithPhoneNumber(auth,phoneNumber,appVerifier){if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth))}const authInternal=_castAuth(auth);const verificationId=await _verifyPhoneNumber(authInternal,phoneNumber,(0,_util.getModularInstance)(appVerifier));return new ConfirmationResultImpl(verificationId,(cred=>signInWithCredential(authInternal,cred)))}async function linkWithPhoneNumber(user,phoneNumber,appVerifier){const userInternal=(0,_util.getModularInstance)(user);await _assertLinkedStatus(false,userInternal,"phone");const verificationId=await _verifyPhoneNumber(userInternal.auth,phoneNumber,(0,_util.getModularInstance)(appVerifier));return new ConfirmationResultImpl(verificationId,(cred=>linkWithCredential(userInternal,cred)))}async function reauthenticateWithPhoneNumber(user,phoneNumber,appVerifier){const userInternal=(0,_util.getModularInstance)(user);if((0,_app._isFirebaseServerApp)(userInternal.auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth))}const verificationId=await _verifyPhoneNumber(userInternal.auth,phoneNumber,(0,_util.getModularInstance)(appVerifier));return new ConfirmationResultImpl(verificationId,(cred=>reauthenticateWithCredential(userInternal,cred)))}async function _verifyPhoneNumber(auth,options,verifier){var _a;const recaptchaToken=await verifier.verify();try{_assert(typeof recaptchaToken==="string",auth,"argument-error");_assert(verifier.type===RECAPTCHA_VERIFIER_TYPE,auth,"argument-error");let phoneInfoOptions;if(typeof options==="string"){phoneInfoOptions={phoneNumber:options}}else{phoneInfoOptions=options}if("session"in phoneInfoOptions){const session=phoneInfoOptions.session;if("phoneNumber"in phoneInfoOptions){_assert(session.type==="enroll",auth,"internal-error");const response=await startEnrollPhoneMfa(auth,{idToken:session.credential,phoneEnrollmentInfo:{phoneNumber:phoneInfoOptions.phoneNumber,recaptchaToken:recaptchaToken}});return response.phoneSessionInfo.sessionInfo}else{_assert(session.type==="signin",auth,"internal-error");const mfaEnrollmentId=((_a=phoneInfoOptions.multiFactorHint)===null||_a===void 0?void 0:_a.uid)||phoneInfoOptions.multiFactorUid;_assert(mfaEnrollmentId,auth,"missing-multi-factor-info");const response=await startSignInPhoneMfa(auth,{mfaPendingCredential:session.credential,mfaEnrollmentId:mfaEnrollmentId,phoneSignInInfo:{recaptchaToken:recaptchaToken}});return response.phoneResponseInfo.sessionInfo}}else{const{sessionInfo:sessionInfo}=await sendPhoneVerificationCode(auth,{phoneNumber:phoneInfoOptions.phoneNumber,recaptchaToken:recaptchaToken});return sessionInfo}}finally{verifier._reset()}}async function updatePhoneNumber(user,credential){const userInternal=(0,_util.getModularInstance)(user);if((0,_app._isFirebaseServerApp)(userInternal.auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth))}await _link$1(userInternal,credential)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class PhoneAuthProvider{constructor(auth){this.providerId=PhoneAuthProvider.PROVIDER_ID;this.auth=_castAuth(auth)}verifyPhoneNumber(phoneOptions,applicationVerifier){return _verifyPhoneNumber(this.auth,phoneOptions,(0,_util.getModularInstance)(applicationVerifier))}static credential(verificationId,verificationCode){return PhoneAuthCredential._fromVerification(verificationId,verificationCode)}static credentialFromResult(userCredential){const credential=userCredential;return PhoneAuthProvider.credentialFromTaggedObject(credential)}static credentialFromError(error){return PhoneAuthProvider.credentialFromTaggedObject(error.customData||{})}static credentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse){return null}const{phoneNumber:phoneNumber,temporaryProof:temporaryProof}=tokenResponse;if(phoneNumber&&temporaryProof){return PhoneAuthCredential._fromTokenResponse(phoneNumber,temporaryProof)}return null}}exports.P=PhoneAuthProvider;PhoneAuthProvider.PROVIDER_ID="phone";PhoneAuthProvider.PHONE_SIGN_IN_METHOD="phone";
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _withDefaultResolver(auth,resolverOverride){if(resolverOverride){return _getInstance(resolverOverride)}_assert(auth._popupRedirectResolver,auth,"argument-error");return auth._popupRedirectResolver}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class IdpCredential extends AuthCredential{constructor(params){super("custom","custom");this.params=params}_getIdTokenResponse(auth){return signInWithIdp(auth,this._buildIdpRequest())}_linkToIdToken(auth,idToken){return signInWithIdp(auth,this._buildIdpRequest(idToken))}_getReauthenticationResolver(auth){return signInWithIdp(auth,this._buildIdpRequest())}_buildIdpRequest(idToken){const request={requestUri:this.params.requestUri,sessionId:this.params.sessionId,postBody:this.params.postBody,tenantId:this.params.tenantId,pendingToken:this.params.pendingToken,returnSecureToken:true,returnIdpCredential:true};if(idToken){request.idToken=idToken}return request}}function _signIn(params){return _signInWithCredential(params.auth,new IdpCredential(params),params.bypassAuthState)}function _reauth(params){const{auth:auth,user:user}=params;_assert(user,auth,"internal-error");return _reauthenticate(user,new IdpCredential(params),params.bypassAuthState)}async function _link(params){const{auth:auth,user:user}=params;_assert(user,auth,"internal-error");return _link$1(user,new IdpCredential(params),params.bypassAuthState)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class AbstractPopupRedirectOperation{constructor(auth,filter,resolver,user,bypassAuthState=false){this.auth=auth;this.resolver=resolver;this.user=user;this.bypassAuthState=bypassAuthState;this.pendingPromise=null;this.eventManager=null;this.filter=Array.isArray(filter)?filter:[filter]}execute(){return new Promise((async(resolve,reject)=>{this.pendingPromise={resolve:resolve,reject:reject};try{this.eventManager=await this.resolver._initialize(this.auth);await this.onExecution();this.eventManager.registerConsumer(this)}catch(e){this.reject(e)}}))}async onAuthEvent(event){const{urlResponse:urlResponse,sessionId:sessionId,postBody:postBody,tenantId:tenantId,error:error,type:type}=event;if(error){this.reject(error);return}const params={auth:this.auth,requestUri:urlResponse,sessionId:sessionId,tenantId:tenantId||undefined,postBody:postBody||undefined,user:this.user,bypassAuthState:this.bypassAuthState};try{this.resolve(await this.getIdpTask(type)(params))}catch(e){this.reject(e)}}onError(error){this.reject(error)}getIdpTask(type){switch(type){case"signInViaPopup":case"signInViaRedirect":return _signIn;case"linkViaPopup":case"linkViaRedirect":return _link;case"reauthViaPopup":case"reauthViaRedirect":return _reauth;default:_fail(this.auth,"internal-error")}}resolve(cred){debugAssert(this.pendingPromise,"Pending promise was never set");this.pendingPromise.resolve(cred);this.unregisterAndCleanUp()}reject(error){debugAssert(this.pendingPromise,"Pending promise was never set");this.pendingPromise.reject(error);this.unregisterAndCleanUp()}unregisterAndCleanUp(){if(this.eventManager){this.eventManager.unregisterConsumer(this)}this.pendingPromise=null;this.cleanUp()}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _POLL_WINDOW_CLOSE_TIMEOUT=new Delay(2e3,1e4);async function signInWithPopup(auth,provider,resolver){if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_createError(auth,"operation-not-supported-in-this-environment"))}const authInternal=_castAuth(auth);_assertInstanceOf(auth,provider,FederatedAuthProvider);const resolverInternal=_withDefaultResolver(authInternal,resolver);const action=new PopupOperation(authInternal,"signInViaPopup",provider,resolverInternal);return action.executeNotNull()}async function reauthenticateWithPopup(user,provider,resolver){const userInternal=(0,_util.getModularInstance)(user);if((0,_app._isFirebaseServerApp)(userInternal.auth.app)){return Promise.reject(_createError(userInternal.auth,"operation-not-supported-in-this-environment"))}_assertInstanceOf(userInternal.auth,provider,FederatedAuthProvider);const resolverInternal=_withDefaultResolver(userInternal.auth,resolver);const action=new PopupOperation(userInternal.auth,"reauthViaPopup",provider,resolverInternal,userInternal);return action.executeNotNull()}async function linkWithPopup(user,provider,resolver){const userInternal=(0,_util.getModularInstance)(user);_assertInstanceOf(userInternal.auth,provider,FederatedAuthProvider);const resolverInternal=_withDefaultResolver(userInternal.auth,resolver);const action=new PopupOperation(userInternal.auth,"linkViaPopup",provider,resolverInternal,userInternal);return action.executeNotNull()}class PopupOperation extends AbstractPopupRedirectOperation{constructor(auth,filter,provider,resolver,user){super(auth,filter,resolver,user);this.provider=provider;this.authWindow=null;this.pollId=null;if(PopupOperation.currentPopupAction){PopupOperation.currentPopupAction.cancel()}PopupOperation.currentPopupAction=this}async executeNotNull(){const result=await this.execute();_assert(result,this.auth,"internal-error");return result}async onExecution(){debugAssert(this.filter.length===1,"Popup operations only handle one event");const eventId=_generateEventId();this.authWindow=await this.resolver._openPopup(this.auth,this.provider,this.filter[0],eventId);this.authWindow.associatedEvent=eventId;this.resolver._originValidation(this.auth).catch((e=>{this.reject(e)}));this.resolver._isIframeWebStorageSupported(this.auth,(isSupported=>{if(!isSupported){this.reject(_createError(this.auth,"web-storage-unsupported"))}}));this.pollUserCancellation()}get eventId(){var _a;return((_a=this.authWindow)===null||_a===void 0?void 0:_a.associatedEvent)||null}cancel(){this.reject(_createError(this.auth,"cancelled-popup-request"))}cleanUp(){if(this.authWindow){this.authWindow.close()}if(this.pollId){window.clearTimeout(this.pollId)}this.authWindow=null;this.pollId=null;PopupOperation.currentPopupAction=null}pollUserCancellation(){const poll=()=>{var _a,_b;if((_b=(_a=this.authWindow)===null||_a===void 0?void 0:_a.window)===null||_b===void 0?void 0:_b.closed){this.pollId=window.setTimeout((()=>{this.pollId=null;this.reject(_createError(this.auth,"popup-closed-by-user"))}),8e3);return}this.pollId=window.setTimeout(poll,_POLL_WINDOW_CLOSE_TIMEOUT.get())};poll()}}PopupOperation.currentPopupAction=null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const PENDING_REDIRECT_KEY="pendingRedirect";const redirectOutcomeMap=new Map;class RedirectAction extends AbstractPopupRedirectOperation{constructor(auth,resolver,bypassAuthState=false){super(auth,["signInViaRedirect","linkViaRedirect","reauthViaRedirect","unknown"],resolver,undefined,bypassAuthState);this.eventId=null}async execute(){let readyOutcome=redirectOutcomeMap.get(this.auth._key());if(!readyOutcome){try{const hasPendingRedirect=await _getAndClearPendingRedirectStatus(this.resolver,this.auth);const result=hasPendingRedirect?await super.execute():null;readyOutcome=()=>Promise.resolve(result)}catch(e){readyOutcome=()=>Promise.reject(e)}redirectOutcomeMap.set(this.auth._key(),readyOutcome)}if(!this.bypassAuthState){redirectOutcomeMap.set(this.auth._key(),(()=>Promise.resolve(null)))}return readyOutcome()}async onAuthEvent(event){if(event.type==="signInViaRedirect"){return super.onAuthEvent(event)}else if(event.type==="unknown"){this.resolve(null);return}if(event.eventId){const user=await this.auth._redirectUserForId(event.eventId);if(user){this.user=user;return super.onAuthEvent(event)}else{this.resolve(null)}}}async onExecution(){}cleanUp(){}}async function _getAndClearPendingRedirectStatus(resolver,auth){const key=pendingRedirectKey(auth);const persistence=resolverPersistence(resolver);if(!await persistence._isAvailable()){return false}const hasPendingRedirect=await persistence._get(key)==="true";await persistence._remove(key);return hasPendingRedirect}async function _setPendingRedirectStatus(resolver,auth){return resolverPersistence(resolver)._set(pendingRedirectKey(auth),"true")}function _clearRedirectOutcomes(){redirectOutcomeMap.clear()}function _overrideRedirectResult(auth,result){redirectOutcomeMap.set(auth._key(),result)}function resolverPersistence(resolver){return _getInstance(resolver._redirectPersistence)}function pendingRedirectKey(auth){return _persistenceKeyName(PENDING_REDIRECT_KEY,auth.config.apiKey,auth.name)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function signInWithRedirect(auth,provider,resolver){return _signInWithRedirect(auth,provider,resolver)}async function _signInWithRedirect(auth,provider,resolver){if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth))}const authInternal=_castAuth(auth);_assertInstanceOf(auth,provider,FederatedAuthProvider);await authInternal._initializationPromise;const resolverInternal=_withDefaultResolver(authInternal,resolver);await _setPendingRedirectStatus(resolverInternal,authInternal);return resolverInternal._openRedirect(authInternal,provider,"signInViaRedirect")}function reauthenticateWithRedirect(user,provider,resolver){return _reauthenticateWithRedirect(user,provider,resolver)}async function _reauthenticateWithRedirect(user,provider,resolver){const userInternal=(0,_util.getModularInstance)(user);_assertInstanceOf(userInternal.auth,provider,FederatedAuthProvider);if((0,_app._isFirebaseServerApp)(userInternal.auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth))}await userInternal.auth._initializationPromise;const resolverInternal=_withDefaultResolver(userInternal.auth,resolver);await _setPendingRedirectStatus(resolverInternal,userInternal.auth);const eventId=await prepareUserForRedirect(userInternal);return resolverInternal._openRedirect(userInternal.auth,provider,"reauthViaRedirect",eventId)}function linkWithRedirect(user,provider,resolver){return _linkWithRedirect(user,provider,resolver)}async function _linkWithRedirect(user,provider,resolver){const userInternal=(0,_util.getModularInstance)(user);_assertInstanceOf(userInternal.auth,provider,FederatedAuthProvider);await userInternal.auth._initializationPromise;const resolverInternal=_withDefaultResolver(userInternal.auth,resolver);await _assertLinkedStatus(false,userInternal,provider.providerId);await _setPendingRedirectStatus(resolverInternal,userInternal.auth);const eventId=await prepareUserForRedirect(userInternal);return resolverInternal._openRedirect(userInternal.auth,provider,"linkViaRedirect",eventId)}async function getRedirectResult(auth,resolver){await _castAuth(auth)._initializationPromise;return _getRedirectResult(auth,resolver,false)}async function _getRedirectResult(auth,resolverExtern,bypassAuthState=false){if((0,_app._isFirebaseServerApp)(auth.app)){return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth))}const authInternal=_castAuth(auth);const resolver=_withDefaultResolver(authInternal,resolverExtern);const action=new RedirectAction(authInternal,resolver,bypassAuthState);const result=await action.execute();if(result&&!bypassAuthState){delete result.user._redirectEventId;await authInternal._persistUserIfCurrent(result.user);await authInternal._setRedirectUser(null,resolverExtern)}return result}async function prepareUserForRedirect(user){const eventId=_generateEventId(`${user.uid}:::`);user._redirectEventId=eventId;await user.auth._setRedirectUser(user);await user.auth._persistUserIfCurrent(user);return eventId}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const EVENT_DUPLICATION_CACHE_DURATION_MS=10*60*1e3;class AuthEventManager{constructor(auth){this.auth=auth;this.cachedEventUids=new Set;this.consumers=new Set;this.queuedRedirectEvent=null;this.hasHandledPotentialRedirect=false;this.lastProcessedEventTime=Date.now()}registerConsumer(authEventConsumer){this.consumers.add(authEventConsumer);if(this.queuedRedirectEvent&&this.isEventForConsumer(this.queuedRedirectEvent,authEventConsumer)){this.sendToConsumer(this.queuedRedirectEvent,authEventConsumer);this.saveEventToCache(this.queuedRedirectEvent);this.queuedRedirectEvent=null}}unregisterConsumer(authEventConsumer){this.consumers.delete(authEventConsumer)}onEvent(event){if(this.hasEventBeenHandled(event)){return false}let handled=false;this.consumers.forEach((consumer=>{if(this.isEventForConsumer(event,consumer)){handled=true;this.sendToConsumer(event,consumer);this.saveEventToCache(event)}}));if(this.hasHandledPotentialRedirect||!isRedirectEvent(event)){return handled}this.hasHandledPotentialRedirect=true;if(!handled){this.queuedRedirectEvent=event;handled=true}return handled}sendToConsumer(event,consumer){var _a;if(event.error&&!isNullRedirectEvent(event)){const code=((_a=event.error.code)===null||_a===void 0?void 0:_a.split("auth/")[1])||"internal-error";consumer.onError(_createError(this.auth,code))}else{consumer.onAuthEvent(event)}}isEventForConsumer(event,consumer){const eventIdMatches=consumer.eventId===null||!!event.eventId&&event.eventId===consumer.eventId;return consumer.filter.includes(event.type)&&eventIdMatches}hasEventBeenHandled(event){if(Date.now()-this.lastProcessedEventTime>=EVENT_DUPLICATION_CACHE_DURATION_MS){this.cachedEventUids.clear()}return this.cachedEventUids.has(eventUid(event))}saveEventToCache(event){this.cachedEventUids.add(eventUid(event));this.lastProcessedEventTime=Date.now()}}exports.aD=AuthEventManager;function eventUid(e){return[e.type,e.eventId,e.sessionId,e.tenantId].filter((v=>v)).join("-")}function isNullRedirectEvent({type:type,error:error}){return type==="unknown"&&(error===null||error===void 0?void 0:error.code)===`auth/${"no-auth-event"}`}function isRedirectEvent(event){switch(event.type){case"signInViaRedirect":case"linkViaRedirect":case"reauthViaRedirect":return true;case"unknown":return isNullRedirectEvent(event);default:return false}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function _getProjectConfig(auth,request={}){return _performApiRequest(auth,"GET","/v1/projects",request)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const IP_ADDRESS_REGEX=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;const HTTP_REGEX=/^https?/;async function _validateOrigin(auth){if(auth.config.emulator){return}const{authorizedDomains:authorizedDomains}=await _getProjectConfig(auth);for(const domain of authorizedDomains){try{if(matchDomain(domain)){return}}catch(_a){}}_fail(auth,"unauthorized-domain")}function matchDomain(expected){const currentUrl=_getCurrentUrl();const{protocol:protocol,hostname:hostname}=new URL(currentUrl);if(expected.startsWith("chrome-extension://")){const ceUrl=new URL(expected);if(ceUrl.hostname===""&&hostname===""){return protocol==="chrome-extension:"&&expected.replace("chrome-extension://","")===currentUrl.replace("chrome-extension://","")}return protocol==="chrome-extension:"&&ceUrl.hostname===hostname}if(!HTTP_REGEX.test(protocol)){return false}if(IP_ADDRESS_REGEX.test(expected)){return hostname===expected}const escapedDomainPattern=expected.replace(/\./g,"\\.");const re=new RegExp("^(.+\\."+escapedDomainPattern+"|"+escapedDomainPattern+")$","i");return re.test(hostname)}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const NETWORK_TIMEOUT=new Delay(3e4,6e4);function resetUnloadedGapiModules(){const beacon=_window().___jsl;if(beacon===null||beacon===void 0?void 0:beacon.H){for(const hint of Object.keys(beacon.H)){beacon.H[hint].r=beacon.H[hint].r||[];beacon.H[hint].L=beacon.H[hint].L||[];beacon.H[hint].r=[...beacon.H[hint].L];if(beacon.CP){for(let i=0;i<beacon.CP.length;i++){beacon.CP[i]=null}}}}}function loadGapi(auth){return new Promise(((resolve,reject)=>{var _a,_b,_c;function loadGapiIframe(){resetUnloadedGapiModules();gapi.load("gapi.iframes",{callback:()=>{resolve(gapi.iframes.getContext())},ontimeout:()=>{resetUnloadedGapiModules();reject(_createError(auth,"network-request-failed"))},timeout:NETWORK_TIMEOUT.get()})}if((_b=(_a=_window().gapi)===null||_a===void 0?void 0:_a.iframes)===null||_b===void 0?void 0:_b.Iframe){resolve(gapi.iframes.getContext())}else if(!!((_c=_window().gapi)===null||_c===void 0?void 0:_c.load)){loadGapiIframe()}else{const cbName=_generateCallbackName("iframefcb");_window()[cbName]=()=>{if(!!gapi.load){loadGapiIframe()}else{reject(_createError(auth,"network-request-failed"))}};return _loadJS(`${_gapiScriptUrl()}?onload=${cbName}`).catch((e=>reject(e)))}})).catch((error=>{cachedGApiLoader=null;throw error}))}let cachedGApiLoader=null;function _loadGapi(auth){cachedGApiLoader=cachedGApiLoader||loadGapi(auth);return cachedGApiLoader}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const PING_TIMEOUT=new Delay(5e3,15e3);const IFRAME_PATH="__/auth/iframe";const EMULATED_IFRAME_PATH="emulator/auth/iframe";const IFRAME_ATTRIBUTES={style:{position:"absolute",top:"-100px",width:"1px",height:"1px"},"aria-hidden":"true",tabindex:"-1"};const EID_FROM_APIHOST=new Map([["identitytoolkit.googleapis.com","p"],["staging-identitytoolkit.sandbox.googleapis.com","s"],["test-identitytoolkit.sandbox.googleapis.com","t"]]);function getIframeUrl(auth){const config=auth.config;_assert(config.authDomain,auth,"auth-domain-config-required");const url=config.emulator?_emulatorUrl(config,EMULATED_IFRAME_PATH):`https://${auth.config.authDomain}/${IFRAME_PATH}`;const params={apiKey:config.apiKey,appName:auth.name,v:_app.SDK_VERSION};const eid=EID_FROM_APIHOST.get(auth.config.apiHost);if(eid){params.eid=eid}const frameworks=auth._getFrameworks();if(frameworks.length){params.fw=frameworks.join(",")}return`${url}?${(0,_util.querystring)(params).slice(1)}`}async function _openIframe(auth){const context=await _loadGapi(auth);const gapi=_window().gapi;_assert(gapi,auth,"internal-error");return context.open({where:document.body,url:getIframeUrl(auth),messageHandlersFilter:gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER,attributes:IFRAME_ATTRIBUTES,dontclear:true},(iframe=>new Promise((async(resolve,reject)=>{await iframe.restyle({setHideOnLeave:false});const networkError=_createError(auth,"network-request-failed");const networkErrorTimer=_window().setTimeout((()=>{reject(networkError)}),PING_TIMEOUT.get());function clearTimerAndResolve(){_window().clearTimeout(networkErrorTimer);resolve(iframe)}iframe.ping(clearTimerAndResolve).then(clearTimerAndResolve,(()=>{reject(networkError)}))}))))}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const BASE_POPUP_OPTIONS={location:"yes",resizable:"yes",statusbar:"yes",toolbar:"no"};const DEFAULT_WIDTH=500;const DEFAULT_HEIGHT=600;const TARGET_BLANK="_blank";const FIREFOX_EMPTY_URL="http://localhost";class AuthPopup{constructor(window){this.window=window;this.associatedEvent=null}close(){if(this.window){try{this.window.close()}catch(e){}}}}exports.aO=AuthPopup;function _open(auth,url,name,width=DEFAULT_WIDTH,height=DEFAULT_HEIGHT){const top=Math.max((window.screen.availHeight-height)/2,0).toString();const left=Math.max((window.screen.availWidth-width)/2,0).toString();let target="";const options=Object.assign(Object.assign({},BASE_POPUP_OPTIONS),{width:width.toString(),height:height.toString(),top:top,left:left});const ua=(0,_util.getUA)().toLowerCase();if(name){target=_isChromeIOS(ua)?TARGET_BLANK:name}if(_isFirefox(ua)){url=url||FIREFOX_EMPTY_URL;options.scrollbars="yes"}const optionsString=Object.entries(options).reduce(((accum,[key,value])=>`${accum}${key}=${value},`),"");if(_isIOSStandalone(ua)&&target!=="_self"){openAsNewWindowIOS(url||"",target);return new AuthPopup(null)}const newWin=window.open(url||"",target,optionsString);_assert(newWin,auth,"popup-blocked");try{newWin.focus()}catch(e){}return new AuthPopup(newWin)}function openAsNewWindowIOS(url,target){const el=document.createElement("a");el.href=url;el.target=target;const click=document.createEvent("MouseEvent");click.initMouseEvent("click",true,true,window,1,0,0,0,0,false,false,false,false,1,null);el.dispatchEvent(click)}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const WIDGET_PATH="__/auth/handler";const EMULATOR_WIDGET_PATH="emulator/auth/handler";const FIREBASE_APP_CHECK_FRAGMENT_ID=encodeURIComponent("fac");async function _getRedirectUrl(auth,provider,authType,redirectUrl,eventId,additionalParams){_assert(auth.config.authDomain,auth,"auth-domain-config-required");_assert(auth.config.apiKey,auth,"invalid-api-key");const params={apiKey:auth.config.apiKey,appName:auth.name,authType:authType,redirectUrl:redirectUrl,v:_app.SDK_VERSION,eventId:eventId};if(provider instanceof FederatedAuthProvider){provider.setDefaultLanguage(auth.languageCode);params.providerId=provider.providerId||"";if(!(0,_util.isEmpty)(provider.getCustomParameters())){params.customParameters=JSON.stringify(provider.getCustomParameters())}for(const[key,value]of Object.entries(additionalParams||{})){params[key]=value}}if(provider instanceof BaseOAuthProvider){const scopes=provider.getScopes().filter((scope=>scope!==""));if(scopes.length>0){params.scopes=scopes.join(",")}}if(auth.tenantId){params.tid=auth.tenantId}const paramsDict=params;for(const key of Object.keys(paramsDict)){if(paramsDict[key]===undefined){delete paramsDict[key]}}const appCheckToken=await auth._getAppCheckToken();const appCheckTokenFragment=appCheckToken?`#${FIREBASE_APP_CHECK_FRAGMENT_ID}=${encodeURIComponent(appCheckToken)}`:"";return`${getHandlerBase(auth)}?${(0,_util.querystring)(paramsDict).slice(1)}${appCheckTokenFragment}`}function getHandlerBase({config:config}){if(!config.emulator){return`https://${config.authDomain}/${WIDGET_PATH}`}return _emulatorUrl(config,EMULATOR_WIDGET_PATH)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const WEB_STORAGE_SUPPORT_KEY="webStorageSupport";class BrowserPopupRedirectResolver{constructor(){this.eventManagers={};this.iframes={};this.originValidationPromises={};this._redirectPersistence=browserSessionPersistence;this._completeRedirectFn=_getRedirectResult;this._overrideRedirectResult=_overrideRedirectResult}async _openPopup(auth,provider,authType,eventId){var _a;debugAssert((_a=this.eventManagers[auth._key()])===null||_a===void 0?void 0:_a.manager,"_initialize() not called before _openPopup()");const url=await _getRedirectUrl(auth,provider,authType,_getCurrentUrl(),eventId);return _open(auth,url,_generateEventId())}async _openRedirect(auth,provider,authType,eventId){await this._originValidation(auth);const url=await _getRedirectUrl(auth,provider,authType,_getCurrentUrl(),eventId);_setWindowLocation(url);return new Promise((()=>{}))}_initialize(auth){const key=auth._key();if(this.eventManagers[key]){const{manager:manager,promise:promise}=this.eventManagers[key];if(manager){return Promise.resolve(manager)}else{debugAssert(promise,"If manager is not set, promise should be");return promise}}const promise=this.initAndGetManager(auth);this.eventManagers[key]={promise:promise};promise.catch((()=>{delete this.eventManagers[key]}));return promise}async initAndGetManager(auth){const iframe=await _openIframe(auth);const manager=new AuthEventManager(auth);iframe.register("authEvent",(iframeEvent=>{_assert(iframeEvent===null||iframeEvent===void 0?void 0:iframeEvent.authEvent,auth,"invalid-auth-event");const handled=manager.onEvent(iframeEvent.authEvent);return{status:handled?"ACK":"ERROR"}}),gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);this.eventManagers[auth._key()]={manager:manager};this.iframes[auth._key()]=iframe;return manager}_isIframeWebStorageSupported(auth,cb){const iframe=this.iframes[auth._key()];iframe.send(WEB_STORAGE_SUPPORT_KEY,{type:WEB_STORAGE_SUPPORT_KEY},(result=>{var _a;const isSupported=(_a=result===null||result===void 0?void 0:result[0])===null||_a===void 0?void 0:_a[WEB_STORAGE_SUPPORT_KEY];if(isSupported!==undefined){cb(!!isSupported)}_fail(auth,"internal-error")}),gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)}_originValidation(auth){const key=auth._key();if(!this.originValidationPromises[key]){this.originValidationPromises[key]=_validateOrigin(auth)}return this.originValidationPromises[key]}get _shouldInitProactively(){return _isMobileBrowser()||_isSafari()||_isIOS()}}const browserPopupRedirectResolver=BrowserPopupRedirectResolver;exports.k=browserPopupRedirectResolver;class MultiFactorAssertionImpl{constructor(factorId){this.factorId=factorId}_process(auth,session,displayName){switch(session.type){case"enroll":return this._finalizeEnroll(auth,session.credential,displayName);case"signin":return this._finalizeSignIn(auth,session.credential);default:return debugFail("unexpected MultiFactorSessionType")}}}class PhoneMultiFactorAssertionImpl extends MultiFactorAssertionImpl{constructor(credential){super("phone");this.credential=credential}static _fromCredential(credential){return new PhoneMultiFactorAssertionImpl(credential)}_finalizeEnroll(auth,idToken,displayName){return finalizeEnrollPhoneMfa(auth,{idToken:idToken,displayName:displayName,phoneVerificationInfo:this.credential._makeVerificationRequest()})}_finalizeSignIn(auth,mfaPendingCredential){return finalizeSignInPhoneMfa(auth,{mfaPendingCredential:mfaPendingCredential,phoneVerificationInfo:this.credential._makeVerificationRequest()})}}class PhoneMultiFactorGenerator{constructor(){}static assertion(credential){return PhoneMultiFactorAssertionImpl._fromCredential(credential)}}exports.m=PhoneMultiFactorGenerator;PhoneMultiFactorGenerator.FACTOR_ID="phone";class TotpMultiFactorGenerator{static assertionForEnrollment(secret,oneTimePassword){return TotpMultiFactorAssertionImpl._fromSecret(secret,oneTimePassword)}static assertionForSignIn(enrollmentId,oneTimePassword){return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId,oneTimePassword)}static async generateSecret(session){var _a;const mfaSession=session;_assert(typeof((_a=mfaSession.user)===null||_a===void 0?void 0:_a.auth)!=="undefined","internal-error");const response=await startEnrollTotpMfa(mfaSession.user.auth,{idToken:mfaSession.credential,totpEnrollmentInfo:{}});return TotpSecret._fromStartTotpMfaEnrollmentResponse(response,mfaSession.user.auth)}}exports.T=TotpMultiFactorGenerator;TotpMultiFactorGenerator.FACTOR_ID="totp";class TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl{constructor(otp,enrollmentId,secret){super("totp");this.otp=otp;this.enrollmentId=enrollmentId;this.secret=secret}static _fromSecret(secret,otp){return new TotpMultiFactorAssertionImpl(otp,undefined,secret)}static _fromEnrollmentId(enrollmentId,otp){return new TotpMultiFactorAssertionImpl(otp,enrollmentId)}async _finalizeEnroll(auth,idToken,displayName){_assert(typeof this.secret!=="undefined",auth,"argument-error");return finalizeEnrollTotpMfa(auth,{idToken:idToken,displayName:displayName,totpVerificationInfo:this.secret._makeTotpVerificationInfo(this.otp)})}async _finalizeSignIn(auth,mfaPendingCredential){_assert(this.enrollmentId!==undefined&&this.otp!==undefined,auth,"argument-error");const totpVerificationInfo={verificationCode:this.otp};return finalizeSignInTotpMfa(auth,{mfaPendingCredential:mfaPendingCredential,mfaEnrollmentId:this.enrollmentId,totpVerificationInfo:totpVerificationInfo})}}class TotpSecret{constructor(secretKey,hashingAlgorithm,codeLength,codeIntervalSeconds,enrollmentCompletionDeadline,sessionInfo,auth){this.sessionInfo=sessionInfo;this.auth=auth;this.secretKey=secretKey;this.hashingAlgorithm=hashingAlgorithm;this.codeLength=codeLength;this.codeIntervalSeconds=codeIntervalSeconds;this.enrollmentCompletionDeadline=enrollmentCompletionDeadline}static _fromStartTotpMfaEnrollmentResponse(response,auth){return new TotpSecret(response.totpSessionInfo.sharedSecretKey,response.totpSessionInfo.hashingAlgorithm,response.totpSessionInfo.verificationCodeLength,response.totpSessionInfo.periodSec,new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(),response.totpSessionInfo.sessionInfo,auth)}_makeTotpVerificationInfo(otp){return{sessionInfo:this.sessionInfo,verificationCode:otp}}generateQrCodeUrl(accountName,issuer){var _a;let useDefaults=false;if(_isEmptyString(accountName)||_isEmptyString(issuer)){useDefaults=true}if(useDefaults){if(_isEmptyString(accountName)){accountName=((_a=this.auth.currentUser)===null||_a===void 0?void 0:_a.email)||"unknownuser"}if(_isEmptyString(issuer)){issuer=this.auth.name}}return`otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`}}exports.n=TotpSecret;function _isEmptyString(input){return typeof input==="undefined"||(input===null||input===void 0?void 0:input.length)===0}var name="@firebase/auth";var version="1.7.2";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class AuthInterop{constructor(auth){this.auth=auth;this.internalListeners=new Map}getUid(){var _a;this.assertAuthConfigured();return((_a=this.auth.currentUser)===null||_a===void 0?void 0:_a.uid)||null}async getToken(forceRefresh){this.assertAuthConfigured();await this.auth._initializationPromise;if(!this.auth.currentUser){return null}const accessToken=await this.auth.currentUser.getIdToken(forceRefresh);return{accessToken:accessToken}}addAuthTokenListener(listener){this.assertAuthConfigured();if(this.internalListeners.has(listener)){return}const unsubscribe=this.auth.onIdTokenChanged((user=>{listener((user===null||user===void 0?void 0:user.stsTokenManager.accessToken)||null)}));this.internalListeners.set(listener,unsubscribe);this.updateProactiveRefresh()}removeAuthTokenListener(listener){this.assertAuthConfigured();const unsubscribe=this.internalListeners.get(listener);if(!unsubscribe){return}this.internalListeners.delete(listener);unsubscribe();this.updateProactiveRefresh()}assertAuthConfigured(){_assert(this.auth._initializationPromise,"dependent-sdk-initialized-before-auth")}updateProactiveRefresh(){if(this.internalListeners.size>0){this.auth._startProactiveRefresh()}else{this.auth._stopProactiveRefresh()}}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function getVersionForPlatform(clientPlatform){switch(clientPlatform){case"Node":return"node";case"ReactNative":return"rn";case"Worker":return"webworker";case"Cordova":return"cordova";case"WebExtension":return"web-extension";default:return undefined}}function registerAuth(clientPlatform){(0,_app._registerComponent)(new _component.Component("auth",((container,{options:deps})=>{const app=container.getProvider("app").getImmediate();const heartbeatServiceProvider=container.getProvider("heartbeat");const appCheckServiceProvider=container.getProvider("app-check-internal");const{apiKey:apiKey,authDomain:authDomain}=app.options;_assert(apiKey&&!apiKey.includes(":"),"invalid-api-key",{appName:app.name});const config={apiKey:apiKey,authDomain:authDomain,clientPlatform:clientPlatform,apiHost:"identitytoolkit.googleapis.com",tokenApiHost:"securetoken.googleapis.com",apiScheme:"https",sdkClientVersion:_getClientVersion(clientPlatform)};const authInstance=new AuthImpl(app,heartbeatServiceProvider,appCheckServiceProvider,config);_initializeAuthInstance(authInstance,deps);return authInstance}),"PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback(((container,_instanceIdentifier,_instance)=>{const authInternalProvider=container.getProvider("auth-internal");authInternalProvider.initialize()})));(0,_app._registerComponent)(new _component.Component("auth-internal",(container=>{const auth=_castAuth(container.getProvider("auth").getImmediate());return(auth=>new AuthInterop(auth))(auth)}),"PRIVATE").setInstantiationMode("EXPLICIT"));(0,_app.registerVersion)(name,version,getVersionForPlatform(clientPlatform));(0,_app.registerVersion)(name,version,"esm2017")}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const DEFAULT_ID_TOKEN_MAX_AGE=5*60;const authIdTokenMaxAge=(0,_util.getExperimentalSetting)("authIdTokenMaxAge")||DEFAULT_ID_TOKEN_MAX_AGE;let lastPostedIdToken=null;const mintCookieFactory=url=>async user=>{const idTokenResult=user&&await user.getIdTokenResult();const idTokenAge=idTokenResult&&((new Date).getTime()-Date.parse(idTokenResult.issuedAtTime))/1e3;if(idTokenAge&&idTokenAge>authIdTokenMaxAge){return}const idToken=idTokenResult===null||idTokenResult===void 0?void 0:idTokenResult.token;if(lastPostedIdToken===idToken){return}lastPostedIdToken=idToken;await fetch(url,{method:idToken?"POST":"DELETE",headers:idToken?{Authorization:`Bearer ${idToken}`}:{}})};function getAuth(app=(0,_app.getApp)()){const provider=(0,_app._getProvider)(app,"auth");if(provider.isInitialized()){return provider.getImmediate()}const auth=initializeAuth(app,{popupRedirectResolver:browserPopupRedirectResolver,persistence:[indexedDBLocalPersistence,browserLocalPersistence,browserSessionPersistence]});const authTokenSyncPath=(0,_util.getExperimentalSetting)("authTokenSyncURL");if(authTokenSyncPath&&typeof isSecureContext==="boolean"&&isSecureContext){const authTokenSyncUrl=new URL(authTokenSyncPath,location.origin);if(location.origin===authTokenSyncUrl.origin){const mintCookie=mintCookieFactory(authTokenSyncUrl.toString());beforeAuthStateChanged(auth,mintCookie,(()=>mintCookie(auth.currentUser)));onIdTokenChanged(auth,(user=>mintCookie(user)))}}const authEmulatorHost=(0,_util.getDefaultEmulatorHost)("auth");if(authEmulatorHost){connectAuthEmulator(auth,`http://${authEmulatorHost}`)}return auth}function getScriptParentElement(){var _a,_b;return(_b=(_a=document.getElementsByTagName("head"))===null||_a===void 0?void 0:_a[0])!==null&&_b!==void 0?_b:document}_setExternalJSProvider({loadJS(url){return new Promise(((resolve,reject)=>{const el=document.createElement("script");el.setAttribute("src",url);el.onload=resolve;el.onerror=e=>{const error=_createError("internal-error");error.customData=e;reject(error)};el.type="text/javascript";el.charset="UTF-8";getScriptParentElement().appendChild(el)}))},gapiScript:"https://apis.google.com/js/api.js",recaptchaV2Script:"https://www.google.com/recaptcha/api.js",recaptchaEnterpriseScript:"https://www.google.com/recaptcha/enterprise.js?render="});registerAuth("Browser")},{"@firebase/app":4,"@firebase/component":8,"@firebase/logger":11,"@firebase/util":12,tslib:18}],7:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});Object.defineProperty(exports,"ActionCodeOperation",{enumerable:true,get:function(){return _indexFbeda.A}});Object.defineProperty(exports,"ActionCodeURL",{enumerable:true,get:function(){return _indexFbeda.ai}});Object.defineProperty(exports,"AuthCredential",{enumerable:true,get:function(){return _indexFbeda.L}});Object.defineProperty(exports,"AuthErrorCodes",{enumerable:true,get:function(){return _indexFbeda.I}});Object.defineProperty(exports,"AuthImpl",{enumerable:true,get:function(){return _indexFbeda.aL}});Object.defineProperty(exports,"AuthPopup",{enumerable:true,get:function(){return _indexFbeda.aO}});Object.defineProperty(exports,"EmailAuthCredential",{enumerable:true,get:function(){return _indexFbeda.M}});Object.defineProperty(exports,"EmailAuthProvider",{enumerable:true,get:function(){return _indexFbeda.V}});Object.defineProperty(exports,"FacebookAuthProvider",{enumerable:true,get:function(){return _indexFbeda.W}});Object.defineProperty(exports,"FactorId",{enumerable:true,get:function(){return _indexFbeda.F}});Object.defineProperty(exports,"FetchProvider",{enumerable:true,get:function(){return _indexFbeda.aP}});Object.defineProperty(exports,"GithubAuthProvider",{enumerable:true,get:function(){return _indexFbeda.Y}});Object.defineProperty(exports,"GoogleAuthProvider",{enumerable:true,get:function(){return _indexFbeda.X}});Object.defineProperty(exports,"OAuthCredential",{enumerable:true,get:function(){return _indexFbeda.N}});Object.defineProperty(exports,"OAuthProvider",{enumerable:true,get:function(){return _indexFbeda.Z}});Object.defineProperty(exports,"OperationType",{enumerable:true,get:function(){return _indexFbeda.O}});Object.defineProperty(exports,"PhoneAuthCredential",{enumerable:true,get:function(){return _indexFbeda.Q}});Object.defineProperty(exports,"PhoneAuthProvider",{enumerable:true,get:function(){return _indexFbeda.P}});Object.defineProperty(exports,"PhoneMultiFactorGenerator",{enumerable:true,get:function(){return _indexFbeda.m}});Object.defineProperty(exports,"ProviderId",{enumerable:true,get:function(){return _indexFbeda.p}});Object.defineProperty(exports,"RecaptchaVerifier",{enumerable:true,get:function(){return _indexFbeda.R}});Object.defineProperty(exports,"SAMLAuthCredential",{enumerable:true,get:function(){return _indexFbeda.aQ}});Object.defineProperty(exports,"SAMLAuthProvider",{enumerable:true,get:function(){return _indexFbeda._}});Object.defineProperty(exports,"SignInMethod",{enumerable:true,get:function(){return _indexFbeda.S}});Object.defineProperty(exports,"TotpMultiFactorGenerator",{enumerable:true,get:function(){return _indexFbeda.T}});Object.defineProperty(exports,"TotpSecret",{enumerable:true,get:function(){return _indexFbeda.n}});Object.defineProperty(exports,"TwitterAuthProvider",{enumerable:true,get:function(){return _indexFbeda.$}});Object.defineProperty(exports,"UserImpl",{enumerable:true,get:function(){return _indexFbeda.aK}});Object.defineProperty(exports,"_assert",{enumerable:true,get:function(){return _indexFbeda.aC}});Object.defineProperty(exports,"_castAuth",{enumerable:true,get:function(){return _indexFbeda.aJ}});Object.defineProperty(exports,"_fail",{enumerable:true,get:function(){return _indexFbeda.ax}});Object.defineProperty(exports,"_generateEventId",{enumerable:true,get:function(){return _indexFbeda.aN}});Object.defineProperty(exports,"_getClientVersion",{enumerable:true,get:function(){return _indexFbeda.aM}});Object.defineProperty(exports,"_getInstance",{enumerable:true,get:function(){return _indexFbeda.aE}});Object.defineProperty(exports,"_getRedirectResult",{enumerable:true,get:function(){return _indexFbeda.aG}});Object.defineProperty(exports,"_overrideRedirectResult",{enumerable:true,get:function(){return _indexFbeda.aH}});Object.defineProperty(exports,"_persistenceKeyName",{enumerable:true,get:function(){return _indexFbeda.aF}});exports.addFrameworkForLogging=addFrameworkForLogging;Object.defineProperty(exports,"applyActionCode",{enumerable:true,get:function(){return _indexFbeda.a7}});Object.defineProperty(exports,"beforeAuthStateChanged",{enumerable:true,get:function(){return _indexFbeda.x}});Object.defineProperty(exports,"browserLocalPersistence",{enumerable:true,get:function(){return _indexFbeda.b}});Object.defineProperty(exports,"browserPopupRedirectResolver",{enumerable:true,get:function(){return _indexFbeda.k}});Object.defineProperty(exports,"browserSessionPersistence",{enumerable:true,get:function(){return _indexFbeda.a}});Object.defineProperty(exports,"checkActionCode",{enumerable:true,get:function(){return _indexFbeda.a8}});Object.defineProperty(exports,"confirmPasswordReset",{enumerable:true,get:function(){return _indexFbeda.a6}});Object.defineProperty(exports,"connectAuthEmulator",{enumerable:true,get:function(){return _indexFbeda.K}});exports.cordovaPopupRedirectResolver=void 0;Object.defineProperty(exports,"createUserWithEmailAndPassword",{enumerable:true,get:function(){return _indexFbeda.aa}});Object.defineProperty(exports,"debugErrorMap",{enumerable:true,get:function(){return _indexFbeda.G}});Object.defineProperty(exports,"deleteUser",{enumerable:true,get:function(){return _indexFbeda.E}});Object.defineProperty(exports,"fetchSignInMethodsForEmail",{enumerable:true,get:function(){return _indexFbeda.af}});Object.defineProperty(exports,"getAdditionalUserInfo",{enumerable:true,get:function(){return _indexFbeda.aq}});Object.defineProperty(exports,"getAuth",{enumerable:true,get:function(){return _indexFbeda.o}});Object.defineProperty(exports,"getIdToken",{enumerable:true,get:function(){return _indexFbeda.an}});Object.defineProperty(exports,"getIdTokenResult",{enumerable:true,get:function(){return _indexFbeda.ao}});Object.defineProperty(exports,"getMultiFactorResolver",{enumerable:true,get:function(){return _indexFbeda.as}});Object.defineProperty(exports,"getRedirectResult",{enumerable:true,get:function(){return _indexFbeda.j}});Object.defineProperty(exports,"inMemoryPersistence",{enumerable:true,get:function(){return _indexFbeda.U}});Object.defineProperty(exports,"indexedDBLocalPersistence",{enumerable:true,get:function(){return _indexFbeda.i}});Object.defineProperty(exports,"initializeAuth",{enumerable:true,get:function(){return _indexFbeda.J}});Object.defineProperty(exports,"initializeRecaptchaConfig",{enumerable:true,get:function(){return _indexFbeda.t}});Object.defineProperty(exports,"isSignInWithEmailLink",{enumerable:true,get:function(){return _indexFbeda.ad}});Object.defineProperty(exports,"linkWithCredential",{enumerable:true,get:function(){return _indexFbeda.a2}});Object.defineProperty(exports,"linkWithPhoneNumber",{enumerable:true,get:function(){return _indexFbeda.l}});Object.defineProperty(exports,"linkWithPopup",{enumerable:true,get:function(){return _indexFbeda.d}});Object.defineProperty(exports,"linkWithRedirect",{enumerable:true,get:function(){return _indexFbeda.g}});Object.defineProperty(exports,"multiFactor",{enumerable:true,get:function(){return _indexFbeda.at}});Object.defineProperty(exports,"onAuthStateChanged",{enumerable:true,get:function(){return _indexFbeda.y}});Object.defineProperty(exports,"onIdTokenChanged",{enumerable:true,get:function(){return _indexFbeda.w}});Object.defineProperty(exports,"parseActionCodeURL",{enumerable:true,get:function(){return _indexFbeda.aj}});Object.defineProperty(exports,"prodErrorMap",{enumerable:true,get:function(){return _indexFbeda.H}});Object.defineProperty(exports,"reauthenticateWithCredential",{enumerable:true,get:function(){return _indexFbeda.a3}});Object.defineProperty(exports,"reauthenticateWithPhoneNumber",{enumerable:true,get:function(){return _indexFbeda.r}});Object.defineProperty(exports,"reauthenticateWithPopup",{enumerable:true,get:function(){return _indexFbeda.e}});Object.defineProperty(exports,"reauthenticateWithRedirect",{enumerable:true,get:function(){return _indexFbeda.h}});Object.defineProperty(exports,"reload",{enumerable:true,get:function(){return _indexFbeda.ar}});Object.defineProperty(exports,"revokeAccessToken",{enumerable:true,get:function(){return _indexFbeda.D}});Object.defineProperty(exports,"sendEmailVerification",{enumerable:true,get:function(){return _indexFbeda.ag}});Object.defineProperty(exports,"sendPasswordResetEmail",{enumerable:true,get:function(){return _indexFbeda.a5}});Object.defineProperty(exports,"sendSignInLinkToEmail",{enumerable:true,get:function(){return _indexFbeda.ac}});Object.defineProperty(exports,"setPersistence",{enumerable:true,get:function(){return _indexFbeda.q}});Object.defineProperty(exports,"signInAnonymously",{enumerable:true,get:function(){return _indexFbeda.a0}});Object.defineProperty(exports,"signInWithCredential",{enumerable:true,get:function(){return _indexFbeda.a1}});Object.defineProperty(exports,"signInWithCustomToken",{enumerable:true,get:function(){return _indexFbeda.a4}});Object.defineProperty(exports,"signInWithEmailAndPassword",{enumerable:true,get:function(){return _indexFbeda.ab}});Object.defineProperty(exports,"signInWithEmailLink",{enumerable:true,get:function(){return _indexFbeda.ae}});Object.defineProperty(exports,"signInWithPhoneNumber",{enumerable:true,get:function(){return _indexFbeda.s}});Object.defineProperty(exports,"signInWithPopup",{enumerable:true,get:function(){return _indexFbeda.c}});Object.defineProperty(exports,"signInWithRedirect",{enumerable:true,get:function(){return _indexFbeda.f}});Object.defineProperty(exports,"signOut",{enumerable:true,get:function(){return _indexFbeda.C}});Object.defineProperty(exports,"unlink",{enumerable:true,get:function(){return _indexFbeda.ap}});Object.defineProperty(exports,"updateCurrentUser",{enumerable:true,get:function(){return _indexFbeda.B}});Object.defineProperty(exports,"updateEmail",{enumerable:true,get:function(){return _indexFbeda.al}});Object.defineProperty(exports,"updatePassword",{enumerable:true,get:function(){return _indexFbeda.am}});Object.defineProperty(exports,"updatePhoneNumber",{enumerable:true,get:function(){return _indexFbeda.u}});Object.defineProperty(exports,"updateProfile",{enumerable:true,get:function(){return _indexFbeda.ak}});Object.defineProperty(exports,"useDeviceLanguage",{enumerable:true,get:function(){return _indexFbeda.z}});Object.defineProperty(exports,"validatePassword",{enumerable:true,get:function(){return _indexFbeda.v}});Object.defineProperty(exports,"verifyBeforeUpdateEmail",{enumerable:true,get:function(){return _indexFbeda.ah}});Object.defineProperty(exports,"verifyPasswordResetCode",{enumerable:true,get:function(){return _indexFbeda.a9}});var _indexFbeda=require("./index-fbeda258.js");var _util=require("@firebase/util");require("@firebase/app");require("@firebase/logger");require("tslib");require("@firebase/component");
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _cordovaWindow(){return window}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const REDIRECT_TIMEOUT_MS=2e3;async function _generateHandlerUrl(auth,event,provider){var _a;const{BuildInfo:BuildInfo}=_cordovaWindow();(0,_indexFbeda.au)(event.sessionId,"AuthEvent did not contain a session ID");const sessionDigest=await computeSha256(event.sessionId);const additionalParams={};if((0,_indexFbeda.av)()){additionalParams["ibi"]=BuildInfo.packageName}else if((0,_indexFbeda.aw)()){additionalParams["apn"]=BuildInfo.packageName}else{(0,_indexFbeda.ax)(auth,"operation-not-supported-in-this-environment")}if(BuildInfo.displayName){additionalParams["appDisplayName"]=BuildInfo.displayName}additionalParams["sessionId"]=sessionDigest;return(0,_indexFbeda.ay)(auth,provider,event.type,undefined,(_a=event.eventId)!==null&&_a!==void 0?_a:undefined,additionalParams)}async function _validateOrigin(auth){const{BuildInfo:BuildInfo}=_cordovaWindow();const request={};if((0,_indexFbeda.av)()){request.iosBundleId=BuildInfo.packageName}else if((0,_indexFbeda.aw)()){request.androidPackageName=BuildInfo.packageName}else{(0,_indexFbeda.ax)(auth,"operation-not-supported-in-this-environment")}await(0,_indexFbeda.az)(auth,request)}function _performRedirect(handlerUrl){const{cordova:cordova}=_cordovaWindow();return new Promise((resolve=>{cordova.plugins.browsertab.isAvailable((browserTabIsAvailable=>{let iabRef=null;if(browserTabIsAvailable){cordova.plugins.browsertab.openUrl(handlerUrl)}else{iabRef=cordova.InAppBrowser.open(handlerUrl,(0,_indexFbeda.aA)()?"_blank":"_system","location=yes")}resolve(iabRef)}))}))}async function _waitForAppResume(auth,eventListener,iabRef){const{cordova:cordova}=_cordovaWindow();let cleanup=()=>{};try{await new Promise(((resolve,reject)=>{let onCloseTimer=null;function authEventSeen(){var _a;resolve();const closeBrowserTab=(_a=cordova.plugins.browsertab)===null||_a===void 0?void 0:_a.close;if(typeof closeBrowserTab==="function"){closeBrowserTab()}if(typeof(iabRef===null||iabRef===void 0?void 0:iabRef.close)==="function"){iabRef.close()}}function resumed(){if(onCloseTimer){return}onCloseTimer=window.setTimeout((()=>{reject((0,_indexFbeda.aB)(auth,"redirect-cancelled-by-user"))}),REDIRECT_TIMEOUT_MS)}function visibilityChanged(){if((document===null||document===void 0?void 0:document.visibilityState)==="visible"){resumed()}}eventListener.addPassiveListener(authEventSeen);document.addEventListener("resume",resumed,false);if((0,_indexFbeda.aw)()){document.addEventListener("visibilitychange",visibilityChanged,false)}cleanup=()=>{eventListener.removePassiveListener(authEventSeen);document.removeEventListener("resume",resumed,false);document.removeEventListener("visibilitychange",visibilityChanged,false);if(onCloseTimer){window.clearTimeout(onCloseTimer)}}}))}finally{cleanup()}}function _checkCordovaConfiguration(auth){var _a,_b,_c,_d,_e,_f,_g,_h,_j,_k;const win=_cordovaWindow();(0,_indexFbeda.aC)(typeof((_a=win===null||win===void 0?void 0:win.universalLinks)===null||_a===void 0?void 0:_a.subscribe)==="function",auth,"invalid-cordova-configuration",{missingPlugin:"cordova-universal-links-plugin-fix"});(0,_indexFbeda.aC)(typeof((_b=win===null||win===void 0?void 0:win.BuildInfo)===null||_b===void 0?void 0:_b.packageName)!=="undefined",auth,"invalid-cordova-configuration",{missingPlugin:"cordova-plugin-buildInfo"});(0,_indexFbeda.aC)(typeof((_e=(_d=(_c=win===null||win===void 0?void 0:win.cordova)===null||_c===void 0?void 0:_c.plugins)===null||_d===void 0?void 0:_d.browsertab)===null||_e===void 0?void 0:_e.openUrl)==="function",auth,"invalid-cordova-configuration",{missingPlugin:"cordova-plugin-browsertab"});(0,_indexFbeda.aC)(typeof((_h=(_g=(_f=win===null||win===void 0?void 0:win.cordova)===null||_f===void 0?void 0:_f.plugins)===null||_g===void 0?void 0:_g.browsertab)===null||_h===void 0?void 0:_h.isAvailable)==="function",auth,"invalid-cordova-configuration",{missingPlugin:"cordova-plugin-browsertab"});(0,_indexFbeda.aC)(typeof((_k=(_j=win===null||win===void 0?void 0:win.cordova)===null||_j===void 0?void 0:_j.InAppBrowser)===null||_k===void 0?void 0:_k.open)==="function",auth,"invalid-cordova-configuration",{missingPlugin:"cordova-plugin-inappbrowser"})}async function computeSha256(sessionId){const bytes=stringToArrayBuffer(sessionId);const buf=await crypto.subtle.digest("SHA-256",bytes);const arr=Array.from(new Uint8Array(buf));return arr.map((num=>num.toString(16).padStart(2,"0"))).join("")}function stringToArrayBuffer(str){(0,_indexFbeda.au)(/[0-9a-zA-Z]+/.test(str),"Can only convert alpha-numeric strings");if(typeof TextEncoder!=="undefined"){return(new TextEncoder).encode(str)}const buff=new ArrayBuffer(str.length);const view=new Uint8Array(buff);for(let i=0;i<str.length;i++){view[i]=str.charCodeAt(i)}return view}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const SESSION_ID_LENGTH=20;class CordovaAuthEventManager extends _indexFbeda.aD{constructor(){super(...arguments);this.passiveListeners=new Set;this.initPromise=new Promise((resolve=>{this.resolveInialized=resolve}))}addPassiveListener(cb){this.passiveListeners.add(cb)}removePassiveListener(cb){this.passiveListeners.delete(cb)}resetRedirect(){this.queuedRedirectEvent=null;this.hasHandledPotentialRedirect=false}onEvent(event){this.resolveInialized();this.passiveListeners.forEach((cb=>cb(event)));return super.onEvent(event)}async initialized(){await this.initPromise}}function _generateNewEvent(auth,type,eventId=null){return{type:type,eventId:eventId,urlResponse:null,sessionId:generateSessionId(),postBody:null,tenantId:auth.tenantId,error:(0,_indexFbeda.aB)(auth,"no-auth-event")}}function _savePartialEvent(auth,event){return storage()._set(persistenceKey(auth),event)}async function _getAndRemoveEvent(auth){const event=await storage()._get(persistenceKey(auth));if(event){await storage()._remove(persistenceKey(auth))}return event}function _eventFromPartialAndUrl(partialEvent,url){var _a,_b;const callbackUrl=_getDeepLinkFromCallback(url);if(callbackUrl.includes("/__/auth/callback")){const params=searchParamsOrEmpty(callbackUrl);const errorObject=params["firebaseError"]?parseJsonOrNull(decodeURIComponent(params["firebaseError"])):null;const code=(_b=(_a=errorObject===null||errorObject===void 0?void 0:errorObject["code"])===null||_a===void 0?void 0:_a.split("auth/"))===null||_b===void 0?void 0:_b[1];const error=code?(0,_indexFbeda.aB)(code):null;if(error){return{type:partialEvent.type,eventId:partialEvent.eventId,tenantId:partialEvent.tenantId,error:error,urlResponse:null,sessionId:null,postBody:null}}else{return{type:partialEvent.type,eventId:partialEvent.eventId,tenantId:partialEvent.tenantId,sessionId:partialEvent.sessionId,urlResponse:callbackUrl,postBody:null}}}return null}function generateSessionId(){const chars=[];const allowedChars="1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";for(let i=0;i<SESSION_ID_LENGTH;i++){const idx=Math.floor(Math.random()*allowedChars.length);chars.push(allowedChars.charAt(idx))}return chars.join("")}function storage(){return(0,_indexFbeda.aE)(_indexFbeda.b)}function persistenceKey(auth){return(0,_indexFbeda.aF)("authEvent",auth.config.apiKey,auth.name)}function parseJsonOrNull(json){try{return JSON.parse(json)}catch(e){return null}}function _getDeepLinkFromCallback(url){const params=searchParamsOrEmpty(url);const link=params["link"]?decodeURIComponent(params["link"]):undefined;const doubleDeepLink=searchParamsOrEmpty(link)["link"];const iOSDeepLink=params["deep_link_id"]?decodeURIComponent(params["deep_link_id"]):undefined;const iOSDoubleDeepLink=searchParamsOrEmpty(iOSDeepLink)["link"];return iOSDoubleDeepLink||iOSDeepLink||doubleDeepLink||link||url}function searchParamsOrEmpty(url){if(!(url===null||url===void 0?void 0:url.includes("?"))){return{}}const[_,...rest]=url.split("?");return(0,_util.querystringDecode)(rest.join("?"))}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const INITIAL_EVENT_TIMEOUT_MS=500;class CordovaPopupRedirectResolver{constructor(){this._redirectPersistence=_indexFbeda.a;this._shouldInitProactively=true;this.eventManagers=new Map;this.originValidationPromises={};this._completeRedirectFn=_indexFbeda.aG;this._overrideRedirectResult=_indexFbeda.aH}async _initialize(auth){const key=auth._key();let manager=this.eventManagers.get(key);if(!manager){manager=new CordovaAuthEventManager(auth);this.eventManagers.set(key,manager);this.attachCallbackListeners(auth,manager)}return manager}_openPopup(auth){(0,_indexFbeda.ax)(auth,"operation-not-supported-in-this-environment")}async _openRedirect(auth,provider,authType,eventId){_checkCordovaConfiguration(auth);const manager=await this._initialize(auth);await manager.initialized();manager.resetRedirect();(0,_indexFbeda.aI)();await this._originValidation(auth);const event=_generateNewEvent(auth,authType,eventId);await _savePartialEvent(auth,event);const url=await _generateHandlerUrl(auth,event,provider);const iabRef=await _performRedirect(url);return _waitForAppResume(auth,manager,iabRef)}_isIframeWebStorageSupported(_auth,_cb){throw new Error("Method not implemented.")}_originValidation(auth){const key=auth._key();if(!this.originValidationPromises[key]){this.originValidationPromises[key]=_validateOrigin(auth)}return this.originValidationPromises[key]}attachCallbackListeners(auth,manager){const{universalLinks:universalLinks,handleOpenURL:handleOpenURL,BuildInfo:BuildInfo}=_cordovaWindow();const noEventTimeout=setTimeout((async()=>{await _getAndRemoveEvent(auth);manager.onEvent(generateNoEvent())}),INITIAL_EVENT_TIMEOUT_MS);const universalLinksCb=async eventData=>{clearTimeout(noEventTimeout);const partialEvent=await _getAndRemoveEvent(auth);let finalEvent=null;if(partialEvent&&(eventData===null||eventData===void 0?void 0:eventData["url"])){finalEvent=_eventFromPartialAndUrl(partialEvent,eventData["url"])}manager.onEvent(finalEvent||generateNoEvent())};if(typeof universalLinks!=="undefined"&&typeof universalLinks.subscribe==="function"){universalLinks.subscribe(null,universalLinksCb)}const existingHandleOpenURL=handleOpenURL;const packagePrefix=`${BuildInfo.packageName.toLowerCase()}://`;_cordovaWindow().handleOpenURL=async url=>{if(url.toLowerCase().startsWith(packagePrefix)){universalLinksCb({url:url})}if(typeof existingHandleOpenURL==="function"){try{existingHandleOpenURL(url)}catch(e){console.error(e)}}}}}const cordovaPopupRedirectResolver=CordovaPopupRedirectResolver;exports.cordovaPopupRedirectResolver=cordovaPopupRedirectResolver;function generateNoEvent(){return{type:"unknown",eventId:null,sessionId:null,urlResponse:null,postBody:null,tenantId:null,error:(0,_indexFbeda.aB)("no-auth-event")}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function addFrameworkForLogging(auth,framework){(0,_indexFbeda.aJ)(auth)._logFramework(framework)}},{"./index-fbeda258.js":6,"@firebase/app":4,"@firebase/component":8,"@firebase/logger":11,"@firebase/util":12,tslib:18}],8:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Provider=exports.ComponentContainer=exports.Component=void 0;var _util=require("@firebase/util");class Component{constructor(name,instanceFactory,type){this.name=name;this.instanceFactory=instanceFactory;this.type=type;this.multipleInstances=false;this.serviceProps={};this.instantiationMode="LAZY";this.onInstanceCreated=null}setInstantiationMode(mode){this.instantiationMode=mode;return this}setMultipleInstances(multipleInstances){this.multipleInstances=multipleInstances;return this}setServiceProps(props){this.serviceProps=props;return this}setInstanceCreatedCallback(callback){this.onInstanceCreated=callback;return this}}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.Component=Component;const DEFAULT_ENTRY_NAME="[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Provider{constructor(name,container){this.name=name;this.container=container;this.component=null;this.instances=new Map;this.instancesDeferred=new Map;this.instancesOptions=new Map;this.onInitCallbacks=new Map}get(identifier){const normalizedIdentifier=this.normalizeInstanceIdentifier(identifier);if(!this.instancesDeferred.has(normalizedIdentifier)){const deferred=new _util.Deferred;this.instancesDeferred.set(normalizedIdentifier,deferred);if(this.isInitialized(normalizedIdentifier)||this.shouldAutoInitialize()){try{const instance=this.getOrInitializeService({instanceIdentifier:normalizedIdentifier});if(instance){deferred.resolve(instance)}}catch(e){}}}return this.instancesDeferred.get(normalizedIdentifier).promise}getImmediate(options){var _a;const normalizedIdentifier=this.normalizeInstanceIdentifier(options===null||options===void 0?void 0:options.identifier);const optional=(_a=options===null||options===void 0?void 0:options.optional)!==null&&_a!==void 0?_a:false;if(this.isInitialized(normalizedIdentifier)||this.shouldAutoInitialize()){try{return this.getOrInitializeService({instanceIdentifier:normalizedIdentifier})}catch(e){if(optional){return null}else{throw e}}}else{if(optional){return null}else{throw Error(`Service ${this.name} is not available`)}}}getComponent(){return this.component}setComponent(component){if(component.name!==this.name){throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`)}if(this.component){throw Error(`Component for ${this.name} has already been provided`)}this.component=component;if(!this.shouldAutoInitialize()){return}if(isComponentEager(component)){try{this.getOrInitializeService({instanceIdentifier:DEFAULT_ENTRY_NAME})}catch(e){}}for(const[instanceIdentifier,instanceDeferred]of this.instancesDeferred.entries()){const normalizedIdentifier=this.normalizeInstanceIdentifier(instanceIdentifier);try{const instance=this.getOrInitializeService({instanceIdentifier:normalizedIdentifier});instanceDeferred.resolve(instance)}catch(e){}}}clearInstance(identifier=DEFAULT_ENTRY_NAME){this.instancesDeferred.delete(identifier);this.instancesOptions.delete(identifier);this.instances.delete(identifier)}async delete(){const services=Array.from(this.instances.values());await Promise.all([...services.filter((service=>"INTERNAL"in service)).map((service=>service.INTERNAL.delete())),...services.filter((service=>"_delete"in service)).map((service=>service._delete()))])}isComponentSet(){return this.component!=null}isInitialized(identifier=DEFAULT_ENTRY_NAME){return this.instances.has(identifier)}getOptions(identifier=DEFAULT_ENTRY_NAME){return this.instancesOptions.get(identifier)||{}}initialize(opts={}){const{options:options={}}=opts;const normalizedIdentifier=this.normalizeInstanceIdentifier(opts.instanceIdentifier);if(this.isInitialized(normalizedIdentifier)){throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`)}if(!this.isComponentSet()){throw Error(`Component ${this.name} has not been registered yet`)}const instance=this.getOrInitializeService({instanceIdentifier:normalizedIdentifier,options:options});for(const[instanceIdentifier,instanceDeferred]of this.instancesDeferred.entries()){const normalizedDeferredIdentifier=this.normalizeInstanceIdentifier(instanceIdentifier);if(normalizedIdentifier===normalizedDeferredIdentifier){instanceDeferred.resolve(instance)}}return instance}onInit(callback,identifier){var _a;const normalizedIdentifier=this.normalizeInstanceIdentifier(identifier);const existingCallbacks=(_a=this.onInitCallbacks.get(normalizedIdentifier))!==null&&_a!==void 0?_a:new Set;existingCallbacks.add(callback);this.onInitCallbacks.set(normalizedIdentifier,existingCallbacks);const existingInstance=this.instances.get(normalizedIdentifier);if(existingInstance){callback(existingInstance,normalizedIdentifier)}return()=>{existingCallbacks.delete(callback)}}invokeOnInitCallbacks(instance,identifier){const callbacks=this.onInitCallbacks.get(identifier);if(!callbacks){return}for(const callback of callbacks){try{callback(instance,identifier)}catch(_a){}}}getOrInitializeService({instanceIdentifier:instanceIdentifier,options:options={}}){let instance=this.instances.get(instanceIdentifier);if(!instance&&this.component){instance=this.component.instanceFactory(this.container,{instanceIdentifier:normalizeIdentifierForFactory(instanceIdentifier),options:options});this.instances.set(instanceIdentifier,instance);this.instancesOptions.set(instanceIdentifier,options);this.invokeOnInitCallbacks(instance,instanceIdentifier);if(this.component.onInstanceCreated){try{this.component.onInstanceCreated(this.container,instanceIdentifier,instance)}catch(_a){}}}return instance||null}normalizeInstanceIdentifier(identifier=DEFAULT_ENTRY_NAME){if(this.component){return this.component.multipleInstances?identifier:DEFAULT_ENTRY_NAME}else{return identifier}}shouldAutoInitialize(){return!!this.component&&this.component.instantiationMode!=="EXPLICIT"}}exports.Provider=Provider;function normalizeIdentifierForFactory(identifier){return identifier===DEFAULT_ENTRY_NAME?undefined:identifier}function isComponentEager(component){return component.instantiationMode==="EAGER"}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ComponentContainer{constructor(name){this.name=name;this.providers=new Map}addComponent(component){const provider=this.getProvider(component.name);if(provider.isComponentSet()){throw new Error(`Component ${component.name} has already been registered with ${this.name}`)}provider.setComponent(component)}addOrOverwriteComponent(component){const provider=this.getProvider(component.name);if(provider.isComponentSet()){this.providers.delete(component.name)}this.addComponent(component)}getProvider(name){if(this.providers.has(name)){return this.providers.get(name)}const provider=new Provider(name,this);this.providers.set(name,provider);return provider}getProviders(){return Array.from(this.providers.values())}}exports.ComponentContainer=ComponentContainer},{"@firebase/util":12}],9:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.registerDatabase=registerDatabase;var _appCompat=_interopRequireDefault(require("@firebase/app-compat"));var _component=require("@firebase/component");var _database2=require("@firebase/database");var _util=require("@firebase/util");var _logger=require("@firebase/logger");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}const name="@firebase/database-compat";const version="1.0.4";
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const logClient=new _logger.Logger("@firebase/database-compat");const warn=function(msg){const message="FIREBASE WARNING: "+msg;logClient.warn(message)};
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const validateBoolean=function(fnName,argumentName,bool,optional){if(optional&&bool===undefined){return}if(typeof bool!=="boolean"){throw new Error((0,_util.errorPrefix)(fnName,argumentName)+"must be a boolean.")}};const validateEventType=function(fnName,eventType,optional){if(optional&&eventType===undefined){return}switch(eventType){case"value":case"child_added":case"child_removed":case"child_changed":case"child_moved":break;default:throw new Error((0,_util.errorPrefix)(fnName,"eventType")+'must be a valid event type = "value", "child_added", "child_removed", '+'"child_changed", or "child_moved".')}};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class OnDisconnect{constructor(_delegate){this._delegate=_delegate}cancel(onComplete){(0,_util.validateArgCount)("OnDisconnect.cancel",0,1,arguments.length);(0,_util.validateCallback)("OnDisconnect.cancel","onComplete",onComplete,true);const result=this._delegate.cancel();if(onComplete){result.then((()=>onComplete(null)),(error=>onComplete(error)))}return result}remove(onComplete){(0,_util.validateArgCount)("OnDisconnect.remove",0,1,arguments.length);(0,_util.validateCallback)("OnDisconnect.remove","onComplete",onComplete,true);const result=this._delegate.remove();if(onComplete){result.then((()=>onComplete(null)),(error=>onComplete(error)))}return result}set(value,onComplete){(0,_util.validateArgCount)("OnDisconnect.set",1,2,arguments.length);(0,_util.validateCallback)("OnDisconnect.set","onComplete",onComplete,true);const result=this._delegate.set(value);if(onComplete){result.then((()=>onComplete(null)),(error=>onComplete(error)))}return result}setWithPriority(value,priority,onComplete){(0,_util.validateArgCount)("OnDisconnect.setWithPriority",2,3,arguments.length);(0,_util.validateCallback)("OnDisconnect.setWithPriority","onComplete",onComplete,true);const result=this._delegate.setWithPriority(value,priority);if(onComplete){result.then((()=>onComplete(null)),(error=>onComplete(error)))}return result}update(objectToMerge,onComplete){(0,_util.validateArgCount)("OnDisconnect.update",1,2,arguments.length);if(Array.isArray(objectToMerge)){const newObjectToMerge={};for(let i=0;i<objectToMerge.length;++i){newObjectToMerge[""+i]=objectToMerge[i]}objectToMerge=newObjectToMerge;warn("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the "+"existing data, or an Object with integer keys if you really do want to only update some of the children.")}(0,_util.validateCallback)("OnDisconnect.update","onComplete",onComplete,true);const result=this._delegate.update(objectToMerge);if(onComplete){result.then((()=>onComplete(null)),(error=>onComplete(error)))}return result}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class TransactionResult{constructor(committed,snapshot){this.committed=committed;this.snapshot=snapshot}toJSON(){(0,_util.validateArgCount)("TransactionResult.toJSON",0,1,arguments.length);return{committed:this.committed,snapshot:this.snapshot.toJSON()}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class DataSnapshot{constructor(_database,_delegate){this._database=_database;this._delegate=_delegate}val(){(0,_util.validateArgCount)("DataSnapshot.val",0,0,arguments.length);return this._delegate.val()}exportVal(){(0,_util.validateArgCount)("DataSnapshot.exportVal",0,0,arguments.length);return this._delegate.exportVal()}toJSON(){(0,_util.validateArgCount)("DataSnapshot.toJSON",0,1,arguments.length);return this._delegate.toJSON()}exists(){(0,_util.validateArgCount)("DataSnapshot.exists",0,0,arguments.length);return this._delegate.exists()}child(path){(0,_util.validateArgCount)("DataSnapshot.child",0,1,arguments.length);path=String(path);(0,_database2._validatePathString)("DataSnapshot.child","path",path,false);return new DataSnapshot(this._database,this._delegate.child(path))}hasChild(path){(0,_util.validateArgCount)("DataSnapshot.hasChild",1,1,arguments.length);(0,_database2._validatePathString)("DataSnapshot.hasChild","path",path,false);return this._delegate.hasChild(path)}getPriority(){(0,_util.validateArgCount)("DataSnapshot.getPriority",0,0,arguments.length);return this._delegate.priority}forEach(action){(0,_util.validateArgCount)("DataSnapshot.forEach",1,1,arguments.length);(0,_util.validateCallback)("DataSnapshot.forEach","action",action,false);return this._delegate.forEach((expDataSnapshot=>action(new DataSnapshot(this._database,expDataSnapshot))))}hasChildren(){(0,_util.validateArgCount)("DataSnapshot.hasChildren",0,0,arguments.length);return this._delegate.hasChildren()}get key(){return this._delegate.key}numChildren(){(0,_util.validateArgCount)("DataSnapshot.numChildren",0,0,arguments.length);return this._delegate.size}getRef(){(0,_util.validateArgCount)("DataSnapshot.ref",0,0,arguments.length);return new Reference(this._database,this._delegate.ref)}get ref(){return this.getRef()}}class Query{constructor(database,_delegate){this.database=database;this._delegate=_delegate}on(eventType,callback,cancelCallbackOrContext,context){var _a;(0,_util.validateArgCount)("Query.on",2,4,arguments.length);(0,_util.validateCallback)("Query.on","callback",callback,false);const ret=Query.getCancelAndContextArgs_("Query.on",cancelCallbackOrContext,context);const valueCallback=(expSnapshot,previousChildName)=>{callback.call(ret.context,new DataSnapshot(this.database,expSnapshot),previousChildName)};valueCallback.userCallback=callback;valueCallback.context=ret.context;const cancelCallback=(_a=ret.cancel)===null||_a===void 0?void 0:_a.bind(ret.context);switch(eventType){case"value":(0,_database2.onValue)(this._delegate,valueCallback,cancelCallback);return callback;case"child_added":(0,_database2.onChildAdded)(this._delegate,valueCallback,cancelCallback);return callback;case"child_removed":(0,_database2.onChildRemoved)(this._delegate,valueCallback,cancelCallback);return callback;case"child_changed":(0,_database2.onChildChanged)(this._delegate,valueCallback,cancelCallback);return callback;case"child_moved":(0,_database2.onChildMoved)(this._delegate,valueCallback,cancelCallback);return callback;default:throw new Error((0,_util.errorPrefix)("Query.on","eventType")+'must be a valid event type = "value", "child_added", "child_removed", '+'"child_changed", or "child_moved".')}}off(eventType,callback,context){(0,_util.validateArgCount)("Query.off",0,3,arguments.length);validateEventType("Query.off",eventType,true);(0,_util.validateCallback)("Query.off","callback",callback,true);(0,_util.validateContextObject)("Query.off","context",context,true);if(callback){const valueCallback=()=>{};valueCallback.userCallback=callback;valueCallback.context=context;(0,_database2.off)(this._delegate,eventType,valueCallback)}else{(0,_database2.off)(this._delegate,eventType)}}get(){return(0,_database2.get)(this._delegate).then((expSnapshot=>new DataSnapshot(this.database,expSnapshot)))}once(eventType,callback,failureCallbackOrContext,context){(0,_util.validateArgCount)("Query.once",1,4,arguments.length);(0,_util.validateCallback)("Query.once","callback",callback,true);const ret=Query.getCancelAndContextArgs_("Query.once",failureCallbackOrContext,context);const deferred=new _util.Deferred;const valueCallback=(expSnapshot,previousChildName)=>{const result=new DataSnapshot(this.database,expSnapshot);if(callback){callback.call(ret.context,result,previousChildName)}deferred.resolve(result)};valueCallback.userCallback=callback;valueCallback.context=ret.context;const cancelCallback=error=>{if(ret.cancel){ret.cancel.call(ret.context,error)}deferred.reject(error)};switch(eventType){case"value":(0,_database2.onValue)(this._delegate,valueCallback,cancelCallback,{onlyOnce:true});break;case"child_added":(0,_database2.onChildAdded)(this._delegate,valueCallback,cancelCallback,{onlyOnce:true});break;case"child_removed":(0,_database2.onChildRemoved)(this._delegate,valueCallback,cancelCallback,{onlyOnce:true});break;case"child_changed":(0,_database2.onChildChanged)(this._delegate,valueCallback,cancelCallback,{onlyOnce:true});break;case"child_moved":(0,_database2.onChildMoved)(this._delegate,valueCallback,cancelCallback,{onlyOnce:true});break;default:throw new Error((0,_util.errorPrefix)("Query.once","eventType")+'must be a valid event type = "value", "child_added", "child_removed", '+'"child_changed", or "child_moved".')}return deferred.promise}limitToFirst(limit){(0,_util.validateArgCount)("Query.limitToFirst",1,1,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.limitToFirst)(limit)))}limitToLast(limit){(0,_util.validateArgCount)("Query.limitToLast",1,1,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.limitToLast)(limit)))}orderByChild(path){(0,_util.validateArgCount)("Query.orderByChild",1,1,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.orderByChild)(path)))}orderByKey(){(0,_util.validateArgCount)("Query.orderByKey",0,0,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.orderByKey)()))}orderByPriority(){(0,_util.validateArgCount)("Query.orderByPriority",0,0,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.orderByPriority)()))}orderByValue(){(0,_util.validateArgCount)("Query.orderByValue",0,0,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.orderByValue)()))}startAt(value=null,name){(0,_util.validateArgCount)("Query.startAt",0,2,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.startAt)(value,name)))}startAfter(value=null,name){(0,_util.validateArgCount)("Query.startAfter",0,2,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.startAfter)(value,name)))}endAt(value=null,name){(0,_util.validateArgCount)("Query.endAt",0,2,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.endAt)(value,name)))}endBefore(value=null,name){(0,_util.validateArgCount)("Query.endBefore",0,2,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.endBefore)(value,name)))}equalTo(value,name){(0,_util.validateArgCount)("Query.equalTo",1,2,arguments.length);return new Query(this.database,(0,_database2.query)(this._delegate,(0,_database2.equalTo)(value,name)))}toString(){(0,_util.validateArgCount)("Query.toString",0,0,arguments.length);return this._delegate.toString()}toJSON(){(0,_util.validateArgCount)("Query.toJSON",0,1,arguments.length);return this._delegate.toJSON()}isEqual(other){(0,_util.validateArgCount)("Query.isEqual",1,1,arguments.length);if(!(other instanceof Query)){const error="Query.isEqual failed: First argument must be an instance of firebase.database.Query.";throw new Error(error)}return this._delegate.isEqual(other._delegate)}static getCancelAndContextArgs_(fnName,cancelOrContext,context){const ret={cancel:undefined,context:undefined};if(cancelOrContext&&context){ret.cancel=cancelOrContext;(0,_util.validateCallback)(fnName,"cancel",ret.cancel,true);ret.context=context;(0,_util.validateContextObject)(fnName,"context",ret.context,true)}else if(cancelOrContext){if(typeof cancelOrContext==="object"&&cancelOrContext!==null){ret.context=cancelOrContext}else if(typeof cancelOrContext==="function"){ret.cancel=cancelOrContext}else{throw new Error((0,_util.errorPrefix)(fnName,"cancelOrContext")+" must either be a cancel callback or a context object.")}}return ret}get ref(){return new Reference(this.database,new _database2._ReferenceImpl(this._delegate._repo,this._delegate._path))}}class Reference extends Query{constructor(database,_delegate){super(database,new _database2._QueryImpl(_delegate._repo,_delegate._path,new _database2._QueryParams,false));this.database=database;this._delegate=_delegate}getKey(){(0,_util.validateArgCount)("Reference.key",0,0,arguments.length);return this._delegate.key}child(pathString){(0,_util.validateArgCount)("Reference.child",1,1,arguments.length);if(typeof pathString==="number"){pathString=String(pathString)}return new Reference(this.database,(0,_database2.child)(this._delegate,pathString))}getParent(){(0,_util.validateArgCount)("Reference.parent",0,0,arguments.length);const parent=this._delegate.parent;return parent?new Reference(this.database,parent):null}getRoot(){(0,_util.validateArgCount)("Reference.root",0,0,arguments.length);return new Reference(this.database,this._delegate.root)}set(newVal,onComplete){(0,_util.validateArgCount)("Reference.set",1,2,arguments.length);(0,_util.validateCallback)("Reference.set","onComplete",onComplete,true);const result=(0,_database2.set)(this._delegate,newVal);if(onComplete){result.then((()=>onComplete(null)),(error=>onComplete(error)))}return result}update(values,onComplete){(0,_util.validateArgCount)("Reference.update",1,2,arguments.length);if(Array.isArray(values)){const newObjectToMerge={};for(let i=0;i<values.length;++i){newObjectToMerge[""+i]=values[i]}values=newObjectToMerge;warn("Passing an Array to Firebase.update() is deprecated. "+"Use set() if you want to overwrite the existing data, or "+"an Object with integer keys if you really do want to "+"only update some of the children.")}(0,_database2._validateWritablePath)("Reference.update",this._delegate._path);(0,_util.validateCallback)("Reference.update","onComplete",onComplete,true);const result=(0,_database2.update)(this._delegate,values);if(onComplete){result.then((()=>onComplete(null)),(error=>onComplete(error)))}return result}setWithPriority(newVal,newPriority,onComplete){(0,_util.validateArgCount)("Reference.setWithPriority",2,3,arguments.length);(0,_util.validateCallback)("Reference.setWithPriority","onComplete",onComplete,true);const result=(0,_database2.setWithPriority)(this._delegate,newVal,newPriority);if(onComplete){result.then((()=>onComplete(null)),(error=>onComplete(error)))}return result}remove(onComplete){(0,_util.validateArgCount)("Reference.remove",0,1,arguments.length);(0,_util.validateCallback)("Reference.remove","onComplete",onComplete,true);const result=(0,_database2.remove)(this._delegate);if(onComplete){result.then((()=>onComplete(null)),(error=>onComplete(error)))}return result}transaction(transactionUpdate,onComplete,applyLocally){(0,_util.validateArgCount)("Reference.transaction",1,3,arguments.length);(0,_util.validateCallback)("Reference.transaction","transactionUpdate",transactionUpdate,false);(0,_util.validateCallback)("Reference.transaction","onComplete",onComplete,true);validateBoolean("Reference.transaction","applyLocally",applyLocally,true);const result=(0,_database2.runTransaction)(this._delegate,transactionUpdate,{applyLocally:applyLocally}).then((transactionResult=>new TransactionResult(transactionResult.committed,new DataSnapshot(this.database,transactionResult.snapshot))));if(onComplete){result.then((transactionResult=>onComplete(null,transactionResult.committed,transactionResult.snapshot)),(error=>onComplete(error,false,null)))}return result}setPriority(priority,onComplete){(0,_util.validateArgCount)("Reference.setPriority",1,2,arguments.length);(0,_util.validateCallback)("Reference.setPriority","onComplete",onComplete,true);const result=(0,_database2.setPriority)(this._delegate,priority);if(onComplete){result.then((()=>onComplete(null)),(error=>onComplete(error)))}return result}push(value,onComplete){(0,_util.validateArgCount)("Reference.push",0,2,arguments.length);(0,_util.validateCallback)("Reference.push","onComplete",onComplete,true);const expPromise=(0,_database2.push)(this._delegate,value);const promise=expPromise.then((expRef=>new Reference(this.database,expRef)));if(onComplete){promise.then((()=>onComplete(null)),(error=>onComplete(error)))}const result=new Reference(this.database,expPromise);result.then=promise.then.bind(promise);result.catch=promise.catch.bind(promise,undefined);return result}onDisconnect(){(0,_database2._validateWritablePath)("Reference.onDisconnect",this._delegate._path);return new OnDisconnect(new _database2.OnDisconnect(this._delegate._repo,this._delegate._path))}get key(){return this.getKey()}get parent(){return this.getParent()}get root(){return this.getRoot()}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Database{constructor(_delegate,app){this._delegate=_delegate;this.app=app;this.INTERNAL={delete:()=>this._delegate._delete(),forceWebSockets:_database2.forceWebSockets,forceLongPolling:_database2.forceLongPolling}}useEmulator(host,port,options={}){(0,_database2.connectDatabaseEmulator)(this._delegate,host,port,options)}ref(path){(0,_util.validateArgCount)("database.ref",0,1,arguments.length);if(path instanceof Reference){const childRef=(0,_database2.refFromURL)(this._delegate,path.toString());return new Reference(this,childRef)}else{const childRef=(0,_database2.ref)(this._delegate,path);return new Reference(this,childRef)}}refFromURL(url){const apiName="database.refFromURL";(0,_util.validateArgCount)(apiName,1,1,arguments.length);const childRef=(0,_database2.refFromURL)(this._delegate,url);return new Reference(this,childRef)}goOffline(){(0,_util.validateArgCount)("database.goOffline",0,0,arguments.length);return(0,_database2.goOffline)(this._delegate)}goOnline(){(0,_util.validateArgCount)("database.goOnline",0,0,arguments.length);return(0,_database2.goOnline)(this._delegate)}}Database.ServerValue={TIMESTAMP:(0,_database2.serverTimestamp)(),increment:delta=>(0,_database2.increment)(delta)};function initStandalone({app:app,url:url,version:version,customAuthImpl:customAuthImpl,customAppCheckImpl:customAppCheckImpl,namespace:namespace,nodeAdmin:nodeAdmin=false}){(0,_database2._setSDKVersion)(version);const container=new _component.ComponentContainer("database-standalone");const authProvider=new _component.Provider("auth-internal",container);authProvider.setComponent(new _component.Component("auth-internal",(()=>customAuthImpl),"PRIVATE"));let appCheckProvider=undefined;if(customAppCheckImpl){appCheckProvider=new _component.Provider("app-check-internal",container);appCheckProvider.setComponent(new _component.Component("app-check-internal",(()=>customAppCheckImpl),"PRIVATE"))}return{instance:new Database((0,_database2._repoManagerDatabaseFromApp)(app,authProvider,appCheckProvider,url,nodeAdmin),app),namespace:namespace}}var INTERNAL=Object.freeze({__proto__:null,initStandalone:initStandalone});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ServerValue=Database.ServerValue;function registerDatabase(instance){instance.INTERNAL.registerComponent(new _component.Component("database-compat",((container,{instanceIdentifier:url})=>{const app=container.getProvider("app-compat").getImmediate();const databaseExp=container.getProvider("database").getImmediate({identifier:url});return new Database(databaseExp,app)}),"PUBLIC").setServiceProps({Reference:Reference,Query:Query,Database:Database,DataSnapshot:DataSnapshot,enableLogging:_database2.enableLogging,INTERNAL:INTERNAL,ServerValue:ServerValue}).setMultipleInstances(true));instance.registerVersion(name,version)}registerDatabase(_appCompat.default)},{"@firebase/app-compat":3,"@firebase/component":8,"@firebase/database":10,"@firebase/logger":11,"@firebase/util":12}],10:[function(require,module,exports){(function(process){(function(){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports._TEST_ACCESS_hijackHash=exports._TEST_ACCESS_forceRestClient=exports._ReferenceImpl=exports._QueryParams=exports._QueryImpl=exports.TransactionResult=exports.QueryConstraint=exports.OnDisconnect=exports.Database=exports.DataSnapshot=void 0;exports._initStandalone=_initStandalone;exports._repoManagerDatabaseFromApp=repoManagerDatabaseFromApp;exports._setSDKVersion=setSDKVersion;exports._validateWritablePath=exports._validatePathString=void 0;exports.child=child;exports.connectDatabaseEmulator=connectDatabaseEmulator;exports.enableLogging=enableLogging;exports.endAt=endAt;exports.endBefore=endBefore;exports.equalTo=equalTo;exports.forceLongPolling=forceLongPolling;exports.forceWebSockets=forceWebSockets;exports.get=get;exports.getDatabase=getDatabase;exports.goOffline=goOffline;exports.goOnline=goOnline;exports.increment=increment;exports.limitToFirst=limitToFirst;exports.limitToLast=limitToLast;exports.off=off;exports.onChildAdded=onChildAdded;exports.onChildChanged=onChildChanged;exports.onChildMoved=onChildMoved;exports.onChildRemoved=onChildRemoved;exports.onDisconnect=onDisconnect;exports.onValue=onValue;exports.orderByChild=orderByChild;exports.orderByKey=orderByKey;exports.orderByPriority=orderByPriority;exports.orderByValue=orderByValue;exports.push=push;exports.query=query;exports.ref=ref;exports.refFromURL=refFromURL;exports.remove=remove;exports.runTransaction=runTransaction;exports.serverTimestamp=serverTimestamp;exports.set=set;exports.setPriority=setPriority;exports.setWithPriority=setWithPriority;exports.startAfter=startAfter;exports.startAt=startAt;exports.update=update;var _app=require("@firebase/app");var _component=require("@firebase/component");var _util=require("@firebase/util");var _logger=require("@firebase/logger");const name="@firebase/database";const version="1.0.4";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let SDK_VERSION="";function setSDKVersion(version){SDK_VERSION=version}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class DOMStorageWrapper{constructor(domStorage_){this.domStorage_=domStorage_;this.prefix_="firebase:"}set(key,value){if(value==null){this.domStorage_.removeItem(this.prefixedName_(key))}else{this.domStorage_.setItem(this.prefixedName_(key),(0,_util.stringify)(value))}}get(key){const storedVal=this.domStorage_.getItem(this.prefixedName_(key));if(storedVal==null){return null}else{return(0,_util.jsonEval)(storedVal)}}remove(key){this.domStorage_.removeItem(this.prefixedName_(key))}prefixedName_(name){return this.prefix_+name}toString(){return this.domStorage_.toString()}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class MemoryStorage{constructor(){this.cache_={};this.isInMemoryStorage=true}set(key,value){if(value==null){delete this.cache_[key]}else{this.cache_[key]=value}}get(key){if((0,_util.contains)(this.cache_,key)){return this.cache_[key]}return null}remove(key){delete this.cache_[key]}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const createStoragefor=function(domStorageName){try{if(typeof window!=="undefined"&&typeof window[domStorageName]!=="undefined"){const domStorage=window[domStorageName];domStorage.setItem("firebase:sentinel","cache");domStorage.removeItem("firebase:sentinel");return new DOMStorageWrapper(domStorage)}}catch(e){}return new MemoryStorage};const PersistentStorage=createStoragefor("localStorage");const SessionStorage=createStoragefor("sessionStorage");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const logClient=new _logger.Logger("@firebase/database");const LUIDGenerator=function(){let id=1;return function(){return id++}}();const sha1=function(str){const utf8Bytes=(0,_util.stringToByteArray)(str);const sha1=new _util.Sha1;sha1.update(utf8Bytes);const sha1Bytes=sha1.digest();return _util.base64.encodeByteArray(sha1Bytes)};const buildLogMessage_=function(...varArgs){let message="";for(let i=0;i<varArgs.length;i++){const arg=varArgs[i];if(Array.isArray(arg)||arg&&typeof arg==="object"&&typeof arg.length==="number"){message+=buildLogMessage_.apply(null,arg)}else if(typeof arg==="object"){message+=(0,_util.stringify)(arg)}else{message+=arg}message+=" "}return message};let logger=null;let firstLog_=true;const enableLogging$1=function(logger_,persistent){(0,_util.assert)(!persistent||logger_===true||logger_===false,"Can't turn on custom loggers persistently.");if(logger_===true){logClient.logLevel=_logger.LogLevel.VERBOSE;logger=logClient.log.bind(logClient);if(persistent){SessionStorage.set("logging_enabled",true)}}else if(typeof logger_==="function"){logger=logger_}else{logger=null;SessionStorage.remove("logging_enabled")}};const log=function(...varArgs){if(firstLog_===true){firstLog_=false;if(logger===null&&SessionStorage.get("logging_enabled")===true){enableLogging$1(true)}}if(logger){const message=buildLogMessage_.apply(null,varArgs);logger(message)}};const logWrapper=function(prefix){return function(...varArgs){log(prefix,...varArgs)}};const error=function(...varArgs){const message="FIREBASE INTERNAL ERROR: "+buildLogMessage_(...varArgs);logClient.error(message)};const fatal=function(...varArgs){const message=`FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;logClient.error(message);throw new Error(message)};const warn=function(...varArgs){const message="FIREBASE WARNING: "+buildLogMessage_(...varArgs);logClient.warn(message)};const warnIfPageIsSecure=function(){if(typeof window!=="undefined"&&window.location&&window.location.protocol&&window.location.protocol.indexOf("https:")!==-1){warn("Insecure Firebase access from a secure page. "+"Please use https in calls to new Firebase().")}};const isInvalidJSONNumber=function(data){return typeof data==="number"&&(data!==data||data===Number.POSITIVE_INFINITY||data===Number.NEGATIVE_INFINITY)};const executeWhenDOMReady=function(fn){if((0,_util.isNodeSdk)()||document.readyState==="complete"){fn()}else{let called=false;const wrappedFn=function(){if(!document.body){setTimeout(wrappedFn,Math.floor(10));return}if(!called){called=true;fn()}};if(document.addEventListener){document.addEventListener("DOMContentLoaded",wrappedFn,false);window.addEventListener("load",wrappedFn,false)}else if(document.attachEvent){document.attachEvent("onreadystatechange",(()=>{if(document.readyState==="complete"){wrappedFn()}}));window.attachEvent("onload",wrappedFn)}}};const MIN_NAME="[MIN_NAME]";const MAX_NAME="[MAX_NAME]";const nameCompare=function(a,b){if(a===b){return 0}else if(a===MIN_NAME||b===MAX_NAME){return-1}else if(b===MIN_NAME||a===MAX_NAME){return 1}else{const aAsInt=tryParseInt(a),bAsInt=tryParseInt(b);if(aAsInt!==null){if(bAsInt!==null){return aAsInt-bAsInt===0?a.length-b.length:aAsInt-bAsInt}else{return-1}}else if(bAsInt!==null){return 1}else{return a<b?-1:1}}};const stringCompare=function(a,b){if(a===b){return 0}else if(a<b){return-1}else{return 1}};const requireKey=function(key,obj){if(obj&&key in obj){return obj[key]}else{throw new Error("Missing required key ("+key+") in object: "+(0,_util.stringify)(obj))}};const ObjectToUniqueKey=function(obj){if(typeof obj!=="object"||obj===null){return(0,_util.stringify)(obj)}const keys=[];for(const k in obj){keys.push(k)}keys.sort();let key="{";for(let i=0;i<keys.length;i++){if(i!==0){key+=","}key+=(0,_util.stringify)(keys[i]);key+=":";key+=ObjectToUniqueKey(obj[keys[i]])}key+="}";return key};const splitStringBySize=function(str,segsize){const len=str.length;if(len<=segsize){return[str]}const dataSegs=[];for(let c=0;c<len;c+=segsize){if(c+segsize>len){dataSegs.push(str.substring(c,len))}else{dataSegs.push(str.substring(c,c+segsize))}}return dataSegs};function each(obj,fn){for(const key in obj){if(obj.hasOwnProperty(key)){fn(key,obj[key])}}}const doubleToIEEE754String=function(v){(0,_util.assert)(!isInvalidJSONNumber(v),"Invalid JSON number");const ebits=11,fbits=52;const bias=(1<<ebits-1)-1;let s,e,f,ln,i;if(v===0){e=0;f=0;s=1/v===-Infinity?1:0}else{s=v<0;v=Math.abs(v);if(v>=Math.pow(2,1-bias)){ln=Math.min(Math.floor(Math.log(v)/Math.LN2),bias);e=ln+bias;f=Math.round(v*Math.pow(2,fbits-ln)-Math.pow(2,fbits))}else{e=0;f=Math.round(v/Math.pow(2,1-bias-fbits))}}const bits=[];for(i=fbits;i;i-=1){bits.push(f%2?1:0);f=Math.floor(f/2)}for(i=ebits;i;i-=1){bits.push(e%2?1:0);e=Math.floor(e/2)}bits.push(s?1:0);bits.reverse();const str=bits.join("");let hexByteString="";for(i=0;i<64;i+=8){let hexByte=parseInt(str.substr(i,8),2).toString(16);if(hexByte.length===1){hexByte="0"+hexByte}hexByteString=hexByteString+hexByte}return hexByteString.toLowerCase()};const isChromeExtensionContentScript=function(){return!!(typeof window==="object"&&window["chrome"]&&window["chrome"]["extension"]&&!/^chrome/.test(window.location.href))};const isWindowsStoreApp=function(){return typeof Windows==="object"&&typeof Windows.UI==="object"};function errorForServerCode(code,query){let reason="Unknown Error";if(code==="too_big"){reason="The data requested exceeds the maximum size "+"that can be accessed with a single request."}else if(code==="permission_denied"){reason="Client doesn't have permission to access the desired data."}else if(code==="unavailable"){reason="The service is unavailable"}const error=new Error(code+" at "+query._path.toString()+": "+reason);error.code=code.toUpperCase();return error}const INTEGER_REGEXP_=new RegExp("^-?(0*)\\d{1,10}$");const INTEGER_32_MIN=-2147483648;const INTEGER_32_MAX=2147483647;const tryParseInt=function(str){if(INTEGER_REGEXP_.test(str)){const intVal=Number(str);if(intVal>=INTEGER_32_MIN&&intVal<=INTEGER_32_MAX){return intVal}}return null};const exceptionGuard=function(fn){try{fn()}catch(e){setTimeout((()=>{const stack=e.stack||"";warn("Exception was thrown by user callback.",stack);throw e}),Math.floor(0))}};const beingCrawled=function(){const userAgent=typeof window==="object"&&window["navigator"]&&window["navigator"]["userAgent"]||"";return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i)>=0};const setTimeoutNonBlocking=function(fn,time){const timeout=setTimeout(fn,time);if(typeof timeout==="number"&&typeof Deno!=="undefined"&&Deno["unrefTimer"]){Deno.unrefTimer(timeout)}else if(typeof timeout==="object"&&timeout["unref"]){timeout["unref"]()}return timeout};
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class AppCheckTokenProvider{constructor(appName_,appCheckProvider){this.appName_=appName_;this.appCheckProvider=appCheckProvider;this.appCheck=appCheckProvider===null||appCheckProvider===void 0?void 0:appCheckProvider.getImmediate({optional:true});if(!this.appCheck){appCheckProvider===null||appCheckProvider===void 0?void 0:appCheckProvider.get().then((appCheck=>this.appCheck=appCheck))}}getToken(forceRefresh){if(!this.appCheck){return new Promise(((resolve,reject)=>{setTimeout((()=>{if(this.appCheck){this.getToken(forceRefresh).then(resolve,reject)}else{resolve(null)}}),0)}))}return this.appCheck.getToken(forceRefresh)}addTokenChangeListener(listener){var _a;(_a=this.appCheckProvider)===null||_a===void 0?void 0:_a.get().then((appCheck=>appCheck.addTokenListener(listener)))}notifyForInvalidToken(){warn(`Provided AppCheck credentials for the app named "${this.appName_}" `+"are invalid. This usually indicates your app was not initialized correctly.")}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class FirebaseAuthTokenProvider{constructor(appName_,firebaseOptions_,authProvider_){this.appName_=appName_;this.firebaseOptions_=firebaseOptions_;this.authProvider_=authProvider_;this.auth_=null;this.auth_=authProvider_.getImmediate({optional:true});if(!this.auth_){authProvider_.onInit((auth=>this.auth_=auth))}}getToken(forceRefresh){if(!this.auth_){return new Promise(((resolve,reject)=>{setTimeout((()=>{if(this.auth_){this.getToken(forceRefresh).then(resolve,reject)}else{resolve(null)}}),0)}))}return this.auth_.getToken(forceRefresh).catch((error=>{if(error&&error.code==="auth/token-not-initialized"){log("Got auth/token-not-initialized error.  Treating as null token.");return null}else{return Promise.reject(error)}}))}addTokenChangeListener(listener){if(this.auth_){this.auth_.addAuthTokenListener(listener)}else{this.authProvider_.get().then((auth=>auth.addAuthTokenListener(listener)))}}removeTokenChangeListener(listener){this.authProvider_.get().then((auth=>auth.removeAuthTokenListener(listener)))}notifyForInvalidToken(){let errorMessage='Provided authentication credentials for the app named "'+this.appName_+'" are invalid. This usually indicates your app was not '+"initialized correctly. ";if("credential"in this.firebaseOptions_){errorMessage+='Make sure the "credential" property provided to initializeApp() '+'is authorized to access the specified "databaseURL" and is from the correct '+"project."}else if("serviceAccount"in this.firebaseOptions_){errorMessage+='Make sure the "serviceAccount" property provided to initializeApp() '+'is authorized to access the specified "databaseURL" and is from the correct '+"project."}else{errorMessage+='Make sure the "apiKey" and "databaseURL" properties provided to '+"initializeApp() match the values provided for your app at "+"https://console.firebase.google.com/."}warn(errorMessage)}}class EmulatorTokenProvider{constructor(accessToken){this.accessToken=accessToken}getToken(forceRefresh){return Promise.resolve({accessToken:this.accessToken})}addTokenChangeListener(listener){listener(this.accessToken)}removeTokenChangeListener(listener){}notifyForInvalidToken(){}}EmulatorTokenProvider.OWNER="owner";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const PROTOCOL_VERSION="5";const VERSION_PARAM="v";const TRANSPORT_SESSION_PARAM="s";const REFERER_PARAM="r";const FORGE_REF="f";const FORGE_DOMAIN_RE=/(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;const LAST_SESSION_PARAM="ls";const APPLICATION_ID_PARAM="p";const APP_CHECK_TOKEN_PARAM="ac";const WEBSOCKET="websocket";const LONG_POLLING="long_polling";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class RepoInfo{constructor(host,secure,namespace,webSocketOnly,nodeAdmin=false,persistenceKey="",includeNamespaceInQueryParams=false,isUsingEmulator=false){this.secure=secure;this.namespace=namespace;this.webSocketOnly=webSocketOnly;this.nodeAdmin=nodeAdmin;this.persistenceKey=persistenceKey;this.includeNamespaceInQueryParams=includeNamespaceInQueryParams;this.isUsingEmulator=isUsingEmulator;this._host=host.toLowerCase();this._domain=this._host.substr(this._host.indexOf(".")+1);this.internalHost=PersistentStorage.get("host:"+host)||this._host}isCacheableHost(){return this.internalHost.substr(0,2)==="s-"}isCustomHost(){return this._domain!=="firebaseio.com"&&this._domain!=="firebaseio-demo.com"}get host(){return this._host}set host(newHost){if(newHost!==this.internalHost){this.internalHost=newHost;if(this.isCacheableHost()){PersistentStorage.set("host:"+this._host,this.internalHost)}}}toString(){let str=this.toURLString();if(this.persistenceKey){str+="<"+this.persistenceKey+">"}return str}toURLString(){const protocol=this.secure?"https://":"http://";const query=this.includeNamespaceInQueryParams?`?ns=${this.namespace}`:"";return`${protocol}${this.host}/${query}`}}function repoInfoNeedsQueryParam(repoInfo){return repoInfo.host!==repoInfo.internalHost||repoInfo.isCustomHost()||repoInfo.includeNamespaceInQueryParams}function repoInfoConnectionURL(repoInfo,type,params){(0,_util.assert)(typeof type==="string","typeof type must == string");(0,_util.assert)(typeof params==="object","typeof params must == object");let connURL;if(type===WEBSOCKET){connURL=(repoInfo.secure?"wss://":"ws://")+repoInfo.internalHost+"/.ws?"}else if(type===LONG_POLLING){connURL=(repoInfo.secure?"https://":"http://")+repoInfo.internalHost+"/.lp?"}else{throw new Error("Unknown connection type: "+type)}if(repoInfoNeedsQueryParam(repoInfo)){params["ns"]=repoInfo.namespace}const pairs=[];each(params,((key,value)=>{pairs.push(key+"="+value)}));return connURL+pairs.join("&")}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class StatsCollection{constructor(){this.counters_={}}incrementCounter(name,amount=1){if(!(0,_util.contains)(this.counters_,name)){this.counters_[name]=0}this.counters_[name]+=amount}get(){return(0,_util.deepCopy)(this.counters_)}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const collections={};const reporters={};function statsManagerGetCollection(repoInfo){const hashString=repoInfo.toString();if(!collections[hashString]){collections[hashString]=new StatsCollection}return collections[hashString]}function statsManagerGetOrCreateReporter(repoInfo,creatorFunction){const hashString=repoInfo.toString();if(!reporters[hashString]){reporters[hashString]=creatorFunction()}return reporters[hashString]}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class PacketReceiver{constructor(onMessage_){this.onMessage_=onMessage_;this.pendingResponses=[];this.currentResponseNum=0;this.closeAfterResponse=-1;this.onClose=null}closeAfter(responseNum,callback){this.closeAfterResponse=responseNum;this.onClose=callback;if(this.closeAfterResponse<this.currentResponseNum){this.onClose();this.onClose=null}}handleResponse(requestNum,data){this.pendingResponses[requestNum]=data;while(this.pendingResponses[this.currentResponseNum]){const toProcess=this.pendingResponses[this.currentResponseNum];delete this.pendingResponses[this.currentResponseNum];for(let i=0;i<toProcess.length;++i){if(toProcess[i]){exceptionGuard((()=>{this.onMessage_(toProcess[i])}))}}if(this.currentResponseNum===this.closeAfterResponse){if(this.onClose){this.onClose();this.onClose=null}break}this.currentResponseNum++}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const FIREBASE_LONGPOLL_START_PARAM="start";const FIREBASE_LONGPOLL_CLOSE_COMMAND="close";const FIREBASE_LONGPOLL_COMMAND_CB_NAME="pLPCommand";const FIREBASE_LONGPOLL_DATA_CB_NAME="pRTLPCB";const FIREBASE_LONGPOLL_ID_PARAM="id";const FIREBASE_LONGPOLL_PW_PARAM="pw";const FIREBASE_LONGPOLL_SERIAL_PARAM="ser";const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM="cb";const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM="seg";const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET="ts";const FIREBASE_LONGPOLL_DATA_PARAM="d";const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM="dframe";const MAX_URL_DATA_SIZE=1870;const SEG_HEADER_SIZE=30;const MAX_PAYLOAD_SIZE=MAX_URL_DATA_SIZE-SEG_HEADER_SIZE;const KEEPALIVE_REQUEST_INTERVAL=25e3;const LP_CONNECT_TIMEOUT=3e4;class BrowserPollConnection{constructor(connId,repoInfo,applicationId,appCheckToken,authToken,transportSessionId,lastSessionId){this.connId=connId;this.repoInfo=repoInfo;this.applicationId=applicationId;this.appCheckToken=appCheckToken;this.authToken=authToken;this.transportSessionId=transportSessionId;this.lastSessionId=lastSessionId;this.bytesSent=0;this.bytesReceived=0;this.everConnected_=false;this.log_=logWrapper(connId);this.stats_=statsManagerGetCollection(repoInfo);this.urlFn=params=>{if(this.appCheckToken){params[APP_CHECK_TOKEN_PARAM]=this.appCheckToken}return repoInfoConnectionURL(repoInfo,LONG_POLLING,params)}}open(onMessage,onDisconnect){this.curSegmentNum=0;this.onDisconnect_=onDisconnect;this.myPacketOrderer=new PacketReceiver(onMessage);this.isClosed_=false;this.connectTimeoutTimer_=setTimeout((()=>{this.log_("Timed out trying to connect.");this.onClosed_();this.connectTimeoutTimer_=null}),Math.floor(LP_CONNECT_TIMEOUT));executeWhenDOMReady((()=>{if(this.isClosed_){return}this.scriptTagHolder=new FirebaseIFrameScriptHolder(((...args)=>{const[command,arg1,arg2,arg3,arg4]=args;this.incrementIncomingBytes_(args);if(!this.scriptTagHolder){return}if(this.connectTimeoutTimer_){clearTimeout(this.connectTimeoutTimer_);this.connectTimeoutTimer_=null}this.everConnected_=true;if(command===FIREBASE_LONGPOLL_START_PARAM){this.id=arg1;this.password=arg2}else if(command===FIREBASE_LONGPOLL_CLOSE_COMMAND){if(arg1){this.scriptTagHolder.sendNewPolls=false;this.myPacketOrderer.closeAfter(arg1,(()=>{this.onClosed_()}))}else{this.onClosed_()}}else{throw new Error("Unrecognized command received: "+command)}}),((...args)=>{const[pN,data]=args;this.incrementIncomingBytes_(args);this.myPacketOrderer.handleResponse(pN,data)}),(()=>{this.onClosed_()}),this.urlFn);const urlParams={};urlParams[FIREBASE_LONGPOLL_START_PARAM]="t";urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM]=Math.floor(Math.random()*1e8);if(this.scriptTagHolder.uniqueCallbackIdentifier){urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM]=this.scriptTagHolder.uniqueCallbackIdentifier}urlParams[VERSION_PARAM]=PROTOCOL_VERSION;if(this.transportSessionId){urlParams[TRANSPORT_SESSION_PARAM]=this.transportSessionId}if(this.lastSessionId){urlParams[LAST_SESSION_PARAM]=this.lastSessionId}if(this.applicationId){urlParams[APPLICATION_ID_PARAM]=this.applicationId}if(this.appCheckToken){urlParams[APP_CHECK_TOKEN_PARAM]=this.appCheckToken}if(typeof location!=="undefined"&&location.hostname&&FORGE_DOMAIN_RE.test(location.hostname)){urlParams[REFERER_PARAM]=FORGE_REF}const connectURL=this.urlFn(urlParams);this.log_("Connecting via long-poll to "+connectURL);this.scriptTagHolder.addTag(connectURL,(()=>{}))}))}start(){this.scriptTagHolder.startLongPoll(this.id,this.password);this.addDisconnectPingFrame(this.id,this.password)}static forceAllow(){BrowserPollConnection.forceAllow_=true}static forceDisallow(){BrowserPollConnection.forceDisallow_=true}static isAvailable(){if((0,_util.isNodeSdk)()){return false}else if(BrowserPollConnection.forceAllow_){return true}else{return!BrowserPollConnection.forceDisallow_&&typeof document!=="undefined"&&document.createElement!=null&&!isChromeExtensionContentScript()&&!isWindowsStoreApp()}}markConnectionHealthy(){}shutdown_(){this.isClosed_=true;if(this.scriptTagHolder){this.scriptTagHolder.close();this.scriptTagHolder=null}if(this.myDisconnFrame){document.body.removeChild(this.myDisconnFrame);this.myDisconnFrame=null}if(this.connectTimeoutTimer_){clearTimeout(this.connectTimeoutTimer_);this.connectTimeoutTimer_=null}}onClosed_(){if(!this.isClosed_){this.log_("Longpoll is closing itself");this.shutdown_();if(this.onDisconnect_){this.onDisconnect_(this.everConnected_);this.onDisconnect_=null}}}close(){if(!this.isClosed_){this.log_("Longpoll is being closed.");this.shutdown_()}}send(data){const dataStr=(0,_util.stringify)(data);this.bytesSent+=dataStr.length;this.stats_.incrementCounter("bytes_sent",dataStr.length);const base64data=(0,_util.base64Encode)(dataStr);const dataSegs=splitStringBySize(base64data,MAX_PAYLOAD_SIZE);for(let i=0;i<dataSegs.length;i++){this.scriptTagHolder.enqueueSegment(this.curSegmentNum,dataSegs.length,dataSegs[i]);this.curSegmentNum++}}addDisconnectPingFrame(id,pw){if((0,_util.isNodeSdk)()){return}this.myDisconnFrame=document.createElement("iframe");const urlParams={};urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM]="t";urlParams[FIREBASE_LONGPOLL_ID_PARAM]=id;urlParams[FIREBASE_LONGPOLL_PW_PARAM]=pw;this.myDisconnFrame.src=this.urlFn(urlParams);this.myDisconnFrame.style.display="none";document.body.appendChild(this.myDisconnFrame)}incrementIncomingBytes_(args){const bytesReceived=(0,_util.stringify)(args).length;this.bytesReceived+=bytesReceived;this.stats_.incrementCounter("bytes_received",bytesReceived)}}class FirebaseIFrameScriptHolder{constructor(commandCB,onMessageCB,onDisconnect,urlFn){this.onDisconnect=onDisconnect;this.urlFn=urlFn;this.outstandingRequests=new Set;this.pendingSegs=[];this.currentSerial=Math.floor(Math.random()*1e8);this.sendNewPolls=true;if(!(0,_util.isNodeSdk)()){this.uniqueCallbackIdentifier=LUIDGenerator();window[FIREBASE_LONGPOLL_COMMAND_CB_NAME+this.uniqueCallbackIdentifier]=commandCB;window[FIREBASE_LONGPOLL_DATA_CB_NAME+this.uniqueCallbackIdentifier]=onMessageCB;this.myIFrame=FirebaseIFrameScriptHolder.createIFrame_();let script="";if(this.myIFrame.src&&this.myIFrame.src.substr(0,"javascript:".length)==="javascript:"){const currentDomain=document.domain;script='<script>document.domain="'+currentDomain+'";<\/script>'}const iframeContents="<html><body>"+script+"</body></html>";try{this.myIFrame.doc.open();this.myIFrame.doc.write(iframeContents);this.myIFrame.doc.close()}catch(e){log("frame writing exception");if(e.stack){log(e.stack)}log(e)}}else{this.commandCB=commandCB;this.onMessageCB=onMessageCB}}static createIFrame_(){const iframe=document.createElement("iframe");iframe.style.display="none";if(document.body){document.body.appendChild(iframe);try{const a=iframe.contentWindow.document;if(!a){log("No IE domain setting required")}}catch(e){const domain=document.domain;iframe.src="javascript:void((function(){document.open();document.domain='"+domain+"';document.close();})())"}}else{throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready."}if(iframe.contentDocument){iframe.doc=iframe.contentDocument}else if(iframe.contentWindow){iframe.doc=iframe.contentWindow.document}else if(iframe.document){iframe.doc=iframe.document}return iframe}close(){this.alive=false;if(this.myIFrame){this.myIFrame.doc.body.textContent="";setTimeout((()=>{if(this.myIFrame!==null){document.body.removeChild(this.myIFrame);this.myIFrame=null}}),Math.floor(0))}const onDisconnect=this.onDisconnect;if(onDisconnect){this.onDisconnect=null;onDisconnect()}}startLongPoll(id,pw){this.myID=id;this.myPW=pw;this.alive=true;while(this.newRequest_()){}}newRequest_(){if(this.alive&&this.sendNewPolls&&this.outstandingRequests.size<(this.pendingSegs.length>0?2:1)){this.currentSerial++;const urlParams={};urlParams[FIREBASE_LONGPOLL_ID_PARAM]=this.myID;urlParams[FIREBASE_LONGPOLL_PW_PARAM]=this.myPW;urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM]=this.currentSerial;let theURL=this.urlFn(urlParams);let curDataString="";let i=0;while(this.pendingSegs.length>0){const nextSeg=this.pendingSegs[0];if(nextSeg.d.length+SEG_HEADER_SIZE+curDataString.length<=MAX_URL_DATA_SIZE){const theSeg=this.pendingSegs.shift();curDataString=curDataString+"&"+FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM+i+"="+theSeg.seg+"&"+FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET+i+"="+theSeg.ts+"&"+FIREBASE_LONGPOLL_DATA_PARAM+i+"="+theSeg.d;i++}else{break}}theURL=theURL+curDataString;this.addLongPollTag_(theURL,this.currentSerial);return true}else{return false}}enqueueSegment(segnum,totalsegs,data){this.pendingSegs.push({seg:segnum,ts:totalsegs,d:data});if(this.alive){this.newRequest_()}}addLongPollTag_(url,serial){this.outstandingRequests.add(serial);const doNewRequest=()=>{this.outstandingRequests.delete(serial);this.newRequest_()};const keepaliveTimeout=setTimeout(doNewRequest,Math.floor(KEEPALIVE_REQUEST_INTERVAL));const readyStateCB=()=>{clearTimeout(keepaliveTimeout);doNewRequest()};this.addTag(url,readyStateCB)}addTag(url,loadCB){if((0,_util.isNodeSdk)()){this.doNodeLongPoll(url,loadCB)}else{setTimeout((()=>{try{if(!this.sendNewPolls){return}const newScript=this.myIFrame.doc.createElement("script");newScript.type="text/javascript";newScript.async=true;newScript.src=url;newScript.onload=newScript.onreadystatechange=function(){const rstate=newScript.readyState;if(!rstate||rstate==="loaded"||rstate==="complete"){newScript.onload=newScript.onreadystatechange=null;if(newScript.parentNode){newScript.parentNode.removeChild(newScript)}loadCB()}};newScript.onerror=()=>{log("Long-poll script failed to load: "+url);this.sendNewPolls=false;this.close()};this.myIFrame.doc.body.appendChild(newScript)}catch(e){}}),Math.floor(1))}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const WEBSOCKET_MAX_FRAME_SIZE=16384;const WEBSOCKET_KEEPALIVE_INTERVAL=45e3;let WebSocketImpl=null;if(typeof MozWebSocket!=="undefined"){WebSocketImpl=MozWebSocket}else if(typeof WebSocket!=="undefined"){WebSocketImpl=WebSocket}class WebSocketConnection{constructor(connId,repoInfo,applicationId,appCheckToken,authToken,transportSessionId,lastSessionId){this.connId=connId;this.applicationId=applicationId;this.appCheckToken=appCheckToken;this.authToken=authToken;this.keepaliveTimer=null;this.frames=null;this.totalFrames=0;this.bytesSent=0;this.bytesReceived=0;this.log_=logWrapper(this.connId);this.stats_=statsManagerGetCollection(repoInfo);this.connURL=WebSocketConnection.connectionURL_(repoInfo,transportSessionId,lastSessionId,appCheckToken,applicationId);this.nodeAdmin=repoInfo.nodeAdmin}static connectionURL_(repoInfo,transportSessionId,lastSessionId,appCheckToken,applicationId){const urlParams={};urlParams[VERSION_PARAM]=PROTOCOL_VERSION;if(!(0,_util.isNodeSdk)()&&typeof location!=="undefined"&&location.hostname&&FORGE_DOMAIN_RE.test(location.hostname)){urlParams[REFERER_PARAM]=FORGE_REF}if(transportSessionId){urlParams[TRANSPORT_SESSION_PARAM]=transportSessionId}if(lastSessionId){urlParams[LAST_SESSION_PARAM]=lastSessionId}if(appCheckToken){urlParams[APP_CHECK_TOKEN_PARAM]=appCheckToken}if(applicationId){urlParams[APPLICATION_ID_PARAM]=applicationId}return repoInfoConnectionURL(repoInfo,WEBSOCKET,urlParams)}open(onMessage,onDisconnect){this.onDisconnect=onDisconnect;this.onMessage=onMessage;this.log_("Websocket connecting to "+this.connURL);this.everConnected_=false;PersistentStorage.set("previous_websocket_failure",true);try{let options;if((0,_util.isNodeSdk)()){const device=this.nodeAdmin?"AdminNode":"Node";options={headers:{"User-Agent":`Firebase/${PROTOCOL_VERSION}/${SDK_VERSION}/${process.platform}/${device}`,"X-Firebase-GMPID":this.applicationId||""}};if(this.authToken){options.headers["Authorization"]=`Bearer ${this.authToken}`}if(this.appCheckToken){options.headers["X-Firebase-AppCheck"]=this.appCheckToken}const env=process["env"];const proxy=this.connURL.indexOf("wss://")===0?env["HTTPS_PROXY"]||env["https_proxy"]:env["HTTP_PROXY"]||env["http_proxy"];if(proxy){options["proxy"]={origin:proxy}}}this.mySock=new WebSocketImpl(this.connURL,[],options)}catch(e){this.log_("Error instantiating WebSocket.");const error=e.message||e.data;if(error){this.log_(error)}this.onClosed_();return}this.mySock.onopen=()=>{this.log_("Websocket connected.");this.everConnected_=true};this.mySock.onclose=()=>{this.log_("Websocket connection was disconnected.");this.mySock=null;this.onClosed_()};this.mySock.onmessage=m=>{this.handleIncomingFrame(m)};this.mySock.onerror=e=>{this.log_("WebSocket error.  Closing connection.");const error=e.message||e.data;if(error){this.log_(error)}this.onClosed_()}}start(){}static forceDisallow(){WebSocketConnection.forceDisallow_=true}static isAvailable(){let isOldAndroid=false;if(typeof navigator!=="undefined"&&navigator.userAgent){const oldAndroidRegex=/Android ([0-9]{0,}\.[0-9]{0,})/;const oldAndroidMatch=navigator.userAgent.match(oldAndroidRegex);if(oldAndroidMatch&&oldAndroidMatch.length>1){if(parseFloat(oldAndroidMatch[1])<4.4){isOldAndroid=true}}}return!isOldAndroid&&WebSocketImpl!==null&&!WebSocketConnection.forceDisallow_}static previouslyFailed(){return PersistentStorage.isInMemoryStorage||PersistentStorage.get("previous_websocket_failure")===true}markConnectionHealthy(){PersistentStorage.remove("previous_websocket_failure")}appendFrame_(data){this.frames.push(data);if(this.frames.length===this.totalFrames){const fullMess=this.frames.join("");this.frames=null;const jsonMess=(0,_util.jsonEval)(fullMess);this.onMessage(jsonMess)}}handleNewFrameCount_(frameCount){this.totalFrames=frameCount;this.frames=[]}extractFrameCount_(data){(0,_util.assert)(this.frames===null,"We already have a frame buffer");if(data.length<=6){const frameCount=Number(data);if(!isNaN(frameCount)){this.handleNewFrameCount_(frameCount);return null}}this.handleNewFrameCount_(1);return data}handleIncomingFrame(mess){if(this.mySock===null){return}const data=mess["data"];this.bytesReceived+=data.length;this.stats_.incrementCounter("bytes_received",data.length);this.resetKeepAlive();if(this.frames!==null){this.appendFrame_(data)}else{const remainingData=this.extractFrameCount_(data);if(remainingData!==null){this.appendFrame_(remainingData)}}}send(data){this.resetKeepAlive();const dataStr=(0,_util.stringify)(data);this.bytesSent+=dataStr.length;this.stats_.incrementCounter("bytes_sent",dataStr.length);const dataSegs=splitStringBySize(dataStr,WEBSOCKET_MAX_FRAME_SIZE);if(dataSegs.length>1){this.sendString_(String(dataSegs.length))}for(let i=0;i<dataSegs.length;i++){this.sendString_(dataSegs[i])}}shutdown_(){this.isClosed_=true;if(this.keepaliveTimer){clearInterval(this.keepaliveTimer);this.keepaliveTimer=null}if(this.mySock){this.mySock.close();this.mySock=null}}onClosed_(){if(!this.isClosed_){this.log_("WebSocket is closing itself");this.shutdown_();if(this.onDisconnect){this.onDisconnect(this.everConnected_);this.onDisconnect=null}}}close(){if(!this.isClosed_){this.log_("WebSocket is being closed");this.shutdown_()}}resetKeepAlive(){clearInterval(this.keepaliveTimer);this.keepaliveTimer=setInterval((()=>{if(this.mySock){this.sendString_("0")}this.resetKeepAlive()}),Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL))}sendString_(str){try{this.mySock.send(str)}catch(e){this.log_("Exception thrown from WebSocket.send():",e.message||e.data,"Closing connection.");setTimeout(this.onClosed_.bind(this),0)}}}WebSocketConnection.responsesRequiredToBeHealthy=2;WebSocketConnection.healthyTimeout=3e4;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class TransportManager{constructor(repoInfo){this.initTransports_(repoInfo)}static get ALL_TRANSPORTS(){return[BrowserPollConnection,WebSocketConnection]}static get IS_TRANSPORT_INITIALIZED(){return this.globalTransportInitialized_}initTransports_(repoInfo){const isWebSocketsAvailable=WebSocketConnection&&WebSocketConnection["isAvailable"]();let isSkipPollConnection=isWebSocketsAvailable&&!WebSocketConnection.previouslyFailed();if(repoInfo.webSocketOnly){if(!isWebSocketsAvailable){warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.")}isSkipPollConnection=true}if(isSkipPollConnection){this.transports_=[WebSocketConnection]}else{const transports=this.transports_=[];for(const transport of TransportManager.ALL_TRANSPORTS){if(transport&&transport["isAvailable"]()){transports.push(transport)}}TransportManager.globalTransportInitialized_=true}}initialTransport(){if(this.transports_.length>0){return this.transports_[0]}else{throw new Error("No transports available")}}upgradeTransport(){if(this.transports_.length>1){return this.transports_[1]}else{return null}}}TransportManager.globalTransportInitialized_=false;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const UPGRADE_TIMEOUT=6e4;const DELAY_BEFORE_SENDING_EXTRA_REQUESTS=5e3;const BYTES_SENT_HEALTHY_OVERRIDE=10*1024;const BYTES_RECEIVED_HEALTHY_OVERRIDE=100*1024;const MESSAGE_TYPE="t";const MESSAGE_DATA="d";const CONTROL_SHUTDOWN="s";const CONTROL_RESET="r";const CONTROL_ERROR="e";const CONTROL_PONG="o";const SWITCH_ACK="a";const END_TRANSMISSION="n";const PING="p";const SERVER_HELLO="h";class Connection{constructor(id,repoInfo_,applicationId_,appCheckToken_,authToken_,onMessage_,onReady_,onDisconnect_,onKill_,lastSessionId){this.id=id;this.repoInfo_=repoInfo_;this.applicationId_=applicationId_;this.appCheckToken_=appCheckToken_;this.authToken_=authToken_;this.onMessage_=onMessage_;this.onReady_=onReady_;this.onDisconnect_=onDisconnect_;this.onKill_=onKill_;this.lastSessionId=lastSessionId;this.connectionCount=0;this.pendingDataMessages=[];this.state_=0;this.log_=logWrapper("c:"+this.id+":");this.transportManager_=new TransportManager(repoInfo_);this.log_("Connection created");this.start_()}start_(){const conn=this.transportManager_.initialTransport();this.conn_=new conn(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,null,this.lastSessionId);this.primaryResponsesRequired_=conn["responsesRequiredToBeHealthy"]||0;const onMessageReceived=this.connReceiver_(this.conn_);const onConnectionLost=this.disconnReceiver_(this.conn_);this.tx_=this.conn_;this.rx_=this.conn_;this.secondaryConn_=null;this.isHealthy_=false;setTimeout((()=>{this.conn_&&this.conn_.open(onMessageReceived,onConnectionLost)}),Math.floor(0));const healthyTimeoutMS=conn["healthyTimeout"]||0;if(healthyTimeoutMS>0){this.healthyTimeout_=setTimeoutNonBlocking((()=>{this.healthyTimeout_=null;if(!this.isHealthy_){if(this.conn_&&this.conn_.bytesReceived>BYTES_RECEIVED_HEALTHY_OVERRIDE){this.log_("Connection exceeded healthy timeout but has received "+this.conn_.bytesReceived+" bytes.  Marking connection healthy.");this.isHealthy_=true;this.conn_.markConnectionHealthy()}else if(this.conn_&&this.conn_.bytesSent>BYTES_SENT_HEALTHY_OVERRIDE){this.log_("Connection exceeded healthy timeout but has sent "+this.conn_.bytesSent+" bytes.  Leaving connection alive.")}else{this.log_("Closing unhealthy connection after timeout.");this.close()}}}),Math.floor(healthyTimeoutMS))}}nextTransportId_(){return"c:"+this.id+":"+this.connectionCount++}disconnReceiver_(conn){return everConnected=>{if(conn===this.conn_){this.onConnectionLost_(everConnected)}else if(conn===this.secondaryConn_){this.log_("Secondary connection lost.");this.onSecondaryConnectionLost_()}else{this.log_("closing an old connection")}}}connReceiver_(conn){return message=>{if(this.state_!==2){if(conn===this.rx_){this.onPrimaryMessageReceived_(message)}else if(conn===this.secondaryConn_){this.onSecondaryMessageReceived_(message)}else{this.log_("message on old connection")}}}}sendRequest(dataMsg){const msg={t:"d",d:dataMsg};this.sendData_(msg)}tryCleanupConnection(){if(this.tx_===this.secondaryConn_&&this.rx_===this.secondaryConn_){this.log_("cleaning up and promoting a connection: "+this.secondaryConn_.connId);this.conn_=this.secondaryConn_;this.secondaryConn_=null}}onSecondaryControl_(controlData){if(MESSAGE_TYPE in controlData){const cmd=controlData[MESSAGE_TYPE];if(cmd===SWITCH_ACK){this.upgradeIfSecondaryHealthy_()}else if(cmd===CONTROL_RESET){this.log_("Got a reset on secondary, closing it");this.secondaryConn_.close();if(this.tx_===this.secondaryConn_||this.rx_===this.secondaryConn_){this.close()}}else if(cmd===CONTROL_PONG){this.log_("got pong on secondary.");this.secondaryResponsesRequired_--;this.upgradeIfSecondaryHealthy_()}}}onSecondaryMessageReceived_(parsedData){const layer=requireKey("t",parsedData);const data=requireKey("d",parsedData);if(layer==="c"){this.onSecondaryControl_(data)}else if(layer==="d"){this.pendingDataMessages.push(data)}else{throw new Error("Unknown protocol layer: "+layer)}}upgradeIfSecondaryHealthy_(){if(this.secondaryResponsesRequired_<=0){this.log_("Secondary connection is healthy.");this.isHealthy_=true;this.secondaryConn_.markConnectionHealthy();this.proceedWithUpgrade_()}else{this.log_("sending ping on secondary.");this.secondaryConn_.send({t:"c",d:{t:PING,d:{}}})}}proceedWithUpgrade_(){this.secondaryConn_.start();this.log_("sending client ack on secondary");this.secondaryConn_.send({t:"c",d:{t:SWITCH_ACK,d:{}}});this.log_("Ending transmission on primary");this.conn_.send({t:"c",d:{t:END_TRANSMISSION,d:{}}});this.tx_=this.secondaryConn_;this.tryCleanupConnection()}onPrimaryMessageReceived_(parsedData){const layer=requireKey("t",parsedData);const data=requireKey("d",parsedData);if(layer==="c"){this.onControl_(data)}else if(layer==="d"){this.onDataMessage_(data)}}onDataMessage_(message){this.onPrimaryResponse_();this.onMessage_(message)}onPrimaryResponse_(){if(!this.isHealthy_){this.primaryResponsesRequired_--;if(this.primaryResponsesRequired_<=0){this.log_("Primary connection is healthy.");this.isHealthy_=true;this.conn_.markConnectionHealthy()}}}onControl_(controlData){const cmd=requireKey(MESSAGE_TYPE,controlData);if(MESSAGE_DATA in controlData){const payload=controlData[MESSAGE_DATA];if(cmd===SERVER_HELLO){const handshakePayload=Object.assign({},payload);if(this.repoInfo_.isUsingEmulator){handshakePayload.h=this.repoInfo_.host}this.onHandshake_(handshakePayload)}else if(cmd===END_TRANSMISSION){this.log_("recvd end transmission on primary");this.rx_=this.secondaryConn_;for(let i=0;i<this.pendingDataMessages.length;++i){this.onDataMessage_(this.pendingDataMessages[i])}this.pendingDataMessages=[];this.tryCleanupConnection()}else if(cmd===CONTROL_SHUTDOWN){this.onConnectionShutdown_(payload)}else if(cmd===CONTROL_RESET){this.onReset_(payload)}else if(cmd===CONTROL_ERROR){error("Server Error: "+payload)}else if(cmd===CONTROL_PONG){this.log_("got pong on primary.");this.onPrimaryResponse_();this.sendPingOnPrimaryIfNecessary_()}else{error("Unknown control packet command: "+cmd)}}}onHandshake_(handshake){const timestamp=handshake.ts;const version=handshake.v;const host=handshake.h;this.sessionId=handshake.s;this.repoInfo_.host=host;if(this.state_===0){this.conn_.start();this.onConnectionEstablished_(this.conn_,timestamp);if(PROTOCOL_VERSION!==version){warn("Protocol version mismatch detected")}this.tryStartUpgrade_()}}tryStartUpgrade_(){const conn=this.transportManager_.upgradeTransport();if(conn){this.startUpgrade_(conn)}}startUpgrade_(conn){this.secondaryConn_=new conn(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,this.sessionId);this.secondaryResponsesRequired_=conn["responsesRequiredToBeHealthy"]||0;const onMessage=this.connReceiver_(this.secondaryConn_);const onDisconnect=this.disconnReceiver_(this.secondaryConn_);this.secondaryConn_.open(onMessage,onDisconnect);setTimeoutNonBlocking((()=>{if(this.secondaryConn_){this.log_("Timed out trying to upgrade.");this.secondaryConn_.close()}}),Math.floor(UPGRADE_TIMEOUT))}onReset_(host){this.log_("Reset packet received.  New host: "+host);this.repoInfo_.host=host;if(this.state_===1){this.close()}else{this.closeConnections_();this.start_()}}onConnectionEstablished_(conn,timestamp){this.log_("Realtime connection established.");this.conn_=conn;this.state_=1;if(this.onReady_){this.onReady_(timestamp,this.sessionId);this.onReady_=null}if(this.primaryResponsesRequired_===0){this.log_("Primary connection is healthy.");this.isHealthy_=true}else{setTimeoutNonBlocking((()=>{this.sendPingOnPrimaryIfNecessary_()}),Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS))}}sendPingOnPrimaryIfNecessary_(){if(!this.isHealthy_&&this.state_===1){this.log_("sending ping on primary.");this.sendData_({t:"c",d:{t:PING,d:{}}})}}onSecondaryConnectionLost_(){const conn=this.secondaryConn_;this.secondaryConn_=null;if(this.tx_===conn||this.rx_===conn){this.close()}}onConnectionLost_(everConnected){this.conn_=null;if(!everConnected&&this.state_===0){this.log_("Realtime connection failed.");if(this.repoInfo_.isCacheableHost()){PersistentStorage.remove("host:"+this.repoInfo_.host);this.repoInfo_.internalHost=this.repoInfo_.host}}else if(this.state_===1){this.log_("Realtime connection lost.")}this.close()}onConnectionShutdown_(reason){this.log_("Connection shutdown command received. Shutting down...");if(this.onKill_){this.onKill_(reason);this.onKill_=null}this.onDisconnect_=null;this.close()}sendData_(data){if(this.state_!==1){throw"Connection is not connected"}else{this.tx_.send(data)}}close(){if(this.state_!==2){this.log_("Closing realtime connection.");this.state_=2;this.closeConnections_();if(this.onDisconnect_){this.onDisconnect_();this.onDisconnect_=null}}}closeConnections_(){this.log_("Shutting down all connections");if(this.conn_){this.conn_.close();this.conn_=null}if(this.secondaryConn_){this.secondaryConn_.close();this.secondaryConn_=null}if(this.healthyTimeout_){clearTimeout(this.healthyTimeout_);this.healthyTimeout_=null}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ServerActions{put(pathString,data,onComplete,hash){}merge(pathString,data,onComplete,hash){}refreshAuthToken(token){}refreshAppCheckToken(token){}onDisconnectPut(pathString,data,onComplete){}onDisconnectMerge(pathString,data,onComplete){}onDisconnectCancel(pathString,onComplete){}reportStats(stats){}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class EventEmitter{constructor(allowedEvents_){this.allowedEvents_=allowedEvents_;this.listeners_={};(0,_util.assert)(Array.isArray(allowedEvents_)&&allowedEvents_.length>0,"Requires a non-empty array")}trigger(eventType,...varArgs){if(Array.isArray(this.listeners_[eventType])){const listeners=[...this.listeners_[eventType]];for(let i=0;i<listeners.length;i++){listeners[i].callback.apply(listeners[i].context,varArgs)}}}on(eventType,callback,context){this.validateEventType_(eventType);this.listeners_[eventType]=this.listeners_[eventType]||[];this.listeners_[eventType].push({callback:callback,context:context});const eventData=this.getInitialEvent(eventType);if(eventData){callback.apply(context,eventData)}}off(eventType,callback,context){this.validateEventType_(eventType);const listeners=this.listeners_[eventType]||[];for(let i=0;i<listeners.length;i++){if(listeners[i].callback===callback&&(!context||context===listeners[i].context)){listeners.splice(i,1);return}}}validateEventType_(eventType){(0,_util.assert)(this.allowedEvents_.find((et=>et===eventType)),"Unknown event: "+eventType)}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class OnlineMonitor extends EventEmitter{constructor(){super(["online"]);this.online_=true;if(typeof window!=="undefined"&&typeof window.addEventListener!=="undefined"&&!(0,_util.isMobileCordova)()){window.addEventListener("online",(()=>{if(!this.online_){this.online_=true;this.trigger("online",true)}}),false);window.addEventListener("offline",(()=>{if(this.online_){this.online_=false;this.trigger("online",false)}}),false)}}static getInstance(){return new OnlineMonitor}getInitialEvent(eventType){(0,_util.assert)(eventType==="online","Unknown event type: "+eventType);return[this.online_]}currentlyOnline(){return this.online_}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const MAX_PATH_DEPTH=32;const MAX_PATH_LENGTH_BYTES=768;class Path{constructor(pathOrString,pieceNum){if(pieceNum===void 0){this.pieces_=pathOrString.split("/");let copyTo=0;for(let i=0;i<this.pieces_.length;i++){if(this.pieces_[i].length>0){this.pieces_[copyTo]=this.pieces_[i];copyTo++}}this.pieces_.length=copyTo;this.pieceNum_=0}else{this.pieces_=pathOrString;this.pieceNum_=pieceNum}}toString(){let pathString="";for(let i=this.pieceNum_;i<this.pieces_.length;i++){if(this.pieces_[i]!==""){pathString+="/"+this.pieces_[i]}}return pathString||"/"}}function newEmptyPath(){return new Path("")}function pathGetFront(path){if(path.pieceNum_>=path.pieces_.length){return null}return path.pieces_[path.pieceNum_]}function pathGetLength(path){return path.pieces_.length-path.pieceNum_}function pathPopFront(path){let pieceNum=path.pieceNum_;if(pieceNum<path.pieces_.length){pieceNum++}return new Path(path.pieces_,pieceNum)}function pathGetBack(path){if(path.pieceNum_<path.pieces_.length){return path.pieces_[path.pieces_.length-1]}return null}function pathToUrlEncodedString(path){let pathString="";for(let i=path.pieceNum_;i<path.pieces_.length;i++){if(path.pieces_[i]!==""){pathString+="/"+encodeURIComponent(String(path.pieces_[i]))}}return pathString||"/"}function pathSlice(path,begin=0){return path.pieces_.slice(path.pieceNum_+begin)}function pathParent(path){if(path.pieceNum_>=path.pieces_.length){return null}const pieces=[];for(let i=path.pieceNum_;i<path.pieces_.length-1;i++){pieces.push(path.pieces_[i])}return new Path(pieces,0)}function pathChild(path,childPathObj){const pieces=[];for(let i=path.pieceNum_;i<path.pieces_.length;i++){pieces.push(path.pieces_[i])}if(childPathObj instanceof Path){for(let i=childPathObj.pieceNum_;i<childPathObj.pieces_.length;i++){pieces.push(childPathObj.pieces_[i])}}else{const childPieces=childPathObj.split("/");for(let i=0;i<childPieces.length;i++){if(childPieces[i].length>0){pieces.push(childPieces[i])}}}return new Path(pieces,0)}function pathIsEmpty(path){return path.pieceNum_>=path.pieces_.length}function newRelativePath(outerPath,innerPath){const outer=pathGetFront(outerPath),inner=pathGetFront(innerPath);if(outer===null){return innerPath}else if(outer===inner){return newRelativePath(pathPopFront(outerPath),pathPopFront(innerPath))}else{throw new Error("INTERNAL ERROR: innerPath ("+innerPath+") is not within "+"outerPath ("+outerPath+")")}}function pathCompare(left,right){const leftKeys=pathSlice(left,0);const rightKeys=pathSlice(right,0);for(let i=0;i<leftKeys.length&&i<rightKeys.length;i++){const cmp=nameCompare(leftKeys[i],rightKeys[i]);if(cmp!==0){return cmp}}if(leftKeys.length===rightKeys.length){return 0}return leftKeys.length<rightKeys.length?-1:1}function pathEquals(path,other){if(pathGetLength(path)!==pathGetLength(other)){return false}for(let i=path.pieceNum_,j=other.pieceNum_;i<=path.pieces_.length;i++,j++){if(path.pieces_[i]!==other.pieces_[j]){return false}}return true}function pathContains(path,other){let i=path.pieceNum_;let j=other.pieceNum_;if(pathGetLength(path)>pathGetLength(other)){return false}while(i<path.pieces_.length){if(path.pieces_[i]!==other.pieces_[j]){return false}++i;++j}return true}class ValidationPath{constructor(path,errorPrefix_){this.errorPrefix_=errorPrefix_;this.parts_=pathSlice(path,0);this.byteLength_=Math.max(1,this.parts_.length);for(let i=0;i<this.parts_.length;i++){this.byteLength_+=(0,_util.stringLength)(this.parts_[i])}validationPathCheckValid(this)}}function validationPathPush(validationPath,child){if(validationPath.parts_.length>0){validationPath.byteLength_+=1}validationPath.parts_.push(child);validationPath.byteLength_+=(0,_util.stringLength)(child);validationPathCheckValid(validationPath)}function validationPathPop(validationPath){const last=validationPath.parts_.pop();validationPath.byteLength_-=(0,_util.stringLength)(last);if(validationPath.parts_.length>0){validationPath.byteLength_-=1}}function validationPathCheckValid(validationPath){if(validationPath.byteLength_>MAX_PATH_LENGTH_BYTES){throw new Error(validationPath.errorPrefix_+"has a key path longer than "+MAX_PATH_LENGTH_BYTES+" bytes ("+validationPath.byteLength_+").")}if(validationPath.parts_.length>MAX_PATH_DEPTH){throw new Error(validationPath.errorPrefix_+"path specified exceeds the maximum depth that can be written ("+MAX_PATH_DEPTH+") or object contains a cycle "+validationPathToErrorString(validationPath))}}function validationPathToErrorString(validationPath){if(validationPath.parts_.length===0){return""}return"in property '"+validationPath.parts_.join(".")+"'"}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class VisibilityMonitor extends EventEmitter{constructor(){super(["visible"]);let hidden;let visibilityChange;if(typeof document!=="undefined"&&typeof document.addEventListener!=="undefined"){if(typeof document["hidden"]!=="undefined"){visibilityChange="visibilitychange";hidden="hidden"}else if(typeof document["mozHidden"]!=="undefined"){visibilityChange="mozvisibilitychange";hidden="mozHidden"}else if(typeof document["msHidden"]!=="undefined"){visibilityChange="msvisibilitychange";hidden="msHidden"}else if(typeof document["webkitHidden"]!=="undefined"){visibilityChange="webkitvisibilitychange";hidden="webkitHidden"}}this.visible_=true;if(visibilityChange){document.addEventListener(visibilityChange,(()=>{const visible=!document[hidden];if(visible!==this.visible_){this.visible_=visible;this.trigger("visible",visible)}}),false)}}static getInstance(){return new VisibilityMonitor}getInitialEvent(eventType){(0,_util.assert)(eventType==="visible","Unknown event type: "+eventType);return[this.visible_]}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const RECONNECT_MIN_DELAY=1e3;const RECONNECT_MAX_DELAY_DEFAULT=60*5*1e3;const RECONNECT_MAX_DELAY_FOR_ADMINS=30*1e3;const RECONNECT_DELAY_MULTIPLIER=1.3;const RECONNECT_DELAY_RESET_TIMEOUT=3e4;const SERVER_KILL_INTERRUPT_REASON="server_kill";const INVALID_TOKEN_THRESHOLD=3;class PersistentConnection extends ServerActions{constructor(repoInfo_,applicationId_,onDataUpdate_,onConnectStatus_,onServerInfoUpdate_,authTokenProvider_,appCheckTokenProvider_,authOverride_){super();this.repoInfo_=repoInfo_;this.applicationId_=applicationId_;this.onDataUpdate_=onDataUpdate_;this.onConnectStatus_=onConnectStatus_;this.onServerInfoUpdate_=onServerInfoUpdate_;this.authTokenProvider_=authTokenProvider_;this.appCheckTokenProvider_=appCheckTokenProvider_;this.authOverride_=authOverride_;this.id=PersistentConnection.nextPersistentConnectionId_++;this.log_=logWrapper("p:"+this.id+":");this.interruptReasons_={};this.listens=new Map;this.outstandingPuts_=[];this.outstandingGets_=[];this.outstandingPutCount_=0;this.outstandingGetCount_=0;this.onDisconnectRequestQueue_=[];this.connected_=false;this.reconnectDelay_=RECONNECT_MIN_DELAY;this.maxReconnectDelay_=RECONNECT_MAX_DELAY_DEFAULT;this.securityDebugCallback_=null;this.lastSessionId=null;this.establishConnectionTimer_=null;this.visible_=false;this.requestCBHash_={};this.requestNumber_=0;this.realtime_=null;this.authToken_=null;this.appCheckToken_=null;this.forceTokenRefresh_=false;this.invalidAuthTokenCount_=0;this.invalidAppCheckTokenCount_=0;this.firstConnection_=true;this.lastConnectionAttemptTime_=null;this.lastConnectionEstablishedTime_=null;if(authOverride_&&!(0,_util.isNodeSdk)()){throw new Error("Auth override specified in options, but not supported on non Node.js platforms")}VisibilityMonitor.getInstance().on("visible",this.onVisible_,this);if(repoInfo_.host.indexOf("fblocal")===-1){OnlineMonitor.getInstance().on("online",this.onOnline_,this)}}sendRequest(action,body,onResponse){const curReqNum=++this.requestNumber_;const msg={r:curReqNum,a:action,b:body};this.log_((0,_util.stringify)(msg));(0,_util.assert)(this.connected_,"sendRequest call when we're not connected not allowed.");this.realtime_.sendRequest(msg);if(onResponse){this.requestCBHash_[curReqNum]=onResponse}}get(query){this.initConnection_();const deferred=new _util.Deferred;const request={p:query._path.toString(),q:query._queryObject};const outstandingGet={action:"g",request:request,onComplete:message=>{const payload=message["d"];if(message["s"]==="ok"){deferred.resolve(payload)}else{deferred.reject(payload)}}};this.outstandingGets_.push(outstandingGet);this.outstandingGetCount_++;const index=this.outstandingGets_.length-1;if(this.connected_){this.sendGet_(index)}return deferred.promise}listen(query,currentHashFn,tag,onComplete){this.initConnection_();const queryId=query._queryIdentifier;const pathString=query._path.toString();this.log_("Listen called for "+pathString+" "+queryId);if(!this.listens.has(pathString)){this.listens.set(pathString,new Map)}(0,_util.assert)(query._queryParams.isDefault()||!query._queryParams.loadsAllData(),"listen() called for non-default but complete query");(0,_util.assert)(!this.listens.get(pathString).has(queryId),`listen() called twice for same path/queryId.`);const listenSpec={onComplete:onComplete,hashFn:currentHashFn,query:query,tag:tag};this.listens.get(pathString).set(queryId,listenSpec);if(this.connected_){this.sendListen_(listenSpec)}}sendGet_(index){const get=this.outstandingGets_[index];this.sendRequest("g",get.request,(message=>{delete this.outstandingGets_[index];this.outstandingGetCount_--;if(this.outstandingGetCount_===0){this.outstandingGets_=[]}if(get.onComplete){get.onComplete(message)}}))}sendListen_(listenSpec){const query=listenSpec.query;const pathString=query._path.toString();const queryId=query._queryIdentifier;this.log_("Listen on "+pathString+" for "+queryId);const req={p:pathString};const action="q";if(listenSpec.tag){req["q"]=query._queryObject;req["t"]=listenSpec.tag}req["h"]=listenSpec.hashFn();this.sendRequest(action,req,(message=>{const payload=message["d"];const status=message["s"];PersistentConnection.warnOnListenWarnings_(payload,query);const currentListenSpec=this.listens.get(pathString)&&this.listens.get(pathString).get(queryId);if(currentListenSpec===listenSpec){this.log_("listen response",message);if(status!=="ok"){this.removeListen_(pathString,queryId)}if(listenSpec.onComplete){listenSpec.onComplete(status,payload)}}}))}static warnOnListenWarnings_(payload,query){if(payload&&typeof payload==="object"&&(0,_util.contains)(payload,"w")){const warnings=(0,_util.safeGet)(payload,"w");if(Array.isArray(warnings)&&~warnings.indexOf("no_index")){const indexSpec='".indexOn": "'+query._queryParams.getIndex().toString()+'"';const indexPath=query._path.toString();warn(`Using an unspecified index. Your data will be downloaded and `+`filtered on the client. Consider adding ${indexSpec} at `+`${indexPath} to your security rules for better performance.`)}}}refreshAuthToken(token){this.authToken_=token;this.log_("Auth token refreshed");if(this.authToken_){this.tryAuth()}else{if(this.connected_){this.sendRequest("unauth",{},(()=>{}))}}this.reduceReconnectDelayIfAdminCredential_(token)}reduceReconnectDelayIfAdminCredential_(credential){const isFirebaseSecret=credential&&credential.length===40;if(isFirebaseSecret||(0,_util.isAdmin)(credential)){this.log_("Admin auth credential detected.  Reducing max reconnect time.");this.maxReconnectDelay_=RECONNECT_MAX_DELAY_FOR_ADMINS}}refreshAppCheckToken(token){this.appCheckToken_=token;this.log_("App check token refreshed");if(this.appCheckToken_){this.tryAppCheck()}else{if(this.connected_){this.sendRequest("unappeck",{},(()=>{}))}}}tryAuth(){if(this.connected_&&this.authToken_){const token=this.authToken_;const authMethod=(0,_util.isValidFormat)(token)?"auth":"gauth";const requestData={cred:token};if(this.authOverride_===null){requestData["noauth"]=true}else if(typeof this.authOverride_==="object"){requestData["authvar"]=this.authOverride_}this.sendRequest(authMethod,requestData,(res=>{const status=res["s"];const data=res["d"]||"error";if(this.authToken_===token){if(status==="ok"){this.invalidAuthTokenCount_=0}else{this.onAuthRevoked_(status,data)}}}))}}tryAppCheck(){if(this.connected_&&this.appCheckToken_){this.sendRequest("appcheck",{token:this.appCheckToken_},(res=>{const status=res["s"];const data=res["d"]||"error";if(status==="ok"){this.invalidAppCheckTokenCount_=0}else{this.onAppCheckRevoked_(status,data)}}))}}unlisten(query,tag){const pathString=query._path.toString();const queryId=query._queryIdentifier;this.log_("Unlisten called for "+pathString+" "+queryId);(0,_util.assert)(query._queryParams.isDefault()||!query._queryParams.loadsAllData(),"unlisten() called for non-default but complete query");const listen=this.removeListen_(pathString,queryId);if(listen&&this.connected_){this.sendUnlisten_(pathString,queryId,query._queryObject,tag)}}sendUnlisten_(pathString,queryId,queryObj,tag){this.log_("Unlisten on "+pathString+" for "+queryId);const req={p:pathString};const action="n";if(tag){req["q"]=queryObj;req["t"]=tag}this.sendRequest(action,req)}onDisconnectPut(pathString,data,onComplete){this.initConnection_();if(this.connected_){this.sendOnDisconnect_("o",pathString,data,onComplete)}else{this.onDisconnectRequestQueue_.push({pathString:pathString,action:"o",data:data,onComplete:onComplete})}}onDisconnectMerge(pathString,data,onComplete){this.initConnection_();if(this.connected_){this.sendOnDisconnect_("om",pathString,data,onComplete)}else{this.onDisconnectRequestQueue_.push({pathString:pathString,action:"om",data:data,onComplete:onComplete})}}onDisconnectCancel(pathString,onComplete){this.initConnection_();if(this.connected_){this.sendOnDisconnect_("oc",pathString,null,onComplete)}else{this.onDisconnectRequestQueue_.push({pathString:pathString,action:"oc",data:null,onComplete:onComplete})}}sendOnDisconnect_(action,pathString,data,onComplete){const request={p:pathString,d:data};this.log_("onDisconnect "+action,request);this.sendRequest(action,request,(response=>{if(onComplete){setTimeout((()=>{onComplete(response["s"],response["d"])}),Math.floor(0))}}))}put(pathString,data,onComplete,hash){this.putInternal("p",pathString,data,onComplete,hash)}merge(pathString,data,onComplete,hash){this.putInternal("m",pathString,data,onComplete,hash)}putInternal(action,pathString,data,onComplete,hash){this.initConnection_();const request={p:pathString,d:data};if(hash!==undefined){request["h"]=hash}this.outstandingPuts_.push({action:action,request:request,onComplete:onComplete});this.outstandingPutCount_++;const index=this.outstandingPuts_.length-1;if(this.connected_){this.sendPut_(index)}else{this.log_("Buffering put: "+pathString)}}sendPut_(index){const action=this.outstandingPuts_[index].action;const request=this.outstandingPuts_[index].request;const onComplete=this.outstandingPuts_[index].onComplete;this.outstandingPuts_[index].queued=this.connected_;this.sendRequest(action,request,(message=>{this.log_(action+" response",message);delete this.outstandingPuts_[index];this.outstandingPutCount_--;if(this.outstandingPutCount_===0){this.outstandingPuts_=[]}if(onComplete){onComplete(message["s"],message["d"])}}))}reportStats(stats){if(this.connected_){const request={c:stats};this.log_("reportStats",request);this.sendRequest("s",request,(result=>{const status=result["s"];if(status!=="ok"){const errorReason=result["d"];this.log_("reportStats","Error sending stats: "+errorReason)}}))}}onDataMessage_(message){if("r"in message){this.log_("from server: "+(0,_util.stringify)(message));const reqNum=message["r"];const onResponse=this.requestCBHash_[reqNum];if(onResponse){delete this.requestCBHash_[reqNum];onResponse(message["b"])}}else if("error"in message){throw"A server-side error has occurred: "+message["error"]}else if("a"in message){this.onDataPush_(message["a"],message["b"])}}onDataPush_(action,body){this.log_("handleServerMessage",action,body);if(action==="d"){this.onDataUpdate_(body["p"],body["d"],false,body["t"])}else if(action==="m"){this.onDataUpdate_(body["p"],body["d"],true,body["t"])}else if(action==="c"){this.onListenRevoked_(body["p"],body["q"])}else if(action==="ac"){this.onAuthRevoked_(body["s"],body["d"])}else if(action==="apc"){this.onAppCheckRevoked_(body["s"],body["d"])}else if(action==="sd"){this.onSecurityDebugPacket_(body)}else{error("Unrecognized action received from server: "+(0,_util.stringify)(action)+"\nAre you using the latest client?")}}onReady_(timestamp,sessionId){this.log_("connection ready");this.connected_=true;this.lastConnectionEstablishedTime_=(new Date).getTime();this.handleTimestamp_(timestamp);this.lastSessionId=sessionId;if(this.firstConnection_){this.sendConnectStats_()}this.restoreState_();this.firstConnection_=false;this.onConnectStatus_(true)}scheduleConnect_(timeout){(0,_util.assert)(!this.realtime_,"Scheduling a connect when we're already connected/ing?");if(this.establishConnectionTimer_){clearTimeout(this.establishConnectionTimer_)}this.establishConnectionTimer_=setTimeout((()=>{this.establishConnectionTimer_=null;this.establishConnection_()}),Math.floor(timeout))}initConnection_(){if(!this.realtime_&&this.firstConnection_){this.scheduleConnect_(0)}}onVisible_(visible){if(visible&&!this.visible_&&this.reconnectDelay_===this.maxReconnectDelay_){this.log_("Window became visible.  Reducing delay.");this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0)}}this.visible_=visible}onOnline_(online){if(online){this.log_("Browser went online.");this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0)}}else{this.log_("Browser went offline.  Killing connection.");if(this.realtime_){this.realtime_.close()}}}onRealtimeDisconnect_(){this.log_("data client disconnected");this.connected_=false;this.realtime_=null;this.cancelSentTransactions_();this.requestCBHash_={};if(this.shouldReconnect_()){if(!this.visible_){this.log_("Window isn't visible.  Delaying reconnect.");this.reconnectDelay_=this.maxReconnectDelay_;this.lastConnectionAttemptTime_=(new Date).getTime()}else if(this.lastConnectionEstablishedTime_){const timeSinceLastConnectSucceeded=(new Date).getTime()-this.lastConnectionEstablishedTime_;if(timeSinceLastConnectSucceeded>RECONNECT_DELAY_RESET_TIMEOUT){this.reconnectDelay_=RECONNECT_MIN_DELAY}this.lastConnectionEstablishedTime_=null}const timeSinceLastConnectAttempt=(new Date).getTime()-this.lastConnectionAttemptTime_;let reconnectDelay=Math.max(0,this.reconnectDelay_-timeSinceLastConnectAttempt);reconnectDelay=Math.random()*reconnectDelay;this.log_("Trying to reconnect in "+reconnectDelay+"ms");this.scheduleConnect_(reconnectDelay);this.reconnectDelay_=Math.min(this.maxReconnectDelay_,this.reconnectDelay_*RECONNECT_DELAY_MULTIPLIER)}this.onConnectStatus_(false)}async establishConnection_(){if(this.shouldReconnect_()){this.log_("Making a connection attempt");this.lastConnectionAttemptTime_=(new Date).getTime();this.lastConnectionEstablishedTime_=null;const onDataMessage=this.onDataMessage_.bind(this);const onReady=this.onReady_.bind(this);const onDisconnect=this.onRealtimeDisconnect_.bind(this);const connId=this.id+":"+PersistentConnection.nextConnectionId_++;const lastSessionId=this.lastSessionId;let canceled=false;let connection=null;const closeFn=function(){if(connection){connection.close()}else{canceled=true;onDisconnect()}};const sendRequestFn=function(msg){(0,_util.assert)(connection,"sendRequest call when we're not connected not allowed.");connection.sendRequest(msg)};this.realtime_={close:closeFn,sendRequest:sendRequestFn};const forceRefresh=this.forceTokenRefresh_;this.forceTokenRefresh_=false;try{const[authToken,appCheckToken]=await Promise.all([this.authTokenProvider_.getToken(forceRefresh),this.appCheckTokenProvider_.getToken(forceRefresh)]);if(!canceled){log("getToken() completed. Creating connection.");this.authToken_=authToken&&authToken.accessToken;this.appCheckToken_=appCheckToken&&appCheckToken.token;connection=new Connection(connId,this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,onDataMessage,onReady,onDisconnect,(reason=>{warn(reason+" ("+this.repoInfo_.toString()+")");this.interrupt(SERVER_KILL_INTERRUPT_REASON)}),lastSessionId)}else{log("getToken() completed but was canceled")}}catch(error){this.log_("Failed to get token: "+error);if(!canceled){if(this.repoInfo_.nodeAdmin){warn(error)}closeFn()}}}}interrupt(reason){log("Interrupting connection for reason: "+reason);this.interruptReasons_[reason]=true;if(this.realtime_){this.realtime_.close()}else{if(this.establishConnectionTimer_){clearTimeout(this.establishConnectionTimer_);this.establishConnectionTimer_=null}if(this.connected_){this.onRealtimeDisconnect_()}}}resume(reason){log("Resuming connection for reason: "+reason);delete this.interruptReasons_[reason];if((0,_util.isEmpty)(this.interruptReasons_)){this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0)}}}handleTimestamp_(timestamp){const delta=timestamp-(new Date).getTime();this.onServerInfoUpdate_({serverTimeOffset:delta})}cancelSentTransactions_(){for(let i=0;i<this.outstandingPuts_.length;i++){const put=this.outstandingPuts_[i];if(put&&"h"in put.request&&put.queued){if(put.onComplete){put.onComplete("disconnect")}delete this.outstandingPuts_[i];this.outstandingPutCount_--}}if(this.outstandingPutCount_===0){this.outstandingPuts_=[]}}onListenRevoked_(pathString,query){let queryId;if(!query){queryId="default"}else{queryId=query.map((q=>ObjectToUniqueKey(q))).join("$")}const listen=this.removeListen_(pathString,queryId);if(listen&&listen.onComplete){listen.onComplete("permission_denied")}}removeListen_(pathString,queryId){const normalizedPathString=new Path(pathString).toString();let listen;if(this.listens.has(normalizedPathString)){const map=this.listens.get(normalizedPathString);listen=map.get(queryId);map.delete(queryId);if(map.size===0){this.listens.delete(normalizedPathString)}}else{listen=undefined}return listen}onAuthRevoked_(statusCode,explanation){log("Auth token revoked: "+statusCode+"/"+explanation);this.authToken_=null;this.forceTokenRefresh_=true;this.realtime_.close();if(statusCode==="invalid_token"||statusCode==="permission_denied"){this.invalidAuthTokenCount_++;if(this.invalidAuthTokenCount_>=INVALID_TOKEN_THRESHOLD){this.reconnectDelay_=RECONNECT_MAX_DELAY_FOR_ADMINS;this.authTokenProvider_.notifyForInvalidToken()}}}onAppCheckRevoked_(statusCode,explanation){log("App check token revoked: "+statusCode+"/"+explanation);this.appCheckToken_=null;this.forceTokenRefresh_=true;if(statusCode==="invalid_token"||statusCode==="permission_denied"){this.invalidAppCheckTokenCount_++;if(this.invalidAppCheckTokenCount_>=INVALID_TOKEN_THRESHOLD){this.appCheckTokenProvider_.notifyForInvalidToken()}}}onSecurityDebugPacket_(body){if(this.securityDebugCallback_){this.securityDebugCallback_(body)}else{if("msg"in body){console.log("FIREBASE: "+body["msg"].replace("\n","\nFIREBASE: "))}}}restoreState_(){this.tryAuth();this.tryAppCheck();for(const queries of this.listens.values()){for(const listenSpec of queries.values()){this.sendListen_(listenSpec)}}for(let i=0;i<this.outstandingPuts_.length;i++){if(this.outstandingPuts_[i]){this.sendPut_(i)}}while(this.onDisconnectRequestQueue_.length){const request=this.onDisconnectRequestQueue_.shift();this.sendOnDisconnect_(request.action,request.pathString,request.data,request.onComplete)}for(let i=0;i<this.outstandingGets_.length;i++){if(this.outstandingGets_[i]){this.sendGet_(i)}}}sendConnectStats_(){const stats={};let clientName="js";if((0,_util.isNodeSdk)()){if(this.repoInfo_.nodeAdmin){clientName="admin_node"}else{clientName="node"}}stats["sdk."+clientName+"."+SDK_VERSION.replace(/\./g,"-")]=1;if((0,_util.isMobileCordova)()){stats["framework.cordova"]=1}else if((0,_util.isReactNative)()){stats["framework.reactnative"]=1}this.reportStats(stats)}shouldReconnect_(){const online=OnlineMonitor.getInstance().currentlyOnline();return(0,_util.isEmpty)(this.interruptReasons_)&&online}}PersistentConnection.nextPersistentConnectionId_=0;PersistentConnection.nextConnectionId_=0;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class NamedNode{constructor(name,node){this.name=name;this.node=node}static Wrap(name,node){return new NamedNode(name,node)}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Index{getCompare(){return this.compare.bind(this)}indexedValueChanged(oldNode,newNode){const oldWrapped=new NamedNode(MIN_NAME,oldNode);const newWrapped=new NamedNode(MIN_NAME,newNode);return this.compare(oldWrapped,newWrapped)!==0}minPost(){return NamedNode.MIN}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let __EMPTY_NODE;class KeyIndex extends Index{static get __EMPTY_NODE(){return __EMPTY_NODE}static set __EMPTY_NODE(val){__EMPTY_NODE=val}compare(a,b){return nameCompare(a.name,b.name)}isDefinedOn(node){throw(0,_util.assertionError)("KeyIndex.isDefinedOn not expected to be called.")}indexedValueChanged(oldNode,newNode){return false}minPost(){return NamedNode.MIN}maxPost(){return new NamedNode(MAX_NAME,__EMPTY_NODE)}makePost(indexValue,name){(0,_util.assert)(typeof indexValue==="string","KeyIndex indexValue must always be a string.");return new NamedNode(indexValue,__EMPTY_NODE)}toString(){return".key"}}const KEY_INDEX=new KeyIndex;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class SortedMapIterator{constructor(node,startKey,comparator,isReverse_,resultGenerator_=null){this.isReverse_=isReverse_;this.resultGenerator_=resultGenerator_;this.nodeStack_=[];let cmp=1;while(!node.isEmpty()){node=node;cmp=startKey?comparator(node.key,startKey):1;if(isReverse_){cmp*=-1}if(cmp<0){if(this.isReverse_){node=node.left}else{node=node.right}}else if(cmp===0){this.nodeStack_.push(node);break}else{this.nodeStack_.push(node);if(this.isReverse_){node=node.right}else{node=node.left}}}}getNext(){if(this.nodeStack_.length===0){return null}let node=this.nodeStack_.pop();let result;if(this.resultGenerator_){result=this.resultGenerator_(node.key,node.value)}else{result={key:node.key,value:node.value}}if(this.isReverse_){node=node.left;while(!node.isEmpty()){this.nodeStack_.push(node);node=node.right}}else{node=node.right;while(!node.isEmpty()){this.nodeStack_.push(node);node=node.left}}return result}hasNext(){return this.nodeStack_.length>0}peek(){if(this.nodeStack_.length===0){return null}const node=this.nodeStack_[this.nodeStack_.length-1];if(this.resultGenerator_){return this.resultGenerator_(node.key,node.value)}else{return{key:node.key,value:node.value}}}}class LLRBNode{constructor(key,value,color,left,right){this.key=key;this.value=value;this.color=color!=null?color:LLRBNode.RED;this.left=left!=null?left:SortedMap.EMPTY_NODE;this.right=right!=null?right:SortedMap.EMPTY_NODE}copy(key,value,color,left,right){return new LLRBNode(key!=null?key:this.key,value!=null?value:this.value,color!=null?color:this.color,left!=null?left:this.left,right!=null?right:this.right)}count(){return this.left.count()+1+this.right.count()}isEmpty(){return false}inorderTraversal(action){return this.left.inorderTraversal(action)||!!action(this.key,this.value)||this.right.inorderTraversal(action)}reverseTraversal(action){return this.right.reverseTraversal(action)||action(this.key,this.value)||this.left.reverseTraversal(action)}min_(){if(this.left.isEmpty()){return this}else{return this.left.min_()}}minKey(){return this.min_().key}maxKey(){if(this.right.isEmpty()){return this.key}else{return this.right.maxKey()}}insert(key,value,comparator){let n=this;const cmp=comparator(key,n.key);if(cmp<0){n=n.copy(null,null,null,n.left.insert(key,value,comparator),null)}else if(cmp===0){n=n.copy(null,value,null,null,null)}else{n=n.copy(null,null,null,null,n.right.insert(key,value,comparator))}return n.fixUp_()}removeMin_(){if(this.left.isEmpty()){return SortedMap.EMPTY_NODE}let n=this;if(!n.left.isRed_()&&!n.left.left.isRed_()){n=n.moveRedLeft_()}n=n.copy(null,null,null,n.left.removeMin_(),null);return n.fixUp_()}remove(key,comparator){let n,smallest;n=this;if(comparator(key,n.key)<0){if(!n.left.isEmpty()&&!n.left.isRed_()&&!n.left.left.isRed_()){n=n.moveRedLeft_()}n=n.copy(null,null,null,n.left.remove(key,comparator),null)}else{if(n.left.isRed_()){n=n.rotateRight_()}if(!n.right.isEmpty()&&!n.right.isRed_()&&!n.right.left.isRed_()){n=n.moveRedRight_()}if(comparator(key,n.key)===0){if(n.right.isEmpty()){return SortedMap.EMPTY_NODE}else{smallest=n.right.min_();n=n.copy(smallest.key,smallest.value,null,null,n.right.removeMin_())}}n=n.copy(null,null,null,null,n.right.remove(key,comparator))}return n.fixUp_()}isRed_(){return this.color}fixUp_(){let n=this;if(n.right.isRed_()&&!n.left.isRed_()){n=n.rotateLeft_()}if(n.left.isRed_()&&n.left.left.isRed_()){n=n.rotateRight_()}if(n.left.isRed_()&&n.right.isRed_()){n=n.colorFlip_()}return n}moveRedLeft_(){let n=this.colorFlip_();if(n.right.left.isRed_()){n=n.copy(null,null,null,null,n.right.rotateRight_());n=n.rotateLeft_();n=n.colorFlip_()}return n}moveRedRight_(){let n=this.colorFlip_();if(n.left.left.isRed_()){n=n.rotateRight_();n=n.colorFlip_()}return n}rotateLeft_(){const nl=this.copy(null,null,LLRBNode.RED,null,this.right.left);return this.right.copy(null,null,this.color,nl,null)}rotateRight_(){const nr=this.copy(null,null,LLRBNode.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,nr)}colorFlip_(){const left=this.left.copy(null,null,!this.left.color,null,null);const right=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,left,right)}checkMaxDepth_(){const blackDepth=this.check_();return Math.pow(2,blackDepth)<=this.count()+1}check_(){if(this.isRed_()&&this.left.isRed_()){throw new Error("Red node has red child("+this.key+","+this.value+")")}if(this.right.isRed_()){throw new Error("Right child of ("+this.key+","+this.value+") is red")}const blackDepth=this.left.check_();if(blackDepth!==this.right.check_()){throw new Error("Black depths differ")}else{return blackDepth+(this.isRed_()?0:1)}}}LLRBNode.RED=true;LLRBNode.BLACK=false;class LLRBEmptyNode{copy(key,value,color,left,right){return this}insert(key,value,comparator){return new LLRBNode(key,value,null)}remove(key,comparator){return this}count(){return 0}isEmpty(){return true}inorderTraversal(action){return false}reverseTraversal(action){return false}minKey(){return null}maxKey(){return null}check_(){return 0}isRed_(){return false}}class SortedMap{constructor(comparator_,root_=SortedMap.EMPTY_NODE){this.comparator_=comparator_;this.root_=root_}insert(key,value){return new SortedMap(this.comparator_,this.root_.insert(key,value,this.comparator_).copy(null,null,LLRBNode.BLACK,null,null))}remove(key){return new SortedMap(this.comparator_,this.root_.remove(key,this.comparator_).copy(null,null,LLRBNode.BLACK,null,null))}get(key){let cmp;let node=this.root_;while(!node.isEmpty()){cmp=this.comparator_(key,node.key);if(cmp===0){return node.value}else if(cmp<0){node=node.left}else if(cmp>0){node=node.right}}return null}getPredecessorKey(key){let cmp,node=this.root_,rightParent=null;while(!node.isEmpty()){cmp=this.comparator_(key,node.key);if(cmp===0){if(!node.left.isEmpty()){node=node.left;while(!node.right.isEmpty()){node=node.right}return node.key}else if(rightParent){return rightParent.key}else{return null}}else if(cmp<0){node=node.left}else if(cmp>0){rightParent=node;node=node.right}}throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?")}isEmpty(){return this.root_.isEmpty()}count(){return this.root_.count()}minKey(){return this.root_.minKey()}maxKey(){return this.root_.maxKey()}inorderTraversal(action){return this.root_.inorderTraversal(action)}reverseTraversal(action){return this.root_.reverseTraversal(action)}getIterator(resultGenerator){return new SortedMapIterator(this.root_,null,this.comparator_,false,resultGenerator)}getIteratorFrom(key,resultGenerator){return new SortedMapIterator(this.root_,key,this.comparator_,false,resultGenerator)}getReverseIteratorFrom(key,resultGenerator){return new SortedMapIterator(this.root_,key,this.comparator_,true,resultGenerator)}getReverseIterator(resultGenerator){return new SortedMapIterator(this.root_,null,this.comparator_,true,resultGenerator)}}SortedMap.EMPTY_NODE=new LLRBEmptyNode;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function NAME_ONLY_COMPARATOR(left,right){return nameCompare(left.name,right.name)}function NAME_COMPARATOR(left,right){return nameCompare(left,right)}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let MAX_NODE$2;function setMaxNode$1(val){MAX_NODE$2=val}const priorityHashText=function(priority){if(typeof priority==="number"){return"number:"+doubleToIEEE754String(priority)}else{return"string:"+priority}};const validatePriorityNode=function(priorityNode){if(priorityNode.isLeafNode()){const val=priorityNode.val();(0,_util.assert)(typeof val==="string"||typeof val==="number"||typeof val==="object"&&(0,_util.contains)(val,".sv"),"Priority must be a string or number.")}else{(0,_util.assert)(priorityNode===MAX_NODE$2||priorityNode.isEmpty(),"priority of unexpected type.")}(0,_util.assert)(priorityNode===MAX_NODE$2||priorityNode.getPriority().isEmpty(),"Priority nodes can't have a priority of their own.")};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let __childrenNodeConstructor;class LeafNode{constructor(value_,priorityNode_=LeafNode.__childrenNodeConstructor.EMPTY_NODE){this.value_=value_;this.priorityNode_=priorityNode_;this.lazyHash_=null;(0,_util.assert)(this.value_!==undefined&&this.value_!==null,"LeafNode shouldn't be created with null/undefined value.");validatePriorityNode(this.priorityNode_)}static set __childrenNodeConstructor(val){__childrenNodeConstructor=val}static get __childrenNodeConstructor(){return __childrenNodeConstructor}isLeafNode(){return true}getPriority(){return this.priorityNode_}updatePriority(newPriorityNode){return new LeafNode(this.value_,newPriorityNode)}getImmediateChild(childName){if(childName===".priority"){return this.priorityNode_}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE}}getChild(path){if(pathIsEmpty(path)){return this}else if(pathGetFront(path)===".priority"){return this.priorityNode_}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE}}hasChild(){return false}getPredecessorChildName(childName,childNode){return null}updateImmediateChild(childName,newChildNode){if(childName===".priority"){return this.updatePriority(newChildNode)}else if(newChildNode.isEmpty()&&childName!==".priority"){return this}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName,newChildNode).updatePriority(this.priorityNode_)}}updateChild(path,newChildNode){const front=pathGetFront(path);if(front===null){return newChildNode}else if(newChildNode.isEmpty()&&front!==".priority"){return this}else{(0,_util.assert)(front!==".priority"||pathGetLength(path)===1,".priority must be the last token in a path");return this.updateImmediateChild(front,LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path),newChildNode))}}isEmpty(){return false}numChildren(){return 0}forEachChild(index,action){return false}val(exportFormat){if(exportFormat&&!this.getPriority().isEmpty()){return{".value":this.getValue(),".priority":this.getPriority().val()}}else{return this.getValue()}}hash(){if(this.lazyHash_===null){let toHash="";if(!this.priorityNode_.isEmpty()){toHash+="priority:"+priorityHashText(this.priorityNode_.val())+":"}const type=typeof this.value_;toHash+=type+":";if(type==="number"){toHash+=doubleToIEEE754String(this.value_)}else{toHash+=this.value_}this.lazyHash_=sha1(toHash)}return this.lazyHash_}getValue(){return this.value_}compareTo(other){if(other===LeafNode.__childrenNodeConstructor.EMPTY_NODE){return 1}else if(other instanceof LeafNode.__childrenNodeConstructor){return-1}else{(0,_util.assert)(other.isLeafNode(),"Unknown node type");return this.compareToLeafNode_(other)}}compareToLeafNode_(otherLeaf){const otherLeafType=typeof otherLeaf.value_;const thisLeafType=typeof this.value_;const otherIndex=LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);const thisIndex=LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);(0,_util.assert)(otherIndex>=0,"Unknown leaf type: "+otherLeafType);(0,_util.assert)(thisIndex>=0,"Unknown leaf type: "+thisLeafType);if(otherIndex===thisIndex){if(thisLeafType==="object"){return 0}else{if(this.value_<otherLeaf.value_){return-1}else if(this.value_===otherLeaf.value_){return 0}else{return 1}}}else{return thisIndex-otherIndex}}withIndex(){return this}isIndexed(){return true}equals(other){if(other===this){return true}else if(other.isLeafNode()){const otherLeaf=other;return this.value_===otherLeaf.value_&&this.priorityNode_.equals(otherLeaf.priorityNode_)}else{return false}}}LeafNode.VALUE_TYPE_ORDER=["object","boolean","number","string"];
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let nodeFromJSON$1;let MAX_NODE$1;function setNodeFromJSON(val){nodeFromJSON$1=val}function setMaxNode(val){MAX_NODE$1=val}class PriorityIndex extends Index{compare(a,b){const aPriority=a.node.getPriority();const bPriority=b.node.getPriority();const indexCmp=aPriority.compareTo(bPriority);if(indexCmp===0){return nameCompare(a.name,b.name)}else{return indexCmp}}isDefinedOn(node){return!node.getPriority().isEmpty()}indexedValueChanged(oldNode,newNode){return!oldNode.getPriority().equals(newNode.getPriority())}minPost(){return NamedNode.MIN}maxPost(){return new NamedNode(MAX_NAME,new LeafNode("[PRIORITY-POST]",MAX_NODE$1))}makePost(indexValue,name){const priorityNode=nodeFromJSON$1(indexValue);return new NamedNode(name,new LeafNode("[PRIORITY-POST]",priorityNode))}toString(){return".priority"}}const PRIORITY_INDEX=new PriorityIndex;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const LOG_2=Math.log(2);class Base12Num{constructor(length){const logBase2=num=>parseInt(Math.log(num)/LOG_2,10);const bitMask=bits=>parseInt(Array(bits+1).join("1"),2);this.count=logBase2(length+1);this.current_=this.count-1;const mask=bitMask(this.count);this.bits_=length+1&mask}nextBitIsOne(){const result=!(this.bits_&1<<this.current_);this.current_--;return result}}const buildChildSet=function(childList,cmp,keyFn,mapSortFn){childList.sort(cmp);const buildBalancedTree=function(low,high){const length=high-low;let namedNode;let key;if(length===0){return null}else if(length===1){namedNode=childList[low];key=keyFn?keyFn(namedNode):namedNode;return new LLRBNode(key,namedNode.node,LLRBNode.BLACK,null,null)}else{const middle=parseInt(length/2,10)+low;const left=buildBalancedTree(low,middle);const right=buildBalancedTree(middle+1,high);namedNode=childList[middle];key=keyFn?keyFn(namedNode):namedNode;return new LLRBNode(key,namedNode.node,LLRBNode.BLACK,left,right)}};const buildFrom12Array=function(base12){let node=null;let root=null;let index=childList.length;const buildPennant=function(chunkSize,color){const low=index-chunkSize;const high=index;index-=chunkSize;const childTree=buildBalancedTree(low+1,high);const namedNode=childList[low];const key=keyFn?keyFn(namedNode):namedNode;attachPennant(new LLRBNode(key,namedNode.node,color,null,childTree))};const attachPennant=function(pennant){if(node){node.left=pennant;node=pennant}else{root=pennant;node=pennant}};for(let i=0;i<base12.count;++i){const isOne=base12.nextBitIsOne();const chunkSize=Math.pow(2,base12.count-(i+1));if(isOne){buildPennant(chunkSize,LLRBNode.BLACK)}else{buildPennant(chunkSize,LLRBNode.BLACK);buildPennant(chunkSize,LLRBNode.RED)}}return root};const base12=new Base12Num(childList.length);const root=buildFrom12Array(base12);return new SortedMap(mapSortFn||cmp,root)};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let _defaultIndexMap;const fallbackObject={};class IndexMap{constructor(indexes_,indexSet_){this.indexes_=indexes_;this.indexSet_=indexSet_}static get Default(){(0,_util.assert)(fallbackObject&&PRIORITY_INDEX,"ChildrenNode.ts has not been loaded");_defaultIndexMap=_defaultIndexMap||new IndexMap({".priority":fallbackObject},{".priority":PRIORITY_INDEX});return _defaultIndexMap}get(indexKey){const sortedMap=(0,_util.safeGet)(this.indexes_,indexKey);if(!sortedMap){throw new Error("No index defined for "+indexKey)}if(sortedMap instanceof SortedMap){return sortedMap}else{return null}}hasIndex(indexDefinition){return(0,_util.contains)(this.indexSet_,indexDefinition.toString())}addIndex(indexDefinition,existingChildren){(0,_util.assert)(indexDefinition!==KEY_INDEX,"KeyIndex always exists and isn't meant to be added to the IndexMap.");const childList=[];let sawIndexedValue=false;const iter=existingChildren.getIterator(NamedNode.Wrap);let next=iter.getNext();while(next){sawIndexedValue=sawIndexedValue||indexDefinition.isDefinedOn(next.node);childList.push(next);next=iter.getNext()}let newIndex;if(sawIndexedValue){newIndex=buildChildSet(childList,indexDefinition.getCompare())}else{newIndex=fallbackObject}const indexName=indexDefinition.toString();const newIndexSet=Object.assign({},this.indexSet_);newIndexSet[indexName]=indexDefinition;const newIndexes=Object.assign({},this.indexes_);newIndexes[indexName]=newIndex;return new IndexMap(newIndexes,newIndexSet)}addToIndexes(namedNode,existingChildren){const newIndexes=(0,_util.map)(this.indexes_,((indexedChildren,indexName)=>{const index=(0,_util.safeGet)(this.indexSet_,indexName);(0,_util.assert)(index,"Missing index implementation for "+indexName);if(indexedChildren===fallbackObject){if(index.isDefinedOn(namedNode.node)){const childList=[];const iter=existingChildren.getIterator(NamedNode.Wrap);let next=iter.getNext();while(next){if(next.name!==namedNode.name){childList.push(next)}next=iter.getNext()}childList.push(namedNode);return buildChildSet(childList,index.getCompare())}else{return fallbackObject}}else{const existingSnap=existingChildren.get(namedNode.name);let newChildren=indexedChildren;if(existingSnap){newChildren=newChildren.remove(new NamedNode(namedNode.name,existingSnap))}return newChildren.insert(namedNode,namedNode.node)}}));return new IndexMap(newIndexes,this.indexSet_)}removeFromIndexes(namedNode,existingChildren){const newIndexes=(0,_util.map)(this.indexes_,(indexedChildren=>{if(indexedChildren===fallbackObject){return indexedChildren}else{const existingSnap=existingChildren.get(namedNode.name);if(existingSnap){return indexedChildren.remove(new NamedNode(namedNode.name,existingSnap))}else{return indexedChildren}}}));return new IndexMap(newIndexes,this.indexSet_)}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let EMPTY_NODE;class ChildrenNode{constructor(children_,priorityNode_,indexMap_){this.children_=children_;this.priorityNode_=priorityNode_;this.indexMap_=indexMap_;this.lazyHash_=null;if(this.priorityNode_){validatePriorityNode(this.priorityNode_)}if(this.children_.isEmpty()){(0,_util.assert)(!this.priorityNode_||this.priorityNode_.isEmpty(),"An empty node cannot have a priority")}}static get EMPTY_NODE(){return EMPTY_NODE||(EMPTY_NODE=new ChildrenNode(new SortedMap(NAME_COMPARATOR),null,IndexMap.Default))}isLeafNode(){return false}getPriority(){return this.priorityNode_||EMPTY_NODE}updatePriority(newPriorityNode){if(this.children_.isEmpty()){return this}else{return new ChildrenNode(this.children_,newPriorityNode,this.indexMap_)}}getImmediateChild(childName){if(childName===".priority"){return this.getPriority()}else{const child=this.children_.get(childName);return child===null?EMPTY_NODE:child}}getChild(path){const front=pathGetFront(path);if(front===null){return this}return this.getImmediateChild(front).getChild(pathPopFront(path))}hasChild(childName){return this.children_.get(childName)!==null}updateImmediateChild(childName,newChildNode){(0,_util.assert)(newChildNode,"We should always be passing snapshot nodes");if(childName===".priority"){return this.updatePriority(newChildNode)}else{const namedNode=new NamedNode(childName,newChildNode);let newChildren,newIndexMap;if(newChildNode.isEmpty()){newChildren=this.children_.remove(childName);newIndexMap=this.indexMap_.removeFromIndexes(namedNode,this.children_)}else{newChildren=this.children_.insert(childName,newChildNode);newIndexMap=this.indexMap_.addToIndexes(namedNode,this.children_)}const newPriority=newChildren.isEmpty()?EMPTY_NODE:this.priorityNode_;return new ChildrenNode(newChildren,newPriority,newIndexMap)}}updateChild(path,newChildNode){const front=pathGetFront(path);if(front===null){return newChildNode}else{(0,_util.assert)(pathGetFront(path)!==".priority"||pathGetLength(path)===1,".priority must be the last token in a path");const newImmediateChild=this.getImmediateChild(front).updateChild(pathPopFront(path),newChildNode);return this.updateImmediateChild(front,newImmediateChild)}}isEmpty(){return this.children_.isEmpty()}numChildren(){return this.children_.count()}val(exportFormat){if(this.isEmpty()){return null}const obj={};let numKeys=0,maxKey=0,allIntegerKeys=true;this.forEachChild(PRIORITY_INDEX,((key,childNode)=>{obj[key]=childNode.val(exportFormat);numKeys++;if(allIntegerKeys&&ChildrenNode.INTEGER_REGEXP_.test(key)){maxKey=Math.max(maxKey,Number(key))}else{allIntegerKeys=false}}));if(!exportFormat&&allIntegerKeys&&maxKey<2*numKeys){const array=[];for(const key in obj){array[key]=obj[key]}return array}else{if(exportFormat&&!this.getPriority().isEmpty()){obj[".priority"]=this.getPriority().val()}return obj}}hash(){if(this.lazyHash_===null){let toHash="";if(!this.getPriority().isEmpty()){toHash+="priority:"+priorityHashText(this.getPriority().val())+":"}this.forEachChild(PRIORITY_INDEX,((key,childNode)=>{const childHash=childNode.hash();if(childHash!==""){toHash+=":"+key+":"+childHash}}));this.lazyHash_=toHash===""?"":sha1(toHash)}return this.lazyHash_}getPredecessorChildName(childName,childNode,index){const idx=this.resolveIndex_(index);if(idx){const predecessor=idx.getPredecessorKey(new NamedNode(childName,childNode));return predecessor?predecessor.name:null}else{return this.children_.getPredecessorKey(childName)}}getFirstChildName(indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){const minKey=idx.minKey();return minKey&&minKey.name}else{return this.children_.minKey()}}getFirstChild(indexDefinition){const minKey=this.getFirstChildName(indexDefinition);if(minKey){return new NamedNode(minKey,this.children_.get(minKey))}else{return null}}getLastChildName(indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){const maxKey=idx.maxKey();return maxKey&&maxKey.name}else{return this.children_.maxKey()}}getLastChild(indexDefinition){const maxKey=this.getLastChildName(indexDefinition);if(maxKey){return new NamedNode(maxKey,this.children_.get(maxKey))}else{return null}}forEachChild(index,action){const idx=this.resolveIndex_(index);if(idx){return idx.inorderTraversal((wrappedNode=>action(wrappedNode.name,wrappedNode.node)))}else{return this.children_.inorderTraversal(action)}}getIterator(indexDefinition){return this.getIteratorFrom(indexDefinition.minPost(),indexDefinition)}getIteratorFrom(startPost,indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){return idx.getIteratorFrom(startPost,(key=>key))}else{const iterator=this.children_.getIteratorFrom(startPost.name,NamedNode.Wrap);let next=iterator.peek();while(next!=null&&indexDefinition.compare(next,startPost)<0){iterator.getNext();next=iterator.peek()}return iterator}}getReverseIterator(indexDefinition){return this.getReverseIteratorFrom(indexDefinition.maxPost(),indexDefinition)}getReverseIteratorFrom(endPost,indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){return idx.getReverseIteratorFrom(endPost,(key=>key))}else{const iterator=this.children_.getReverseIteratorFrom(endPost.name,NamedNode.Wrap);let next=iterator.peek();while(next!=null&&indexDefinition.compare(next,endPost)>0){iterator.getNext();next=iterator.peek()}return iterator}}compareTo(other){if(this.isEmpty()){if(other.isEmpty()){return 0}else{return-1}}else if(other.isLeafNode()||other.isEmpty()){return 1}else if(other===MAX_NODE){return-1}else{return 0}}withIndex(indexDefinition){if(indexDefinition===KEY_INDEX||this.indexMap_.hasIndex(indexDefinition)){return this}else{const newIndexMap=this.indexMap_.addIndex(indexDefinition,this.children_);return new ChildrenNode(this.children_,this.priorityNode_,newIndexMap)}}isIndexed(index){return index===KEY_INDEX||this.indexMap_.hasIndex(index)}equals(other){if(other===this){return true}else if(other.isLeafNode()){return false}else{const otherChildrenNode=other;if(!this.getPriority().equals(otherChildrenNode.getPriority())){return false}else if(this.children_.count()===otherChildrenNode.children_.count()){const thisIter=this.getIterator(PRIORITY_INDEX);const otherIter=otherChildrenNode.getIterator(PRIORITY_INDEX);let thisCurrent=thisIter.getNext();let otherCurrent=otherIter.getNext();while(thisCurrent&&otherCurrent){if(thisCurrent.name!==otherCurrent.name||!thisCurrent.node.equals(otherCurrent.node)){return false}thisCurrent=thisIter.getNext();otherCurrent=otherIter.getNext()}return thisCurrent===null&&otherCurrent===null}else{return false}}}resolveIndex_(indexDefinition){if(indexDefinition===KEY_INDEX){return null}else{return this.indexMap_.get(indexDefinition.toString())}}}ChildrenNode.INTEGER_REGEXP_=/^(0|[1-9]\d*)$/;class MaxNode extends ChildrenNode{constructor(){super(new SortedMap(NAME_COMPARATOR),ChildrenNode.EMPTY_NODE,IndexMap.Default)}compareTo(other){if(other===this){return 0}else{return 1}}equals(other){return other===this}getPriority(){return this}getImmediateChild(childName){return ChildrenNode.EMPTY_NODE}isEmpty(){return false}}const MAX_NODE=new MaxNode;Object.defineProperties(NamedNode,{MIN:{value:new NamedNode(MIN_NAME,ChildrenNode.EMPTY_NODE)},MAX:{value:new NamedNode(MAX_NAME,MAX_NODE)}});KeyIndex.__EMPTY_NODE=ChildrenNode.EMPTY_NODE;LeafNode.__childrenNodeConstructor=ChildrenNode;setMaxNode$1(MAX_NODE);setMaxNode(MAX_NODE);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const USE_HINZE=true;function nodeFromJSON(json,priority=null){if(json===null){return ChildrenNode.EMPTY_NODE}if(typeof json==="object"&&".priority"in json){priority=json[".priority"]}(0,_util.assert)(priority===null||typeof priority==="string"||typeof priority==="number"||typeof priority==="object"&&".sv"in priority,"Invalid priority type found: "+typeof priority);if(typeof json==="object"&&".value"in json&&json[".value"]!==null){json=json[".value"]}if(typeof json!=="object"||".sv"in json){const jsonLeaf=json;return new LeafNode(jsonLeaf,nodeFromJSON(priority))}if(!(json instanceof Array)&&USE_HINZE){const children=[];let childrenHavePriority=false;const hinzeJsonObj=json;each(hinzeJsonObj,((key,child)=>{if(key.substring(0,1)!=="."){const childNode=nodeFromJSON(child);if(!childNode.isEmpty()){childrenHavePriority=childrenHavePriority||!childNode.getPriority().isEmpty();children.push(new NamedNode(key,childNode))}}}));if(children.length===0){return ChildrenNode.EMPTY_NODE}const childSet=buildChildSet(children,NAME_ONLY_COMPARATOR,(namedNode=>namedNode.name),NAME_COMPARATOR);if(childrenHavePriority){const sortedChildSet=buildChildSet(children,PRIORITY_INDEX.getCompare());return new ChildrenNode(childSet,nodeFromJSON(priority),new IndexMap({".priority":sortedChildSet},{".priority":PRIORITY_INDEX}))}else{return new ChildrenNode(childSet,nodeFromJSON(priority),IndexMap.Default)}}else{let node=ChildrenNode.EMPTY_NODE;each(json,((key,childData)=>{if((0,_util.contains)(json,key)){if(key.substring(0,1)!=="."){const childNode=nodeFromJSON(childData);if(childNode.isLeafNode()||!childNode.isEmpty()){node=node.updateImmediateChild(key,childNode)}}}}));return node.updatePriority(nodeFromJSON(priority))}}setNodeFromJSON(nodeFromJSON);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class PathIndex extends Index{constructor(indexPath_){super();this.indexPath_=indexPath_;(0,_util.assert)(!pathIsEmpty(indexPath_)&&pathGetFront(indexPath_)!==".priority","Can't create PathIndex with empty path or .priority key")}extractChild(snap){return snap.getChild(this.indexPath_)}isDefinedOn(node){return!node.getChild(this.indexPath_).isEmpty()}compare(a,b){const aChild=this.extractChild(a.node);const bChild=this.extractChild(b.node);const indexCmp=aChild.compareTo(bChild);if(indexCmp===0){return nameCompare(a.name,b.name)}else{return indexCmp}}makePost(indexValue,name){const valueNode=nodeFromJSON(indexValue);const node=ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_,valueNode);return new NamedNode(name,node)}maxPost(){const node=ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_,MAX_NODE);return new NamedNode(MAX_NAME,node)}toString(){return pathSlice(this.indexPath_,0).join("/")}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ValueIndex extends Index{compare(a,b){const indexCmp=a.node.compareTo(b.node);if(indexCmp===0){return nameCompare(a.name,b.name)}else{return indexCmp}}isDefinedOn(node){return true}indexedValueChanged(oldNode,newNode){return!oldNode.equals(newNode)}minPost(){return NamedNode.MIN}maxPost(){return NamedNode.MAX}makePost(indexValue,name){const valueNode=nodeFromJSON(indexValue);return new NamedNode(name,valueNode)}toString(){return".value"}}const VALUE_INDEX=new ValueIndex;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function changeValue(snapshotNode){return{type:"value",snapshotNode:snapshotNode}}function changeChildAdded(childName,snapshotNode){return{type:"child_added",snapshotNode:snapshotNode,childName:childName}}function changeChildRemoved(childName,snapshotNode){return{type:"child_removed",snapshotNode:snapshotNode,childName:childName}}function changeChildChanged(childName,snapshotNode,oldSnap){return{type:"child_changed",snapshotNode:snapshotNode,childName:childName,oldSnap:oldSnap}}function changeChildMoved(childName,snapshotNode){return{type:"child_moved",snapshotNode:snapshotNode,childName:childName}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class IndexedFilter{constructor(index_){this.index_=index_}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){(0,_util.assert)(snap.isIndexed(this.index_),"A node must be indexed if only a child is updated");const oldChild=snap.getImmediateChild(key);if(oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))){if(oldChild.isEmpty()===newChild.isEmpty()){return snap}}if(optChangeAccumulator!=null){if(newChild.isEmpty()){if(snap.hasChild(key)){optChangeAccumulator.trackChildChange(changeChildRemoved(key,oldChild))}else{(0,_util.assert)(snap.isLeafNode(),"A child remove without an old child only makes sense on a leaf node")}}else if(oldChild.isEmpty()){optChangeAccumulator.trackChildChange(changeChildAdded(key,newChild))}else{optChangeAccumulator.trackChildChange(changeChildChanged(key,newChild,oldChild))}}if(snap.isLeafNode()&&newChild.isEmpty()){return snap}else{return snap.updateImmediateChild(key,newChild).withIndex(this.index_)}}updateFullNode(oldSnap,newSnap,optChangeAccumulator){if(optChangeAccumulator!=null){if(!oldSnap.isLeafNode()){oldSnap.forEachChild(PRIORITY_INDEX,((key,childNode)=>{if(!newSnap.hasChild(key)){optChangeAccumulator.trackChildChange(changeChildRemoved(key,childNode))}}))}if(!newSnap.isLeafNode()){newSnap.forEachChild(PRIORITY_INDEX,((key,childNode)=>{if(oldSnap.hasChild(key)){const oldChild=oldSnap.getImmediateChild(key);if(!oldChild.equals(childNode)){optChangeAccumulator.trackChildChange(changeChildChanged(key,childNode,oldChild))}}else{optChangeAccumulator.trackChildChange(changeChildAdded(key,childNode))}}))}}return newSnap.withIndex(this.index_)}updatePriority(oldSnap,newPriority){if(oldSnap.isEmpty()){return ChildrenNode.EMPTY_NODE}else{return oldSnap.updatePriority(newPriority)}}filtersNodes(){return false}getIndexedFilter(){return this}getIndex(){return this.index_}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class RangedFilter{constructor(params){this.indexedFilter_=new IndexedFilter(params.getIndex());this.index_=params.getIndex();this.startPost_=RangedFilter.getStartPost_(params);this.endPost_=RangedFilter.getEndPost_(params);this.startIsInclusive_=!params.startAfterSet_;this.endIsInclusive_=!params.endBeforeSet_}getStartPost(){return this.startPost_}getEndPost(){return this.endPost_}matches(node){const isWithinStart=this.startIsInclusive_?this.index_.compare(this.getStartPost(),node)<=0:this.index_.compare(this.getStartPost(),node)<0;const isWithinEnd=this.endIsInclusive_?this.index_.compare(node,this.getEndPost())<=0:this.index_.compare(node,this.getEndPost())<0;return isWithinStart&&isWithinEnd}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){if(!this.matches(new NamedNode(key,newChild))){newChild=ChildrenNode.EMPTY_NODE}return this.indexedFilter_.updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator)}updateFullNode(oldSnap,newSnap,optChangeAccumulator){if(newSnap.isLeafNode()){newSnap=ChildrenNode.EMPTY_NODE}let filtered=newSnap.withIndex(this.index_);filtered=filtered.updatePriority(ChildrenNode.EMPTY_NODE);const self=this;newSnap.forEachChild(PRIORITY_INDEX,((key,childNode)=>{if(!self.matches(new NamedNode(key,childNode))){filtered=filtered.updateImmediateChild(key,ChildrenNode.EMPTY_NODE)}}));return this.indexedFilter_.updateFullNode(oldSnap,filtered,optChangeAccumulator)}updatePriority(oldSnap,newPriority){return oldSnap}filtersNodes(){return true}getIndexedFilter(){return this.indexedFilter_}getIndex(){return this.index_}static getStartPost_(params){if(params.hasStart()){const startName=params.getIndexStartName();return params.getIndex().makePost(params.getIndexStartValue(),startName)}else{return params.getIndex().minPost()}}static getEndPost_(params){if(params.hasEnd()){const endName=params.getIndexEndName();return params.getIndex().makePost(params.getIndexEndValue(),endName)}else{return params.getIndex().maxPost()}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class LimitedFilter{constructor(params){this.withinDirectionalStart=node=>this.reverse_?this.withinEndPost(node):this.withinStartPost(node);this.withinDirectionalEnd=node=>this.reverse_?this.withinStartPost(node):this.withinEndPost(node);this.withinStartPost=node=>{const compareRes=this.index_.compare(this.rangedFilter_.getStartPost(),node);return this.startIsInclusive_?compareRes<=0:compareRes<0};this.withinEndPost=node=>{const compareRes=this.index_.compare(node,this.rangedFilter_.getEndPost());return this.endIsInclusive_?compareRes<=0:compareRes<0};this.rangedFilter_=new RangedFilter(params);this.index_=params.getIndex();this.limit_=params.getLimit();this.reverse_=!params.isViewFromLeft();this.startIsInclusive_=!params.startAfterSet_;this.endIsInclusive_=!params.endBeforeSet_}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){if(!this.rangedFilter_.matches(new NamedNode(key,newChild))){newChild=ChildrenNode.EMPTY_NODE}if(snap.getImmediateChild(key).equals(newChild)){return snap}else if(snap.numChildren()<this.limit_){return this.rangedFilter_.getIndexedFilter().updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator)}else{return this.fullLimitUpdateChild_(snap,key,newChild,source,optChangeAccumulator)}}updateFullNode(oldSnap,newSnap,optChangeAccumulator){let filtered;if(newSnap.isLeafNode()||newSnap.isEmpty()){filtered=ChildrenNode.EMPTY_NODE.withIndex(this.index_)}else{if(this.limit_*2<newSnap.numChildren()&&newSnap.isIndexed(this.index_)){filtered=ChildrenNode.EMPTY_NODE.withIndex(this.index_);let iterator;if(this.reverse_){iterator=newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(),this.index_)}else{iterator=newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(),this.index_)}let count=0;while(iterator.hasNext()&&count<this.limit_){const next=iterator.getNext();if(!this.withinDirectionalStart(next)){continue}else if(!this.withinDirectionalEnd(next)){break}else{filtered=filtered.updateImmediateChild(next.name,next.node);count++}}}else{filtered=newSnap.withIndex(this.index_);filtered=filtered.updatePriority(ChildrenNode.EMPTY_NODE);let iterator;if(this.reverse_){iterator=filtered.getReverseIterator(this.index_)}else{iterator=filtered.getIterator(this.index_)}let count=0;while(iterator.hasNext()){const next=iterator.getNext();const inRange=count<this.limit_&&this.withinDirectionalStart(next)&&this.withinDirectionalEnd(next);if(inRange){count++}else{filtered=filtered.updateImmediateChild(next.name,ChildrenNode.EMPTY_NODE)}}}}return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap,filtered,optChangeAccumulator)}updatePriority(oldSnap,newPriority){return oldSnap}filtersNodes(){return true}getIndexedFilter(){return this.rangedFilter_.getIndexedFilter()}getIndex(){return this.index_}fullLimitUpdateChild_(snap,childKey,childSnap,source,changeAccumulator){let cmp;if(this.reverse_){const indexCmp=this.index_.getCompare();cmp=(a,b)=>indexCmp(b,a)}else{cmp=this.index_.getCompare()}const oldEventCache=snap;(0,_util.assert)(oldEventCache.numChildren()===this.limit_,"");const newChildNamedNode=new NamedNode(childKey,childSnap);const windowBoundary=this.reverse_?oldEventCache.getFirstChild(this.index_):oldEventCache.getLastChild(this.index_);const inRange=this.rangedFilter_.matches(newChildNamedNode);if(oldEventCache.hasChild(childKey)){const oldChildSnap=oldEventCache.getImmediateChild(childKey);let nextChild=source.getChildAfterChild(this.index_,windowBoundary,this.reverse_);while(nextChild!=null&&(nextChild.name===childKey||oldEventCache.hasChild(nextChild.name))){nextChild=source.getChildAfterChild(this.index_,nextChild,this.reverse_)}const compareNext=nextChild==null?1:cmp(nextChild,newChildNamedNode);const remainsInWindow=inRange&&!childSnap.isEmpty()&&compareNext>=0;if(remainsInWindow){if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildChanged(childKey,childSnap,oldChildSnap))}return oldEventCache.updateImmediateChild(childKey,childSnap)}else{if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildRemoved(childKey,oldChildSnap))}const newEventCache=oldEventCache.updateImmediateChild(childKey,ChildrenNode.EMPTY_NODE);const nextChildInRange=nextChild!=null&&this.rangedFilter_.matches(nextChild);if(nextChildInRange){if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildAdded(nextChild.name,nextChild.node))}return newEventCache.updateImmediateChild(nextChild.name,nextChild.node)}else{return newEventCache}}}else if(childSnap.isEmpty()){return snap}else if(inRange){if(cmp(windowBoundary,newChildNamedNode)>=0){if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name,windowBoundary.node));changeAccumulator.trackChildChange(changeChildAdded(childKey,childSnap))}return oldEventCache.updateImmediateChild(childKey,childSnap).updateImmediateChild(windowBoundary.name,ChildrenNode.EMPTY_NODE)}else{return snap}}else{return snap}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class QueryParams{constructor(){this.limitSet_=false;this.startSet_=false;this.startNameSet_=false;this.startAfterSet_=false;this.endSet_=false;this.endNameSet_=false;this.endBeforeSet_=false;this.limit_=0;this.viewFrom_="";this.indexStartValue_=null;this.indexStartName_="";this.indexEndValue_=null;this.indexEndName_="";this.index_=PRIORITY_INDEX}hasStart(){return this.startSet_}isViewFromLeft(){if(this.viewFrom_===""){return this.startSet_}else{return this.viewFrom_==="l"}}getIndexStartValue(){(0,_util.assert)(this.startSet_,"Only valid if start has been set");return this.indexStartValue_}getIndexStartName(){(0,_util.assert)(this.startSet_,"Only valid if start has been set");if(this.startNameSet_){return this.indexStartName_}else{return MIN_NAME}}hasEnd(){return this.endSet_}getIndexEndValue(){(0,_util.assert)(this.endSet_,"Only valid if end has been set");return this.indexEndValue_}getIndexEndName(){(0,_util.assert)(this.endSet_,"Only valid if end has been set");if(this.endNameSet_){return this.indexEndName_}else{return MAX_NAME}}hasLimit(){return this.limitSet_}hasAnchoredLimit(){return this.limitSet_&&this.viewFrom_!==""}getLimit(){(0,_util.assert)(this.limitSet_,"Only valid if limit has been set");return this.limit_}getIndex(){return this.index_}loadsAllData(){return!(this.startSet_||this.endSet_||this.limitSet_)}isDefault(){return this.loadsAllData()&&this.index_===PRIORITY_INDEX}copy(){const copy=new QueryParams;copy.limitSet_=this.limitSet_;copy.limit_=this.limit_;copy.startSet_=this.startSet_;copy.startAfterSet_=this.startAfterSet_;copy.indexStartValue_=this.indexStartValue_;copy.startNameSet_=this.startNameSet_;copy.indexStartName_=this.indexStartName_;copy.endSet_=this.endSet_;copy.endBeforeSet_=this.endBeforeSet_;copy.indexEndValue_=this.indexEndValue_;copy.endNameSet_=this.endNameSet_;copy.indexEndName_=this.indexEndName_;copy.index_=this.index_;copy.viewFrom_=this.viewFrom_;return copy}}exports._QueryParams=QueryParams;function queryParamsGetNodeFilter(queryParams){if(queryParams.loadsAllData()){return new IndexedFilter(queryParams.getIndex())}else if(queryParams.hasLimit()){return new LimitedFilter(queryParams)}else{return new RangedFilter(queryParams)}}function queryParamsLimitToFirst(queryParams,newLimit){const newParams=queryParams.copy();newParams.limitSet_=true;newParams.limit_=newLimit;newParams.viewFrom_="l";return newParams}function queryParamsLimitToLast(queryParams,newLimit){const newParams=queryParams.copy();newParams.limitSet_=true;newParams.limit_=newLimit;newParams.viewFrom_="r";return newParams}function queryParamsStartAt(queryParams,indexValue,key){const newParams=queryParams.copy();newParams.startSet_=true;if(indexValue===undefined){indexValue=null}newParams.indexStartValue_=indexValue;if(key!=null){newParams.startNameSet_=true;newParams.indexStartName_=key}else{newParams.startNameSet_=false;newParams.indexStartName_=""}return newParams}function queryParamsStartAfter(queryParams,indexValue,key){let params;if(queryParams.index_===KEY_INDEX||!!key){params=queryParamsStartAt(queryParams,indexValue,key)}else{params=queryParamsStartAt(queryParams,indexValue,MAX_NAME)}params.startAfterSet_=true;return params}function queryParamsEndAt(queryParams,indexValue,key){const newParams=queryParams.copy();newParams.endSet_=true;if(indexValue===undefined){indexValue=null}newParams.indexEndValue_=indexValue;if(key!==undefined){newParams.endNameSet_=true;newParams.indexEndName_=key}else{newParams.endNameSet_=false;newParams.indexEndName_=""}return newParams}function queryParamsEndBefore(queryParams,indexValue,key){let params;if(queryParams.index_===KEY_INDEX||!!key){params=queryParamsEndAt(queryParams,indexValue,key)}else{params=queryParamsEndAt(queryParams,indexValue,MIN_NAME)}params.endBeforeSet_=true;return params}function queryParamsOrderBy(queryParams,index){const newParams=queryParams.copy();newParams.index_=index;return newParams}function queryParamsToRestQueryStringParameters(queryParams){const qs={};if(queryParams.isDefault()){return qs}let orderBy;if(queryParams.index_===PRIORITY_INDEX){orderBy="$priority"}else if(queryParams.index_===VALUE_INDEX){orderBy="$value"}else if(queryParams.index_===KEY_INDEX){orderBy="$key"}else{(0,_util.assert)(queryParams.index_ instanceof PathIndex,"Unrecognized index type!");orderBy=queryParams.index_.toString()}qs["orderBy"]=(0,_util.stringify)(orderBy);if(queryParams.startSet_){const startParam=queryParams.startAfterSet_?"startAfter":"startAt";qs[startParam]=(0,_util.stringify)(queryParams.indexStartValue_);if(queryParams.startNameSet_){qs[startParam]+=","+(0,_util.stringify)(queryParams.indexStartName_)}}if(queryParams.endSet_){const endParam=queryParams.endBeforeSet_?"endBefore":"endAt";qs[endParam]=(0,_util.stringify)(queryParams.indexEndValue_);if(queryParams.endNameSet_){qs[endParam]+=","+(0,_util.stringify)(queryParams.indexEndName_)}}if(queryParams.limitSet_){if(queryParams.isViewFromLeft()){qs["limitToFirst"]=queryParams.limit_}else{qs["limitToLast"]=queryParams.limit_}}return qs}function queryParamsGetQueryObject(queryParams){const obj={};if(queryParams.startSet_){obj["sp"]=queryParams.indexStartValue_;if(queryParams.startNameSet_){obj["sn"]=queryParams.indexStartName_}obj["sin"]=!queryParams.startAfterSet_}if(queryParams.endSet_){obj["ep"]=queryParams.indexEndValue_;if(queryParams.endNameSet_){obj["en"]=queryParams.indexEndName_}obj["ein"]=!queryParams.endBeforeSet_}if(queryParams.limitSet_){obj["l"]=queryParams.limit_;let viewFrom=queryParams.viewFrom_;if(viewFrom===""){if(queryParams.isViewFromLeft()){viewFrom="l"}else{viewFrom="r"}}obj["vf"]=viewFrom}if(queryParams.index_!==PRIORITY_INDEX){obj["i"]=queryParams.index_.toString()}return obj}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ReadonlyRestClient extends ServerActions{constructor(repoInfo_,onDataUpdate_,authTokenProvider_,appCheckTokenProvider_){super();this.repoInfo_=repoInfo_;this.onDataUpdate_=onDataUpdate_;this.authTokenProvider_=authTokenProvider_;this.appCheckTokenProvider_=appCheckTokenProvider_;this.log_=logWrapper("p:rest:");this.listens_={}}reportStats(stats){throw new Error("Method not implemented.")}static getListenId_(query,tag){if(tag!==undefined){return"tag$"+tag}else{(0,_util.assert)(query._queryParams.isDefault(),"should have a tag if it's not a default query.");return query._path.toString()}}listen(query,currentHashFn,tag,onComplete){const pathString=query._path.toString();this.log_("Listen called for "+pathString+" "+query._queryIdentifier);const listenId=ReadonlyRestClient.getListenId_(query,tag);const thisListen={};this.listens_[listenId]=thisListen;const queryStringParameters=queryParamsToRestQueryStringParameters(query._queryParams);this.restRequest_(pathString+".json",queryStringParameters,((error,result)=>{let data=result;if(error===404){data=null;error=null}if(error===null){this.onDataUpdate_(pathString,data,false,tag)}if((0,_util.safeGet)(this.listens_,listenId)===thisListen){let status;if(!error){status="ok"}else if(error===401){status="permission_denied"}else{status="rest_error:"+error}onComplete(status,null)}}))}unlisten(query,tag){const listenId=ReadonlyRestClient.getListenId_(query,tag);delete this.listens_[listenId]}get(query){const queryStringParameters=queryParamsToRestQueryStringParameters(query._queryParams);const pathString=query._path.toString();const deferred=new _util.Deferred;this.restRequest_(pathString+".json",queryStringParameters,((error,result)=>{let data=result;if(error===404){data=null;error=null}if(error===null){this.onDataUpdate_(pathString,data,false,null);deferred.resolve(data)}else{deferred.reject(new Error(data))}}));return deferred.promise}refreshAuthToken(token){}restRequest_(pathString,queryStringParameters={},callback){queryStringParameters["format"]="export";return Promise.all([this.authTokenProvider_.getToken(false),this.appCheckTokenProvider_.getToken(false)]).then((([authToken,appCheckToken])=>{if(authToken&&authToken.accessToken){queryStringParameters["auth"]=authToken.accessToken}if(appCheckToken&&appCheckToken.token){queryStringParameters["ac"]=appCheckToken.token}const url=(this.repoInfo_.secure?"https://":"http://")+this.repoInfo_.host+pathString+"?"+"ns="+this.repoInfo_.namespace+(0,_util.querystring)(queryStringParameters);this.log_("Sending REST request for "+url);const xhr=new XMLHttpRequest;xhr.onreadystatechange=()=>{if(callback&&xhr.readyState===4){this.log_("REST Response for "+url+" received. status:",xhr.status,"response:",xhr.responseText);let res=null;if(xhr.status>=200&&xhr.status<300){try{res=(0,_util.jsonEval)(xhr.responseText)}catch(e){warn("Failed to parse JSON response for "+url+": "+xhr.responseText)}callback(null,res)}else{if(xhr.status!==401&&xhr.status!==404){warn("Got unsuccessful REST response for "+url+" Status: "+xhr.status)}callback(xhr.status)}callback=null}};xhr.open("GET",url,true);xhr.send()}))}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class SnapshotHolder{constructor(){this.rootNode_=ChildrenNode.EMPTY_NODE}getNode(path){return this.rootNode_.getChild(path)}updateSnapshot(path,newSnapshotNode){this.rootNode_=this.rootNode_.updateChild(path,newSnapshotNode)}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function newSparseSnapshotTree(){return{value:null,children:new Map}}function sparseSnapshotTreeRemember(sparseSnapshotTree,path,data){if(pathIsEmpty(path)){sparseSnapshotTree.value=data;sparseSnapshotTree.children.clear()}else if(sparseSnapshotTree.value!==null){sparseSnapshotTree.value=sparseSnapshotTree.value.updateChild(path,data)}else{const childKey=pathGetFront(path);if(!sparseSnapshotTree.children.has(childKey)){sparseSnapshotTree.children.set(childKey,newSparseSnapshotTree())}const child=sparseSnapshotTree.children.get(childKey);path=pathPopFront(path);sparseSnapshotTreeRemember(child,path,data)}}function sparseSnapshotTreeForget(sparseSnapshotTree,path){if(pathIsEmpty(path)){sparseSnapshotTree.value=null;sparseSnapshotTree.children.clear();return true}else{if(sparseSnapshotTree.value!==null){if(sparseSnapshotTree.value.isLeafNode()){return false}else{const value=sparseSnapshotTree.value;sparseSnapshotTree.value=null;value.forEachChild(PRIORITY_INDEX,((key,tree)=>{sparseSnapshotTreeRemember(sparseSnapshotTree,new Path(key),tree)}));return sparseSnapshotTreeForget(sparseSnapshotTree,path)}}else if(sparseSnapshotTree.children.size>0){const childKey=pathGetFront(path);path=pathPopFront(path);if(sparseSnapshotTree.children.has(childKey)){const safeToRemove=sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey),path);if(safeToRemove){sparseSnapshotTree.children.delete(childKey)}}return sparseSnapshotTree.children.size===0}else{return true}}}function sparseSnapshotTreeForEachTree(sparseSnapshotTree,prefixPath,func){if(sparseSnapshotTree.value!==null){func(prefixPath,sparseSnapshotTree.value)}else{sparseSnapshotTreeForEachChild(sparseSnapshotTree,((key,tree)=>{const path=new Path(prefixPath.toString()+"/"+key);sparseSnapshotTreeForEachTree(tree,path,func)}))}}function sparseSnapshotTreeForEachChild(sparseSnapshotTree,func){sparseSnapshotTree.children.forEach(((tree,key)=>{func(key,tree)}))}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class StatsListener{constructor(collection_){this.collection_=collection_;this.last_=null}get(){const newStats=this.collection_.get();const delta=Object.assign({},newStats);if(this.last_){each(this.last_,((stat,value)=>{delta[stat]=delta[stat]-value}))}this.last_=newStats;return delta}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const FIRST_STATS_MIN_TIME=10*1e3;const FIRST_STATS_MAX_TIME=30*1e3;const REPORT_STATS_INTERVAL=5*60*1e3;class StatsReporter{constructor(collection,server_){this.server_=server_;this.statsToReport_={};this.statsListener_=new StatsListener(collection);const timeout=FIRST_STATS_MIN_TIME+(FIRST_STATS_MAX_TIME-FIRST_STATS_MIN_TIME)*Math.random();setTimeoutNonBlocking(this.reportStats_.bind(this),Math.floor(timeout))}reportStats_(){const stats=this.statsListener_.get();const reportedStats={};let haveStatsToReport=false;each(stats,((stat,value)=>{if(value>0&&(0,_util.contains)(this.statsToReport_,stat)){reportedStats[stat]=value;haveStatsToReport=true}}));if(haveStatsToReport){this.server_.reportStats(reportedStats)}setTimeoutNonBlocking(this.reportStats_.bind(this),Math.floor(Math.random()*2*REPORT_STATS_INTERVAL))}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var OperationType;(function(OperationType){OperationType[OperationType["OVERWRITE"]=0]="OVERWRITE";OperationType[OperationType["MERGE"]=1]="MERGE";OperationType[OperationType["ACK_USER_WRITE"]=2]="ACK_USER_WRITE";OperationType[OperationType["LISTEN_COMPLETE"]=3]="LISTEN_COMPLETE"})(OperationType||(OperationType={}));function newOperationSourceUser(){return{fromUser:true,fromServer:false,queryId:null,tagged:false}}function newOperationSourceServer(){return{fromUser:false,fromServer:true,queryId:null,tagged:false}}function newOperationSourceServerTaggedQuery(queryId){return{fromUser:false,fromServer:true,queryId:queryId,tagged:true}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class AckUserWrite{constructor(path,affectedTree,revert){this.path=path;this.affectedTree=affectedTree;this.revert=revert;this.type=OperationType.ACK_USER_WRITE;this.source=newOperationSourceUser()}operationForChild(childName){if(!pathIsEmpty(this.path)){(0,_util.assert)(pathGetFront(this.path)===childName,"operationForChild called for unrelated child.");return new AckUserWrite(pathPopFront(this.path),this.affectedTree,this.revert)}else if(this.affectedTree.value!=null){(0,_util.assert)(this.affectedTree.children.isEmpty(),"affectedTree should not have overlapping affected paths.");return this}else{const childTree=this.affectedTree.subtree(new Path(childName));return new AckUserWrite(newEmptyPath(),childTree,this.revert)}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ListenComplete{constructor(source,path){this.source=source;this.path=path;this.type=OperationType.LISTEN_COMPLETE}operationForChild(childName){if(pathIsEmpty(this.path)){return new ListenComplete(this.source,newEmptyPath())}else{return new ListenComplete(this.source,pathPopFront(this.path))}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Overwrite{constructor(source,path,snap){this.source=source;this.path=path;this.snap=snap;this.type=OperationType.OVERWRITE}operationForChild(childName){if(pathIsEmpty(this.path)){return new Overwrite(this.source,newEmptyPath(),this.snap.getImmediateChild(childName))}else{return new Overwrite(this.source,pathPopFront(this.path),this.snap)}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Merge{constructor(source,path,children){this.source=source;this.path=path;this.children=children;this.type=OperationType.MERGE}operationForChild(childName){if(pathIsEmpty(this.path)){const childTree=this.children.subtree(new Path(childName));if(childTree.isEmpty()){return null}else if(childTree.value){return new Overwrite(this.source,newEmptyPath(),childTree.value)}else{return new Merge(this.source,newEmptyPath(),childTree)}}else{(0,_util.assert)(pathGetFront(this.path)===childName,"Can't get a merge for a child not on the path of the operation");return new Merge(this.source,pathPopFront(this.path),this.children)}}toString(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class CacheNode{constructor(node_,fullyInitialized_,filtered_){this.node_=node_;this.fullyInitialized_=fullyInitialized_;this.filtered_=filtered_}isFullyInitialized(){return this.fullyInitialized_}isFiltered(){return this.filtered_}isCompleteForPath(path){if(pathIsEmpty(path)){return this.isFullyInitialized()&&!this.filtered_}const childKey=pathGetFront(path);return this.isCompleteForChild(childKey)}isCompleteForChild(key){return this.isFullyInitialized()&&!this.filtered_||this.node_.hasChild(key)}getNode(){return this.node_}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class EventGenerator{constructor(query_){this.query_=query_;this.index_=this.query_._queryParams.getIndex()}}function eventGeneratorGenerateEventsForChanges(eventGenerator,changes,eventCache,eventRegistrations){const events=[];const moves=[];changes.forEach((change=>{if(change.type==="child_changed"&&eventGenerator.index_.indexedValueChanged(change.oldSnap,change.snapshotNode)){moves.push(changeChildMoved(change.childName,change.snapshotNode))}}));eventGeneratorGenerateEventsForType(eventGenerator,events,"child_removed",changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"child_added",changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"child_moved",moves,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"child_changed",changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"value",changes,eventRegistrations,eventCache);return events}function eventGeneratorGenerateEventsForType(eventGenerator,events,eventType,changes,registrations,eventCache){const filteredChanges=changes.filter((change=>change.type===eventType));filteredChanges.sort(((a,b)=>eventGeneratorCompareChanges(eventGenerator,a,b)));filteredChanges.forEach((change=>{const materializedChange=eventGeneratorMaterializeSingleChange(eventGenerator,change,eventCache);registrations.forEach((registration=>{if(registration.respondsTo(change.type)){events.push(registration.createEvent(materializedChange,eventGenerator.query_))}}))}))}function eventGeneratorMaterializeSingleChange(eventGenerator,change,eventCache){if(change.type==="value"||change.type==="child_removed"){return change}else{change.prevName=eventCache.getPredecessorChildName(change.childName,change.snapshotNode,eventGenerator.index_);return change}}function eventGeneratorCompareChanges(eventGenerator,a,b){if(a.childName==null||b.childName==null){throw(0,_util.assertionError)("Should only compare child_ events.")}const aWrapped=new NamedNode(a.childName,a.snapshotNode);const bWrapped=new NamedNode(b.childName,b.snapshotNode);return eventGenerator.index_.compare(aWrapped,bWrapped)}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function newViewCache(eventCache,serverCache){return{eventCache:eventCache,serverCache:serverCache}}function viewCacheUpdateEventSnap(viewCache,eventSnap,complete,filtered){return newViewCache(new CacheNode(eventSnap,complete,filtered),viewCache.serverCache)}function viewCacheUpdateServerSnap(viewCache,serverSnap,complete,filtered){return newViewCache(viewCache.eventCache,new CacheNode(serverSnap,complete,filtered))}function viewCacheGetCompleteEventSnap(viewCache){return viewCache.eventCache.isFullyInitialized()?viewCache.eventCache.getNode():null}function viewCacheGetCompleteServerSnap(viewCache){return viewCache.serverCache.isFullyInitialized()?viewCache.serverCache.getNode():null}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let emptyChildrenSingleton;const EmptyChildren=()=>{if(!emptyChildrenSingleton){emptyChildrenSingleton=new SortedMap(stringCompare)}return emptyChildrenSingleton};class ImmutableTree{constructor(value,children=EmptyChildren()){this.value=value;this.children=children}static fromObject(obj){let tree=new ImmutableTree(null);each(obj,((childPath,childSnap)=>{tree=tree.set(new Path(childPath),childSnap)}));return tree}isEmpty(){return this.value===null&&this.children.isEmpty()}findRootMostMatchingPathAndValue(relativePath,predicate){if(this.value!=null&&predicate(this.value)){return{path:newEmptyPath(),value:this.value}}else{if(pathIsEmpty(relativePath)){return null}else{const front=pathGetFront(relativePath);const child=this.children.get(front);if(child!==null){const childExistingPathAndValue=child.findRootMostMatchingPathAndValue(pathPopFront(relativePath),predicate);if(childExistingPathAndValue!=null){const fullPath=pathChild(new Path(front),childExistingPathAndValue.path);return{path:fullPath,value:childExistingPathAndValue.value}}else{return null}}else{return null}}}}findRootMostValueAndPath(relativePath){return this.findRootMostMatchingPathAndValue(relativePath,(()=>true))}subtree(relativePath){if(pathIsEmpty(relativePath)){return this}else{const front=pathGetFront(relativePath);const childTree=this.children.get(front);if(childTree!==null){return childTree.subtree(pathPopFront(relativePath))}else{return new ImmutableTree(null)}}}set(relativePath,toSet){if(pathIsEmpty(relativePath)){return new ImmutableTree(toSet,this.children)}else{const front=pathGetFront(relativePath);const child=this.children.get(front)||new ImmutableTree(null);const newChild=child.set(pathPopFront(relativePath),toSet);const newChildren=this.children.insert(front,newChild);return new ImmutableTree(this.value,newChildren)}}remove(relativePath){if(pathIsEmpty(relativePath)){if(this.children.isEmpty()){return new ImmutableTree(null)}else{return new ImmutableTree(null,this.children)}}else{const front=pathGetFront(relativePath);const child=this.children.get(front);if(child){const newChild=child.remove(pathPopFront(relativePath));let newChildren;if(newChild.isEmpty()){newChildren=this.children.remove(front)}else{newChildren=this.children.insert(front,newChild)}if(this.value===null&&newChildren.isEmpty()){return new ImmutableTree(null)}else{return new ImmutableTree(this.value,newChildren)}}else{return this}}}get(relativePath){if(pathIsEmpty(relativePath)){return this.value}else{const front=pathGetFront(relativePath);const child=this.children.get(front);if(child){return child.get(pathPopFront(relativePath))}else{return null}}}setTree(relativePath,newTree){if(pathIsEmpty(relativePath)){return newTree}else{const front=pathGetFront(relativePath);const child=this.children.get(front)||new ImmutableTree(null);const newChild=child.setTree(pathPopFront(relativePath),newTree);let newChildren;if(newChild.isEmpty()){newChildren=this.children.remove(front)}else{newChildren=this.children.insert(front,newChild)}return new ImmutableTree(this.value,newChildren)}}fold(fn){return this.fold_(newEmptyPath(),fn)}fold_(pathSoFar,fn){const accum={};this.children.inorderTraversal(((childKey,childTree)=>{accum[childKey]=childTree.fold_(pathChild(pathSoFar,childKey),fn)}));return fn(pathSoFar,this.value,accum)}findOnPath(path,f){return this.findOnPath_(path,newEmptyPath(),f)}findOnPath_(pathToFollow,pathSoFar,f){const result=this.value?f(pathSoFar,this.value):false;if(result){return result}else{if(pathIsEmpty(pathToFollow)){return null}else{const front=pathGetFront(pathToFollow);const nextChild=this.children.get(front);if(nextChild){return nextChild.findOnPath_(pathPopFront(pathToFollow),pathChild(pathSoFar,front),f)}else{return null}}}}foreachOnPath(path,f){return this.foreachOnPath_(path,newEmptyPath(),f)}foreachOnPath_(pathToFollow,currentRelativePath,f){if(pathIsEmpty(pathToFollow)){return this}else{if(this.value){f(currentRelativePath,this.value)}const front=pathGetFront(pathToFollow);const nextChild=this.children.get(front);if(nextChild){return nextChild.foreachOnPath_(pathPopFront(pathToFollow),pathChild(currentRelativePath,front),f)}else{return new ImmutableTree(null)}}}foreach(f){this.foreach_(newEmptyPath(),f)}foreach_(currentRelativePath,f){this.children.inorderTraversal(((childName,childTree)=>{childTree.foreach_(pathChild(currentRelativePath,childName),f)}));if(this.value){f(currentRelativePath,this.value)}}foreachChild(f){this.children.inorderTraversal(((childName,childTree)=>{if(childTree.value){f(childName,childTree.value)}}))}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class CompoundWrite{constructor(writeTree_){this.writeTree_=writeTree_}static empty(){return new CompoundWrite(new ImmutableTree(null))}}function compoundWriteAddWrite(compoundWrite,path,node){if(pathIsEmpty(path)){return new CompoundWrite(new ImmutableTree(node))}else{const rootmost=compoundWrite.writeTree_.findRootMostValueAndPath(path);if(rootmost!=null){const rootMostPath=rootmost.path;let value=rootmost.value;const relativePath=newRelativePath(rootMostPath,path);value=value.updateChild(relativePath,node);return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath,value))}else{const subtree=new ImmutableTree(node);const newWriteTree=compoundWrite.writeTree_.setTree(path,subtree);return new CompoundWrite(newWriteTree)}}}function compoundWriteAddWrites(compoundWrite,path,updates){let newWrite=compoundWrite;each(updates,((childKey,node)=>{newWrite=compoundWriteAddWrite(newWrite,pathChild(path,childKey),node)}));return newWrite}function compoundWriteRemoveWrite(compoundWrite,path){if(pathIsEmpty(path)){return CompoundWrite.empty()}else{const newWriteTree=compoundWrite.writeTree_.setTree(path,new ImmutableTree(null));return new CompoundWrite(newWriteTree)}}function compoundWriteHasCompleteWrite(compoundWrite,path){return compoundWriteGetCompleteNode(compoundWrite,path)!=null}function compoundWriteGetCompleteNode(compoundWrite,path){const rootmost=compoundWrite.writeTree_.findRootMostValueAndPath(path);if(rootmost!=null){return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path,path))}else{return null}}function compoundWriteGetCompleteChildren(compoundWrite){const children=[];const node=compoundWrite.writeTree_.value;if(node!=null){if(!node.isLeafNode()){node.forEachChild(PRIORITY_INDEX,((childName,childNode)=>{children.push(new NamedNode(childName,childNode))}))}}else{compoundWrite.writeTree_.children.inorderTraversal(((childName,childTree)=>{if(childTree.value!=null){children.push(new NamedNode(childName,childTree.value))}}))}return children}function compoundWriteChildCompoundWrite(compoundWrite,path){if(pathIsEmpty(path)){return compoundWrite}else{const shadowingNode=compoundWriteGetCompleteNode(compoundWrite,path);if(shadowingNode!=null){return new CompoundWrite(new ImmutableTree(shadowingNode))}else{return new CompoundWrite(compoundWrite.writeTree_.subtree(path))}}}function compoundWriteIsEmpty(compoundWrite){return compoundWrite.writeTree_.isEmpty()}function compoundWriteApply(compoundWrite,node){return applySubtreeWrite(newEmptyPath(),compoundWrite.writeTree_,node)}function applySubtreeWrite(relativePath,writeTree,node){if(writeTree.value!=null){return node.updateChild(relativePath,writeTree.value)}else{let priorityWrite=null;writeTree.children.inorderTraversal(((childKey,childTree)=>{if(childKey===".priority"){(0,_util.assert)(childTree.value!==null,"Priority writes must always be leaf nodes");priorityWrite=childTree.value}else{node=applySubtreeWrite(pathChild(relativePath,childKey),childTree,node)}}));if(!node.getChild(relativePath).isEmpty()&&priorityWrite!==null){node=node.updateChild(pathChild(relativePath,".priority"),priorityWrite)}return node}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function writeTreeChildWrites(writeTree,path){return newWriteTreeRef(path,writeTree)}function writeTreeAddOverwrite(writeTree,path,snap,writeId,visible){(0,_util.assert)(writeId>writeTree.lastWriteId,"Stacking an older write on top of newer ones");if(visible===undefined){visible=true}writeTree.allWrites.push({path:path,snap:snap,writeId:writeId,visible:visible});if(visible){writeTree.visibleWrites=compoundWriteAddWrite(writeTree.visibleWrites,path,snap)}writeTree.lastWriteId=writeId}function writeTreeAddMerge(writeTree,path,changedChildren,writeId){(0,_util.assert)(writeId>writeTree.lastWriteId,"Stacking an older merge on top of newer ones");writeTree.allWrites.push({path:path,children:changedChildren,writeId:writeId,visible:true});writeTree.visibleWrites=compoundWriteAddWrites(writeTree.visibleWrites,path,changedChildren);writeTree.lastWriteId=writeId}function writeTreeGetWrite(writeTree,writeId){for(let i=0;i<writeTree.allWrites.length;i++){const record=writeTree.allWrites[i];if(record.writeId===writeId){return record}}return null}function writeTreeRemoveWrite(writeTree,writeId){const idx=writeTree.allWrites.findIndex((s=>s.writeId===writeId));(0,_util.assert)(idx>=0,"removeWrite called with nonexistent writeId.");const writeToRemove=writeTree.allWrites[idx];writeTree.allWrites.splice(idx,1);let removedWriteWasVisible=writeToRemove.visible;let removedWriteOverlapsWithOtherWrites=false;let i=writeTree.allWrites.length-1;while(removedWriteWasVisible&&i>=0){const currentWrite=writeTree.allWrites[i];if(currentWrite.visible){if(i>=idx&&writeTreeRecordContainsPath_(currentWrite,writeToRemove.path)){removedWriteWasVisible=false}else if(pathContains(writeToRemove.path,currentWrite.path)){removedWriteOverlapsWithOtherWrites=true}}i--}if(!removedWriteWasVisible){return false}else if(removedWriteOverlapsWithOtherWrites){writeTreeResetTree_(writeTree);return true}else{if(writeToRemove.snap){writeTree.visibleWrites=compoundWriteRemoveWrite(writeTree.visibleWrites,writeToRemove.path)}else{const children=writeToRemove.children;each(children,(childName=>{writeTree.visibleWrites=compoundWriteRemoveWrite(writeTree.visibleWrites,pathChild(writeToRemove.path,childName))}))}return true}}function writeTreeRecordContainsPath_(writeRecord,path){if(writeRecord.snap){return pathContains(writeRecord.path,path)}else{for(const childName in writeRecord.children){if(writeRecord.children.hasOwnProperty(childName)&&pathContains(pathChild(writeRecord.path,childName),path)){return true}}return false}}function writeTreeResetTree_(writeTree){writeTree.visibleWrites=writeTreeLayerTree_(writeTree.allWrites,writeTreeDefaultFilter_,newEmptyPath());if(writeTree.allWrites.length>0){writeTree.lastWriteId=writeTree.allWrites[writeTree.allWrites.length-1].writeId}else{writeTree.lastWriteId=-1}}function writeTreeDefaultFilter_(write){return write.visible}function writeTreeLayerTree_(writes,filter,treeRoot){let compoundWrite=CompoundWrite.empty();for(let i=0;i<writes.length;++i){const write=writes[i];if(filter(write)){const writePath=write.path;let relativePath;if(write.snap){if(pathContains(treeRoot,writePath)){relativePath=newRelativePath(treeRoot,writePath);compoundWrite=compoundWriteAddWrite(compoundWrite,relativePath,write.snap)}else if(pathContains(writePath,treeRoot)){relativePath=newRelativePath(writePath,treeRoot);compoundWrite=compoundWriteAddWrite(compoundWrite,newEmptyPath(),write.snap.getChild(relativePath))}else;}else if(write.children){if(pathContains(treeRoot,writePath)){relativePath=newRelativePath(treeRoot,writePath);compoundWrite=compoundWriteAddWrites(compoundWrite,relativePath,write.children)}else if(pathContains(writePath,treeRoot)){relativePath=newRelativePath(writePath,treeRoot);if(pathIsEmpty(relativePath)){compoundWrite=compoundWriteAddWrites(compoundWrite,newEmptyPath(),write.children)}else{const child=(0,_util.safeGet)(write.children,pathGetFront(relativePath));if(child){const deepNode=child.getChild(pathPopFront(relativePath));compoundWrite=compoundWriteAddWrite(compoundWrite,newEmptyPath(),deepNode)}}}else;}else{throw(0,_util.assertionError)("WriteRecord should have .snap or .children")}}}return compoundWrite}function writeTreeCalcCompleteEventCache(writeTree,treePath,completeServerCache,writeIdsToExclude,includeHiddenWrites){if(!writeIdsToExclude&&!includeHiddenWrites){const shadowingNode=compoundWriteGetCompleteNode(writeTree.visibleWrites,treePath);if(shadowingNode!=null){return shadowingNode}else{const subMerge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);if(compoundWriteIsEmpty(subMerge)){return completeServerCache}else if(completeServerCache==null&&!compoundWriteHasCompleteWrite(subMerge,newEmptyPath())){return null}else{const layeredCache=completeServerCache||ChildrenNode.EMPTY_NODE;return compoundWriteApply(subMerge,layeredCache)}}}else{const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);if(!includeHiddenWrites&&compoundWriteIsEmpty(merge)){return completeServerCache}else{if(!includeHiddenWrites&&completeServerCache==null&&!compoundWriteHasCompleteWrite(merge,newEmptyPath())){return null}else{const filter=function(write){return(write.visible||includeHiddenWrites)&&(!writeIdsToExclude||!~writeIdsToExclude.indexOf(write.writeId))&&(pathContains(write.path,treePath)||pathContains(treePath,write.path))};const mergeAtPath=writeTreeLayerTree_(writeTree.allWrites,filter,treePath);const layeredCache=completeServerCache||ChildrenNode.EMPTY_NODE;return compoundWriteApply(mergeAtPath,layeredCache)}}}}function writeTreeCalcCompleteEventChildren(writeTree,treePath,completeServerChildren){let completeChildren=ChildrenNode.EMPTY_NODE;const topLevelSet=compoundWriteGetCompleteNode(writeTree.visibleWrites,treePath);if(topLevelSet){if(!topLevelSet.isLeafNode()){topLevelSet.forEachChild(PRIORITY_INDEX,((childName,childSnap)=>{completeChildren=completeChildren.updateImmediateChild(childName,childSnap)}))}return completeChildren}else if(completeServerChildren){const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);completeServerChildren.forEachChild(PRIORITY_INDEX,((childName,childNode)=>{const node=compoundWriteApply(compoundWriteChildCompoundWrite(merge,new Path(childName)),childNode);completeChildren=completeChildren.updateImmediateChild(childName,node)}));compoundWriteGetCompleteChildren(merge).forEach((namedNode=>{completeChildren=completeChildren.updateImmediateChild(namedNode.name,namedNode.node)}));return completeChildren}else{const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);compoundWriteGetCompleteChildren(merge).forEach((namedNode=>{completeChildren=completeChildren.updateImmediateChild(namedNode.name,namedNode.node)}));return completeChildren}}function writeTreeCalcEventCacheAfterServerOverwrite(writeTree,treePath,childPath,existingEventSnap,existingServerSnap){(0,_util.assert)(existingEventSnap||existingServerSnap,"Either existingEventSnap or existingServerSnap must exist");const path=pathChild(treePath,childPath);if(compoundWriteHasCompleteWrite(writeTree.visibleWrites,path)){return null}else{const childMerge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,path);if(compoundWriteIsEmpty(childMerge)){return existingServerSnap.getChild(childPath)}else{return compoundWriteApply(childMerge,existingServerSnap.getChild(childPath))}}}function writeTreeCalcCompleteChild(writeTree,treePath,childKey,existingServerSnap){const path=pathChild(treePath,childKey);const shadowingNode=compoundWriteGetCompleteNode(writeTree.visibleWrites,path);if(shadowingNode!=null){return shadowingNode}else{if(existingServerSnap.isCompleteForChild(childKey)){const childMerge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,path);return compoundWriteApply(childMerge,existingServerSnap.getNode().getImmediateChild(childKey))}else{return null}}}function writeTreeShadowingWrite(writeTree,path){return compoundWriteGetCompleteNode(writeTree.visibleWrites,path)}function writeTreeCalcIndexedSlice(writeTree,treePath,completeServerData,startPost,count,reverse,index){let toIterate;const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);const shadowingNode=compoundWriteGetCompleteNode(merge,newEmptyPath());if(shadowingNode!=null){toIterate=shadowingNode}else if(completeServerData!=null){toIterate=compoundWriteApply(merge,completeServerData)}else{return[]}toIterate=toIterate.withIndex(index);if(!toIterate.isEmpty()&&!toIterate.isLeafNode()){const nodes=[];const cmp=index.getCompare();const iter=reverse?toIterate.getReverseIteratorFrom(startPost,index):toIterate.getIteratorFrom(startPost,index);let next=iter.getNext();while(next&&nodes.length<count){if(cmp(next,startPost)!==0){nodes.push(next)}next=iter.getNext()}return nodes}else{return[]}}function newWriteTree(){return{visibleWrites:CompoundWrite.empty(),allWrites:[],lastWriteId:-1}}function writeTreeRefCalcCompleteEventCache(writeTreeRef,completeServerCache,writeIdsToExclude,includeHiddenWrites){return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree,writeTreeRef.treePath,completeServerCache,writeIdsToExclude,includeHiddenWrites)}function writeTreeRefCalcCompleteEventChildren(writeTreeRef,completeServerChildren){return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree,writeTreeRef.treePath,completeServerChildren)}function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef,path,existingEventSnap,existingServerSnap){return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree,writeTreeRef.treePath,path,existingEventSnap,existingServerSnap)}function writeTreeRefShadowingWrite(writeTreeRef,path){return writeTreeShadowingWrite(writeTreeRef.writeTree,pathChild(writeTreeRef.treePath,path))}function writeTreeRefCalcIndexedSlice(writeTreeRef,completeServerData,startPost,count,reverse,index){return writeTreeCalcIndexedSlice(writeTreeRef.writeTree,writeTreeRef.treePath,completeServerData,startPost,count,reverse,index)}function writeTreeRefCalcCompleteChild(writeTreeRef,childKey,existingServerCache){return writeTreeCalcCompleteChild(writeTreeRef.writeTree,writeTreeRef.treePath,childKey,existingServerCache)}function writeTreeRefChild(writeTreeRef,childName){return newWriteTreeRef(pathChild(writeTreeRef.treePath,childName),writeTreeRef.writeTree)}function newWriteTreeRef(path,writeTree){return{treePath:path,writeTree:writeTree}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ChildChangeAccumulator{constructor(){this.changeMap=new Map}trackChildChange(change){const type=change.type;const childKey=change.childName;(0,_util.assert)(type==="child_added"||type==="child_changed"||type==="child_removed","Only child changes supported for tracking");(0,_util.assert)(childKey!==".priority","Only non-priority child changes can be tracked.");const oldChange=this.changeMap.get(childKey);if(oldChange){const oldType=oldChange.type;if(type==="child_added"&&oldType==="child_removed"){this.changeMap.set(childKey,changeChildChanged(childKey,change.snapshotNode,oldChange.snapshotNode))}else if(type==="child_removed"&&oldType==="child_added"){this.changeMap.delete(childKey)}else if(type==="child_removed"&&oldType==="child_changed"){this.changeMap.set(childKey,changeChildRemoved(childKey,oldChange.oldSnap))}else if(type==="child_changed"&&oldType==="child_added"){this.changeMap.set(childKey,changeChildAdded(childKey,change.snapshotNode))}else if(type==="child_changed"&&oldType==="child_changed"){this.changeMap.set(childKey,changeChildChanged(childKey,change.snapshotNode,oldChange.oldSnap))}else{throw(0,_util.assertionError)("Illegal combination of changes: "+change+" occurred after "+oldChange)}}else{this.changeMap.set(childKey,change)}}getChanges(){return Array.from(this.changeMap.values())}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class NoCompleteChildSource_{getCompleteChild(childKey){return null}getChildAfterChild(index,child,reverse){return null}}const NO_COMPLETE_CHILD_SOURCE=new NoCompleteChildSource_;class WriteTreeCompleteChildSource{constructor(writes_,viewCache_,optCompleteServerCache_=null){this.writes_=writes_;this.viewCache_=viewCache_;this.optCompleteServerCache_=optCompleteServerCache_}getCompleteChild(childKey){const node=this.viewCache_.eventCache;if(node.isCompleteForChild(childKey)){return node.getNode().getImmediateChild(childKey)}else{const serverNode=this.optCompleteServerCache_!=null?new CacheNode(this.optCompleteServerCache_,true,false):this.viewCache_.serverCache;return writeTreeRefCalcCompleteChild(this.writes_,childKey,serverNode)}}getChildAfterChild(index,child,reverse){const completeServerData=this.optCompleteServerCache_!=null?this.optCompleteServerCache_:viewCacheGetCompleteServerSnap(this.viewCache_);const nodes=writeTreeRefCalcIndexedSlice(this.writes_,completeServerData,child,1,reverse,index);if(nodes.length===0){return null}else{return nodes[0]}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function newViewProcessor(filter){return{filter:filter}}function viewProcessorAssertIndexed(viewProcessor,viewCache){(0,_util.assert)(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()),"Event snap not indexed");(0,_util.assert)(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()),"Server snap not indexed")}function viewProcessorApplyOperation(viewProcessor,oldViewCache,operation,writesCache,completeCache){const accumulator=new ChildChangeAccumulator;let newViewCache,filterServerNode;if(operation.type===OperationType.OVERWRITE){const overwrite=operation;if(overwrite.source.fromUser){newViewCache=viewProcessorApplyUserOverwrite(viewProcessor,oldViewCache,overwrite.path,overwrite.snap,writesCache,completeCache,accumulator)}else{(0,_util.assert)(overwrite.source.fromServer,"Unknown source.");filterServerNode=overwrite.source.tagged||oldViewCache.serverCache.isFiltered()&&!pathIsEmpty(overwrite.path);newViewCache=viewProcessorApplyServerOverwrite(viewProcessor,oldViewCache,overwrite.path,overwrite.snap,writesCache,completeCache,filterServerNode,accumulator)}}else if(operation.type===OperationType.MERGE){const merge=operation;if(merge.source.fromUser){newViewCache=viewProcessorApplyUserMerge(viewProcessor,oldViewCache,merge.path,merge.children,writesCache,completeCache,accumulator)}else{(0,_util.assert)(merge.source.fromServer,"Unknown source.");filterServerNode=merge.source.tagged||oldViewCache.serverCache.isFiltered();newViewCache=viewProcessorApplyServerMerge(viewProcessor,oldViewCache,merge.path,merge.children,writesCache,completeCache,filterServerNode,accumulator)}}else if(operation.type===OperationType.ACK_USER_WRITE){const ackUserWrite=operation;if(!ackUserWrite.revert){newViewCache=viewProcessorAckUserWrite(viewProcessor,oldViewCache,ackUserWrite.path,ackUserWrite.affectedTree,writesCache,completeCache,accumulator)}else{newViewCache=viewProcessorRevertUserWrite(viewProcessor,oldViewCache,ackUserWrite.path,writesCache,completeCache,accumulator)}}else if(operation.type===OperationType.LISTEN_COMPLETE){newViewCache=viewProcessorListenComplete(viewProcessor,oldViewCache,operation.path,writesCache,accumulator)}else{throw(0,_util.assertionError)("Unknown operation type: "+operation.type)}const changes=accumulator.getChanges();viewProcessorMaybeAddValueEvent(oldViewCache,newViewCache,changes);return{viewCache:newViewCache,changes:changes}}function viewProcessorMaybeAddValueEvent(oldViewCache,newViewCache,accumulator){const eventSnap=newViewCache.eventCache;if(eventSnap.isFullyInitialized()){const isLeafOrEmpty=eventSnap.getNode().isLeafNode()||eventSnap.getNode().isEmpty();const oldCompleteSnap=viewCacheGetCompleteEventSnap(oldViewCache);if(accumulator.length>0||!oldViewCache.eventCache.isFullyInitialized()||isLeafOrEmpty&&!eventSnap.getNode().equals(oldCompleteSnap)||!eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())){accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)))}}}function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,viewCache,changePath,writesCache,source,accumulator){const oldEventSnap=viewCache.eventCache;if(writeTreeRefShadowingWrite(writesCache,changePath)!=null){return viewCache}else{let newEventCache,serverNode;if(pathIsEmpty(changePath)){(0,_util.assert)(viewCache.serverCache.isFullyInitialized(),"If change path is empty, we must have complete server data");if(viewCache.serverCache.isFiltered()){const serverCache=viewCacheGetCompleteServerSnap(viewCache);const completeChildren=serverCache instanceof ChildrenNode?serverCache:ChildrenNode.EMPTY_NODE;const completeEventChildren=writeTreeRefCalcCompleteEventChildren(writesCache,completeChildren);newEventCache=viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(),completeEventChildren,accumulator)}else{const completeNode=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(viewCache));newEventCache=viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(),completeNode,accumulator)}}else{const childKey=pathGetFront(changePath);if(childKey===".priority"){(0,_util.assert)(pathGetLength(changePath)===1,"Can't have a priority with additional path components");const oldEventNode=oldEventSnap.getNode();serverNode=viewCache.serverCache.getNode();const updatedPriority=writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache,changePath,oldEventNode,serverNode);if(updatedPriority!=null){newEventCache=viewProcessor.filter.updatePriority(oldEventNode,updatedPriority)}else{newEventCache=oldEventSnap.getNode()}}else{const childChangePath=pathPopFront(changePath);let newEventChild;if(oldEventSnap.isCompleteForChild(childKey)){serverNode=viewCache.serverCache.getNode();const eventChildUpdate=writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache,changePath,oldEventSnap.getNode(),serverNode);if(eventChildUpdate!=null){newEventChild=oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath,eventChildUpdate)}else{newEventChild=oldEventSnap.getNode().getImmediateChild(childKey)}}else{newEventChild=writeTreeRefCalcCompleteChild(writesCache,childKey,viewCache.serverCache)}if(newEventChild!=null){newEventCache=viewProcessor.filter.updateChild(oldEventSnap.getNode(),childKey,newEventChild,childChangePath,source,accumulator)}else{newEventCache=oldEventSnap.getNode()}}}return viewCacheUpdateEventSnap(viewCache,newEventCache,oldEventSnap.isFullyInitialized()||pathIsEmpty(changePath),viewProcessor.filter.filtersNodes())}}function viewProcessorApplyServerOverwrite(viewProcessor,oldViewCache,changePath,changedSnap,writesCache,completeCache,filterServerNode,accumulator){const oldServerSnap=oldViewCache.serverCache;let newServerCache;const serverFilter=filterServerNode?viewProcessor.filter:viewProcessor.filter.getIndexedFilter();if(pathIsEmpty(changePath)){newServerCache=serverFilter.updateFullNode(oldServerSnap.getNode(),changedSnap,null)}else if(serverFilter.filtersNodes()&&!oldServerSnap.isFiltered()){const newServerNode=oldServerSnap.getNode().updateChild(changePath,changedSnap);newServerCache=serverFilter.updateFullNode(oldServerSnap.getNode(),newServerNode,null)}else{const childKey=pathGetFront(changePath);if(!oldServerSnap.isCompleteForPath(changePath)&&pathGetLength(changePath)>1){return oldViewCache}const childChangePath=pathPopFront(changePath);const childNode=oldServerSnap.getNode().getImmediateChild(childKey);const newChildNode=childNode.updateChild(childChangePath,changedSnap);if(childKey===".priority"){newServerCache=serverFilter.updatePriority(oldServerSnap.getNode(),newChildNode)}else{newServerCache=serverFilter.updateChild(oldServerSnap.getNode(),childKey,newChildNode,childChangePath,NO_COMPLETE_CHILD_SOURCE,null)}}const newViewCache=viewCacheUpdateServerSnap(oldViewCache,newServerCache,oldServerSnap.isFullyInitialized()||pathIsEmpty(changePath),serverFilter.filtersNodes());const source=new WriteTreeCompleteChildSource(writesCache,newViewCache,completeCache);return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,newViewCache,changePath,writesCache,source,accumulator)}function viewProcessorApplyUserOverwrite(viewProcessor,oldViewCache,changePath,changedSnap,writesCache,completeCache,accumulator){const oldEventSnap=oldViewCache.eventCache;let newViewCache,newEventCache;const source=new WriteTreeCompleteChildSource(writesCache,oldViewCache,completeCache);if(pathIsEmpty(changePath)){newEventCache=viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(),changedSnap,accumulator);newViewCache=viewCacheUpdateEventSnap(oldViewCache,newEventCache,true,viewProcessor.filter.filtersNodes())}else{const childKey=pathGetFront(changePath);if(childKey===".priority"){newEventCache=viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(),changedSnap);newViewCache=viewCacheUpdateEventSnap(oldViewCache,newEventCache,oldEventSnap.isFullyInitialized(),oldEventSnap.isFiltered())}else{const childChangePath=pathPopFront(changePath);const oldChild=oldEventSnap.getNode().getImmediateChild(childKey);let newChild;if(pathIsEmpty(childChangePath)){newChild=changedSnap}else{const childNode=source.getCompleteChild(childKey);if(childNode!=null){if(pathGetBack(childChangePath)===".priority"&&childNode.getChild(pathParent(childChangePath)).isEmpty()){newChild=childNode}else{newChild=childNode.updateChild(childChangePath,changedSnap)}}else{newChild=ChildrenNode.EMPTY_NODE}}if(!oldChild.equals(newChild)){const newEventSnap=viewProcessor.filter.updateChild(oldEventSnap.getNode(),childKey,newChild,childChangePath,source,accumulator);newViewCache=viewCacheUpdateEventSnap(oldViewCache,newEventSnap,oldEventSnap.isFullyInitialized(),viewProcessor.filter.filtersNodes())}else{newViewCache=oldViewCache}}}return newViewCache}function viewProcessorCacheHasChild(viewCache,childKey){return viewCache.eventCache.isCompleteForChild(childKey)}function viewProcessorApplyUserMerge(viewProcessor,viewCache,path,changedChildren,writesCache,serverCache,accumulator){let curViewCache=viewCache;changedChildren.foreach(((relativePath,childNode)=>{const writePath=pathChild(path,relativePath);if(viewProcessorCacheHasChild(viewCache,pathGetFront(writePath))){curViewCache=viewProcessorApplyUserOverwrite(viewProcessor,curViewCache,writePath,childNode,writesCache,serverCache,accumulator)}}));changedChildren.foreach(((relativePath,childNode)=>{const writePath=pathChild(path,relativePath);if(!viewProcessorCacheHasChild(viewCache,pathGetFront(writePath))){curViewCache=viewProcessorApplyUserOverwrite(viewProcessor,curViewCache,writePath,childNode,writesCache,serverCache,accumulator)}}));return curViewCache}function viewProcessorApplyMerge(viewProcessor,node,merge){merge.foreach(((relativePath,childNode)=>{node=node.updateChild(relativePath,childNode)}));return node}function viewProcessorApplyServerMerge(viewProcessor,viewCache,path,changedChildren,writesCache,serverCache,filterServerNode,accumulator){if(viewCache.serverCache.getNode().isEmpty()&&!viewCache.serverCache.isFullyInitialized()){return viewCache}let curViewCache=viewCache;let viewMergeTree;if(pathIsEmpty(path)){viewMergeTree=changedChildren}else{viewMergeTree=new ImmutableTree(null).setTree(path,changedChildren)}const serverNode=viewCache.serverCache.getNode();viewMergeTree.children.inorderTraversal(((childKey,childTree)=>{if(serverNode.hasChild(childKey)){const serverChild=viewCache.serverCache.getNode().getImmediateChild(childKey);const newChild=viewProcessorApplyMerge(viewProcessor,serverChild,childTree);curViewCache=viewProcessorApplyServerOverwrite(viewProcessor,curViewCache,new Path(childKey),newChild,writesCache,serverCache,filterServerNode,accumulator)}}));viewMergeTree.children.inorderTraversal(((childKey,childMergeTree)=>{const isUnknownDeepMerge=!viewCache.serverCache.isCompleteForChild(childKey)&&childMergeTree.value===null;if(!serverNode.hasChild(childKey)&&!isUnknownDeepMerge){const serverChild=viewCache.serverCache.getNode().getImmediateChild(childKey);const newChild=viewProcessorApplyMerge(viewProcessor,serverChild,childMergeTree);curViewCache=viewProcessorApplyServerOverwrite(viewProcessor,curViewCache,new Path(childKey),newChild,writesCache,serverCache,filterServerNode,accumulator)}}));return curViewCache}function viewProcessorAckUserWrite(viewProcessor,viewCache,ackPath,affectedTree,writesCache,completeCache,accumulator){if(writeTreeRefShadowingWrite(writesCache,ackPath)!=null){return viewCache}const filterServerNode=viewCache.serverCache.isFiltered();const serverCache=viewCache.serverCache;if(affectedTree.value!=null){if(pathIsEmpty(ackPath)&&serverCache.isFullyInitialized()||serverCache.isCompleteForPath(ackPath)){return viewProcessorApplyServerOverwrite(viewProcessor,viewCache,ackPath,serverCache.getNode().getChild(ackPath),writesCache,completeCache,filterServerNode,accumulator)}else if(pathIsEmpty(ackPath)){let changedChildren=new ImmutableTree(null);serverCache.getNode().forEachChild(KEY_INDEX,((name,node)=>{changedChildren=changedChildren.set(new Path(name),node)}));return viewProcessorApplyServerMerge(viewProcessor,viewCache,ackPath,changedChildren,writesCache,completeCache,filterServerNode,accumulator)}else{return viewCache}}else{let changedChildren=new ImmutableTree(null);affectedTree.foreach(((mergePath,value)=>{const serverCachePath=pathChild(ackPath,mergePath);if(serverCache.isCompleteForPath(serverCachePath)){changedChildren=changedChildren.set(mergePath,serverCache.getNode().getChild(serverCachePath))}}));return viewProcessorApplyServerMerge(viewProcessor,viewCache,ackPath,changedChildren,writesCache,completeCache,filterServerNode,accumulator)}}function viewProcessorListenComplete(viewProcessor,viewCache,path,writesCache,accumulator){const oldServerNode=viewCache.serverCache;const newViewCache=viewCacheUpdateServerSnap(viewCache,oldServerNode.getNode(),oldServerNode.isFullyInitialized()||pathIsEmpty(path),oldServerNode.isFiltered());return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,newViewCache,path,writesCache,NO_COMPLETE_CHILD_SOURCE,accumulator)}function viewProcessorRevertUserWrite(viewProcessor,viewCache,path,writesCache,completeServerCache,accumulator){let complete;if(writeTreeRefShadowingWrite(writesCache,path)!=null){return viewCache}else{const source=new WriteTreeCompleteChildSource(writesCache,viewCache,completeServerCache);const oldEventCache=viewCache.eventCache.getNode();let newEventCache;if(pathIsEmpty(path)||pathGetFront(path)===".priority"){let newNode;if(viewCache.serverCache.isFullyInitialized()){newNode=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(viewCache))}else{const serverChildren=viewCache.serverCache.getNode();(0,_util.assert)(serverChildren instanceof ChildrenNode,"serverChildren would be complete if leaf node");newNode=writeTreeRefCalcCompleteEventChildren(writesCache,serverChildren)}newNode=newNode;newEventCache=viewProcessor.filter.updateFullNode(oldEventCache,newNode,accumulator)}else{const childKey=pathGetFront(path);let newChild=writeTreeRefCalcCompleteChild(writesCache,childKey,viewCache.serverCache);if(newChild==null&&viewCache.serverCache.isCompleteForChild(childKey)){newChild=oldEventCache.getImmediateChild(childKey)}if(newChild!=null){newEventCache=viewProcessor.filter.updateChild(oldEventCache,childKey,newChild,pathPopFront(path),source,accumulator)}else if(viewCache.eventCache.getNode().hasChild(childKey)){newEventCache=viewProcessor.filter.updateChild(oldEventCache,childKey,ChildrenNode.EMPTY_NODE,pathPopFront(path),source,accumulator)}else{newEventCache=oldEventCache}if(newEventCache.isEmpty()&&viewCache.serverCache.isFullyInitialized()){complete=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(viewCache));if(complete.isLeafNode()){newEventCache=viewProcessor.filter.updateFullNode(newEventCache,complete,accumulator)}}}complete=viewCache.serverCache.isFullyInitialized()||writeTreeRefShadowingWrite(writesCache,newEmptyPath())!=null;return viewCacheUpdateEventSnap(viewCache,newEventCache,complete,viewProcessor.filter.filtersNodes())}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class View{constructor(query_,initialViewCache){this.query_=query_;this.eventRegistrations_=[];const params=this.query_._queryParams;const indexFilter=new IndexedFilter(params.getIndex());const filter=queryParamsGetNodeFilter(params);this.processor_=newViewProcessor(filter);const initialServerCache=initialViewCache.serverCache;const initialEventCache=initialViewCache.eventCache;const serverSnap=indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE,initialServerCache.getNode(),null);const eventSnap=filter.updateFullNode(ChildrenNode.EMPTY_NODE,initialEventCache.getNode(),null);const newServerCache=new CacheNode(serverSnap,initialServerCache.isFullyInitialized(),indexFilter.filtersNodes());const newEventCache=new CacheNode(eventSnap,initialEventCache.isFullyInitialized(),filter.filtersNodes());this.viewCache_=newViewCache(newEventCache,newServerCache);this.eventGenerator_=new EventGenerator(this.query_)}get query(){return this.query_}}function viewGetServerCache(view){return view.viewCache_.serverCache.getNode()}function viewGetCompleteNode(view){return viewCacheGetCompleteEventSnap(view.viewCache_)}function viewGetCompleteServerCache(view,path){const cache=viewCacheGetCompleteServerSnap(view.viewCache_);if(cache){if(view.query._queryParams.loadsAllData()||!pathIsEmpty(path)&&!cache.getImmediateChild(pathGetFront(path)).isEmpty()){return cache.getChild(path)}}return null}function viewIsEmpty(view){return view.eventRegistrations_.length===0}function viewAddEventRegistration(view,eventRegistration){view.eventRegistrations_.push(eventRegistration)}function viewRemoveEventRegistration(view,eventRegistration,cancelError){const cancelEvents=[];if(cancelError){(0,_util.assert)(eventRegistration==null,"A cancel should cancel all event registrations.");const path=view.query._path;view.eventRegistrations_.forEach((registration=>{const maybeEvent=registration.createCancelEvent(cancelError,path);if(maybeEvent){cancelEvents.push(maybeEvent)}}))}if(eventRegistration){let remaining=[];for(let i=0;i<view.eventRegistrations_.length;++i){const existing=view.eventRegistrations_[i];if(!existing.matches(eventRegistration)){remaining.push(existing)}else if(eventRegistration.hasAnyCallback()){remaining=remaining.concat(view.eventRegistrations_.slice(i+1));break}}view.eventRegistrations_=remaining}else{view.eventRegistrations_=[]}return cancelEvents}function viewApplyOperation(view,operation,writesCache,completeServerCache){if(operation.type===OperationType.MERGE&&operation.source.queryId!==null){(0,_util.assert)(viewCacheGetCompleteServerSnap(view.viewCache_),"We should always have a full cache before handling merges");(0,_util.assert)(viewCacheGetCompleteEventSnap(view.viewCache_),"Missing event cache, even though we have a server cache")}const oldViewCache=view.viewCache_;const result=viewProcessorApplyOperation(view.processor_,oldViewCache,operation,writesCache,completeServerCache);viewProcessorAssertIndexed(view.processor_,result.viewCache);(0,_util.assert)(result.viewCache.serverCache.isFullyInitialized()||!oldViewCache.serverCache.isFullyInitialized(),"Once a server snap is complete, it should never go back");view.viewCache_=result.viewCache;return viewGenerateEventsForChanges_(view,result.changes,result.viewCache.eventCache.getNode(),null)}function viewGetInitialEvents(view,registration){const eventSnap=view.viewCache_.eventCache;const initialChanges=[];if(!eventSnap.getNode().isLeafNode()){const eventNode=eventSnap.getNode();eventNode.forEachChild(PRIORITY_INDEX,((key,childNode)=>{initialChanges.push(changeChildAdded(key,childNode))}))}if(eventSnap.isFullyInitialized()){initialChanges.push(changeValue(eventSnap.getNode()))}return viewGenerateEventsForChanges_(view,initialChanges,eventSnap.getNode(),registration)}function viewGenerateEventsForChanges_(view,changes,eventCache,eventRegistration){const registrations=eventRegistration?[eventRegistration]:view.eventRegistrations_;return eventGeneratorGenerateEventsForChanges(view.eventGenerator_,changes,eventCache,registrations)}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let referenceConstructor$1;class SyncPoint{constructor(){this.views=new Map}}function syncPointSetReferenceConstructor(val){(0,_util.assert)(!referenceConstructor$1,"__referenceConstructor has already been defined");referenceConstructor$1=val}function syncPointGetReferenceConstructor(){(0,_util.assert)(referenceConstructor$1,"Reference.ts has not been loaded");return referenceConstructor$1}function syncPointIsEmpty(syncPoint){return syncPoint.views.size===0}function syncPointApplyOperation(syncPoint,operation,writesCache,optCompleteServerCache){const queryId=operation.source.queryId;if(queryId!==null){const view=syncPoint.views.get(queryId);(0,_util.assert)(view!=null,"SyncTree gave us an op for an invalid query.");return viewApplyOperation(view,operation,writesCache,optCompleteServerCache)}else{let events=[];for(const view of syncPoint.views.values()){events=events.concat(viewApplyOperation(view,operation,writesCache,optCompleteServerCache))}return events}}function syncPointGetView(syncPoint,query,writesCache,serverCache,serverCacheComplete){const queryId=query._queryIdentifier;const view=syncPoint.views.get(queryId);if(!view){let eventCache=writeTreeRefCalcCompleteEventCache(writesCache,serverCacheComplete?serverCache:null);let eventCacheComplete=false;if(eventCache){eventCacheComplete=true}else if(serverCache instanceof ChildrenNode){eventCache=writeTreeRefCalcCompleteEventChildren(writesCache,serverCache);eventCacheComplete=false}else{eventCache=ChildrenNode.EMPTY_NODE;eventCacheComplete=false}const viewCache=newViewCache(new CacheNode(eventCache,eventCacheComplete,false),new CacheNode(serverCache,serverCacheComplete,false));return new View(query,viewCache)}return view}function syncPointAddEventRegistration(syncPoint,query,eventRegistration,writesCache,serverCache,serverCacheComplete){const view=syncPointGetView(syncPoint,query,writesCache,serverCache,serverCacheComplete);if(!syncPoint.views.has(query._queryIdentifier)){syncPoint.views.set(query._queryIdentifier,view)}viewAddEventRegistration(view,eventRegistration);return viewGetInitialEvents(view,eventRegistration)}function syncPointRemoveEventRegistration(syncPoint,query,eventRegistration,cancelError){const queryId=query._queryIdentifier;const removed=[];let cancelEvents=[];const hadCompleteView=syncPointHasCompleteView(syncPoint);if(queryId==="default"){for(const[viewQueryId,view]of syncPoint.views.entries()){cancelEvents=cancelEvents.concat(viewRemoveEventRegistration(view,eventRegistration,cancelError));if(viewIsEmpty(view)){syncPoint.views.delete(viewQueryId);if(!view.query._queryParams.loadsAllData()){removed.push(view.query)}}}}else{const view=syncPoint.views.get(queryId);if(view){cancelEvents=cancelEvents.concat(viewRemoveEventRegistration(view,eventRegistration,cancelError));if(viewIsEmpty(view)){syncPoint.views.delete(queryId);if(!view.query._queryParams.loadsAllData()){removed.push(view.query)}}}}if(hadCompleteView&&!syncPointHasCompleteView(syncPoint)){removed.push(new(syncPointGetReferenceConstructor())(query._repo,query._path))}return{removed:removed,events:cancelEvents}}function syncPointGetQueryViews(syncPoint){const result=[];for(const view of syncPoint.views.values()){if(!view.query._queryParams.loadsAllData()){result.push(view)}}return result}function syncPointGetCompleteServerCache(syncPoint,path){let serverCache=null;for(const view of syncPoint.views.values()){serverCache=serverCache||viewGetCompleteServerCache(view,path)}return serverCache}function syncPointViewForQuery(syncPoint,query){const params=query._queryParams;if(params.loadsAllData()){return syncPointGetCompleteView(syncPoint)}else{const queryId=query._queryIdentifier;return syncPoint.views.get(queryId)}}function syncPointViewExistsForQuery(syncPoint,query){return syncPointViewForQuery(syncPoint,query)!=null}function syncPointHasCompleteView(syncPoint){return syncPointGetCompleteView(syncPoint)!=null}function syncPointGetCompleteView(syncPoint){for(const view of syncPoint.views.values()){if(view.query._queryParams.loadsAllData()){return view}}return null}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let referenceConstructor;function syncTreeSetReferenceConstructor(val){(0,_util.assert)(!referenceConstructor,"__referenceConstructor has already been defined");referenceConstructor=val}function syncTreeGetReferenceConstructor(){(0,_util.assert)(referenceConstructor,"Reference.ts has not been loaded");return referenceConstructor}let syncTreeNextQueryTag_=1;class SyncTree{constructor(listenProvider_){this.listenProvider_=listenProvider_;this.syncPointTree_=new ImmutableTree(null);this.pendingWriteTree_=newWriteTree();this.tagToQueryMap=new Map;this.queryToTagMap=new Map}}function syncTreeApplyUserOverwrite(syncTree,path,newData,writeId,visible){writeTreeAddOverwrite(syncTree.pendingWriteTree_,path,newData,writeId,visible);if(!visible){return[]}else{return syncTreeApplyOperationToSyncPoints_(syncTree,new Overwrite(newOperationSourceUser(),path,newData))}}function syncTreeApplyUserMerge(syncTree,path,changedChildren,writeId){writeTreeAddMerge(syncTree.pendingWriteTree_,path,changedChildren,writeId);const changeTree=ImmutableTree.fromObject(changedChildren);return syncTreeApplyOperationToSyncPoints_(syncTree,new Merge(newOperationSourceUser(),path,changeTree))}function syncTreeAckUserWrite(syncTree,writeId,revert=false){const write=writeTreeGetWrite(syncTree.pendingWriteTree_,writeId);const needToReevaluate=writeTreeRemoveWrite(syncTree.pendingWriteTree_,writeId);if(!needToReevaluate){return[]}else{let affectedTree=new ImmutableTree(null);if(write.snap!=null){affectedTree=affectedTree.set(newEmptyPath(),true)}else{each(write.children,(pathString=>{affectedTree=affectedTree.set(new Path(pathString),true)}))}return syncTreeApplyOperationToSyncPoints_(syncTree,new AckUserWrite(write.path,affectedTree,revert))}}function syncTreeApplyServerOverwrite(syncTree,path,newData){return syncTreeApplyOperationToSyncPoints_(syncTree,new Overwrite(newOperationSourceServer(),path,newData))}function syncTreeApplyServerMerge(syncTree,path,changedChildren){const changeTree=ImmutableTree.fromObject(changedChildren);return syncTreeApplyOperationToSyncPoints_(syncTree,new Merge(newOperationSourceServer(),path,changeTree))}function syncTreeApplyListenComplete(syncTree,path){return syncTreeApplyOperationToSyncPoints_(syncTree,new ListenComplete(newOperationSourceServer(),path))}function syncTreeApplyTaggedListenComplete(syncTree,path,tag){const queryKey=syncTreeQueryKeyForTag_(syncTree,tag);if(queryKey){const r=syncTreeParseQueryKey_(queryKey);const queryPath=r.path,queryId=r.queryId;const relativePath=newRelativePath(queryPath,path);const op=new ListenComplete(newOperationSourceServerTaggedQuery(queryId),relativePath);return syncTreeApplyTaggedOperation_(syncTree,queryPath,op)}else{return[]}}function syncTreeRemoveEventRegistration(syncTree,query,eventRegistration,cancelError,skipListenerDedup=false){const path=query._path;const maybeSyncPoint=syncTree.syncPointTree_.get(path);let cancelEvents=[];if(maybeSyncPoint&&(query._queryIdentifier==="default"||syncPointViewExistsForQuery(maybeSyncPoint,query))){const removedAndEvents=syncPointRemoveEventRegistration(maybeSyncPoint,query,eventRegistration,cancelError);if(syncPointIsEmpty(maybeSyncPoint)){syncTree.syncPointTree_=syncTree.syncPointTree_.remove(path)}const removed=removedAndEvents.removed;cancelEvents=removedAndEvents.events;if(!skipListenerDedup){const removingDefault=-1!==removed.findIndex((query=>query._queryParams.loadsAllData()));const covered=syncTree.syncPointTree_.findOnPath(path,((relativePath,parentSyncPoint)=>syncPointHasCompleteView(parentSyncPoint)));if(removingDefault&&!covered){const subtree=syncTree.syncPointTree_.subtree(path);if(!subtree.isEmpty()){const newViews=syncTreeCollectDistinctViewsForSubTree_(subtree);for(let i=0;i<newViews.length;++i){const view=newViews[i],newQuery=view.query;const listener=syncTreeCreateListenerForView_(syncTree,view);syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery),syncTreeTagForQuery(syncTree,newQuery),listener.hashFn,listener.onComplete)}}}if(!covered&&removed.length>0&&!cancelError){if(removingDefault){const defaultTag=null;syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query),defaultTag)}else{removed.forEach((queryToRemove=>{const tagToRemove=syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove),tagToRemove)}))}}}syncTreeRemoveTags_(syncTree,removed)}return cancelEvents}function syncTreeApplyTaggedQueryOverwrite(syncTree,path,snap,tag){const queryKey=syncTreeQueryKeyForTag_(syncTree,tag);if(queryKey!=null){const r=syncTreeParseQueryKey_(queryKey);const queryPath=r.path,queryId=r.queryId;const relativePath=newRelativePath(queryPath,path);const op=new Overwrite(newOperationSourceServerTaggedQuery(queryId),relativePath,snap);return syncTreeApplyTaggedOperation_(syncTree,queryPath,op)}else{return[]}}function syncTreeApplyTaggedQueryMerge(syncTree,path,changedChildren,tag){const queryKey=syncTreeQueryKeyForTag_(syncTree,tag);if(queryKey){const r=syncTreeParseQueryKey_(queryKey);const queryPath=r.path,queryId=r.queryId;const relativePath=newRelativePath(queryPath,path);const changeTree=ImmutableTree.fromObject(changedChildren);const op=new Merge(newOperationSourceServerTaggedQuery(queryId),relativePath,changeTree);return syncTreeApplyTaggedOperation_(syncTree,queryPath,op)}else{return[]}}function syncTreeAddEventRegistration(syncTree,query,eventRegistration,skipSetupListener=false){const path=query._path;let serverCache=null;let foundAncestorDefaultView=false;syncTree.syncPointTree_.foreachOnPath(path,((pathToSyncPoint,sp)=>{const relativePath=newRelativePath(pathToSyncPoint,path);serverCache=serverCache||syncPointGetCompleteServerCache(sp,relativePath);foundAncestorDefaultView=foundAncestorDefaultView||syncPointHasCompleteView(sp)}));let syncPoint=syncTree.syncPointTree_.get(path);if(!syncPoint){syncPoint=new SyncPoint;syncTree.syncPointTree_=syncTree.syncPointTree_.set(path,syncPoint)}else{foundAncestorDefaultView=foundAncestorDefaultView||syncPointHasCompleteView(syncPoint);serverCache=serverCache||syncPointGetCompleteServerCache(syncPoint,newEmptyPath())}let serverCacheComplete;if(serverCache!=null){serverCacheComplete=true}else{serverCacheComplete=false;serverCache=ChildrenNode.EMPTY_NODE;const subtree=syncTree.syncPointTree_.subtree(path);subtree.foreachChild(((childName,childSyncPoint)=>{const completeCache=syncPointGetCompleteServerCache(childSyncPoint,newEmptyPath());if(completeCache){serverCache=serverCache.updateImmediateChild(childName,completeCache)}}))}const viewAlreadyExists=syncPointViewExistsForQuery(syncPoint,query);if(!viewAlreadyExists&&!query._queryParams.loadsAllData()){const queryKey=syncTreeMakeQueryKey_(query);(0,_util.assert)(!syncTree.queryToTagMap.has(queryKey),"View does not exist, but we have a tag");const tag=syncTreeGetNextQueryTag_();syncTree.queryToTagMap.set(queryKey,tag);syncTree.tagToQueryMap.set(tag,queryKey)}const writesCache=writeTreeChildWrites(syncTree.pendingWriteTree_,path);let events=syncPointAddEventRegistration(syncPoint,query,eventRegistration,writesCache,serverCache,serverCacheComplete);if(!viewAlreadyExists&&!foundAncestorDefaultView&&!skipSetupListener){const view=syncPointViewForQuery(syncPoint,query);events=events.concat(syncTreeSetupListener_(syncTree,query,view))}return events}function syncTreeCalcCompleteEventCache(syncTree,path,writeIdsToExclude){const includeHiddenSets=true;const writeTree=syncTree.pendingWriteTree_;const serverCache=syncTree.syncPointTree_.findOnPath(path,((pathSoFar,syncPoint)=>{const relativePath=newRelativePath(pathSoFar,path);const serverCache=syncPointGetCompleteServerCache(syncPoint,relativePath);if(serverCache){return serverCache}}));return writeTreeCalcCompleteEventCache(writeTree,path,serverCache,writeIdsToExclude,includeHiddenSets)}function syncTreeGetServerValue(syncTree,query){const path=query._path;let serverCache=null;syncTree.syncPointTree_.foreachOnPath(path,((pathToSyncPoint,sp)=>{const relativePath=newRelativePath(pathToSyncPoint,path);serverCache=serverCache||syncPointGetCompleteServerCache(sp,relativePath)}));let syncPoint=syncTree.syncPointTree_.get(path);if(!syncPoint){syncPoint=new SyncPoint;syncTree.syncPointTree_=syncTree.syncPointTree_.set(path,syncPoint)}else{serverCache=serverCache||syncPointGetCompleteServerCache(syncPoint,newEmptyPath())}const serverCacheComplete=serverCache!=null;const serverCacheNode=serverCacheComplete?new CacheNode(serverCache,true,false):null;const writesCache=writeTreeChildWrites(syncTree.pendingWriteTree_,query._path);const view=syncPointGetView(syncPoint,query,writesCache,serverCacheComplete?serverCacheNode.getNode():ChildrenNode.EMPTY_NODE,serverCacheComplete);return viewGetCompleteNode(view)}function syncTreeApplyOperationToSyncPoints_(syncTree,operation){return syncTreeApplyOperationHelper_(operation,syncTree.syncPointTree_,null,writeTreeChildWrites(syncTree.pendingWriteTree_,newEmptyPath()))}function syncTreeApplyOperationHelper_(operation,syncPointTree,serverCache,writesCache){if(pathIsEmpty(operation.path)){return syncTreeApplyOperationDescendantsHelper_(operation,syncPointTree,serverCache,writesCache)}else{const syncPoint=syncPointTree.get(newEmptyPath());if(serverCache==null&&syncPoint!=null){serverCache=syncPointGetCompleteServerCache(syncPoint,newEmptyPath())}let events=[];const childName=pathGetFront(operation.path);const childOperation=operation.operationForChild(childName);const childTree=syncPointTree.children.get(childName);if(childTree&&childOperation){const childServerCache=serverCache?serverCache.getImmediateChild(childName):null;const childWritesCache=writeTreeRefChild(writesCache,childName);events=events.concat(syncTreeApplyOperationHelper_(childOperation,childTree,childServerCache,childWritesCache))}if(syncPoint){events=events.concat(syncPointApplyOperation(syncPoint,operation,writesCache,serverCache))}return events}}function syncTreeApplyOperationDescendantsHelper_(operation,syncPointTree,serverCache,writesCache){const syncPoint=syncPointTree.get(newEmptyPath());if(serverCache==null&&syncPoint!=null){serverCache=syncPointGetCompleteServerCache(syncPoint,newEmptyPath())}let events=[];syncPointTree.children.inorderTraversal(((childName,childTree)=>{const childServerCache=serverCache?serverCache.getImmediateChild(childName):null;const childWritesCache=writeTreeRefChild(writesCache,childName);const childOperation=operation.operationForChild(childName);if(childOperation){events=events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation,childTree,childServerCache,childWritesCache))}}));if(syncPoint){events=events.concat(syncPointApplyOperation(syncPoint,operation,writesCache,serverCache))}return events}function syncTreeCreateListenerForView_(syncTree,view){const query=view.query;const tag=syncTreeTagForQuery(syncTree,query);return{hashFn:()=>{const cache=viewGetServerCache(view)||ChildrenNode.EMPTY_NODE;return cache.hash()},onComplete:status=>{if(status==="ok"){if(tag){return syncTreeApplyTaggedListenComplete(syncTree,query._path,tag)}else{return syncTreeApplyListenComplete(syncTree,query._path)}}else{const error=errorForServerCode(status,query);return syncTreeRemoveEventRegistration(syncTree,query,null,error)}}}}function syncTreeTagForQuery(syncTree,query){const queryKey=syncTreeMakeQueryKey_(query);return syncTree.queryToTagMap.get(queryKey)}function syncTreeMakeQueryKey_(query){return query._path.toString()+"$"+query._queryIdentifier}function syncTreeQueryKeyForTag_(syncTree,tag){return syncTree.tagToQueryMap.get(tag)}function syncTreeParseQueryKey_(queryKey){const splitIndex=queryKey.indexOf("$");(0,_util.assert)(splitIndex!==-1&&splitIndex<queryKey.length-1,"Bad queryKey.");return{queryId:queryKey.substr(splitIndex+1),path:new Path(queryKey.substr(0,splitIndex))}}function syncTreeApplyTaggedOperation_(syncTree,queryPath,operation){const syncPoint=syncTree.syncPointTree_.get(queryPath);(0,_util.assert)(syncPoint,"Missing sync point for query tag that we're tracking");const writesCache=writeTreeChildWrites(syncTree.pendingWriteTree_,queryPath);return syncPointApplyOperation(syncPoint,operation,writesCache,null)}function syncTreeCollectDistinctViewsForSubTree_(subtree){return subtree.fold(((relativePath,maybeChildSyncPoint,childMap)=>{if(maybeChildSyncPoint&&syncPointHasCompleteView(maybeChildSyncPoint)){const completeView=syncPointGetCompleteView(maybeChildSyncPoint);return[completeView]}else{let views=[];if(maybeChildSyncPoint){views=syncPointGetQueryViews(maybeChildSyncPoint)}each(childMap,((_key,childViews)=>{views=views.concat(childViews)}));return views}}))}function syncTreeQueryForListening_(query){if(query._queryParams.loadsAllData()&&!query._queryParams.isDefault()){return new(syncTreeGetReferenceConstructor())(query._repo,query._path)}else{return query}}function syncTreeRemoveTags_(syncTree,queries){for(let j=0;j<queries.length;++j){const removedQuery=queries[j];if(!removedQuery._queryParams.loadsAllData()){const removedQueryKey=syncTreeMakeQueryKey_(removedQuery);const removedQueryTag=syncTree.queryToTagMap.get(removedQueryKey);syncTree.queryToTagMap.delete(removedQueryKey);syncTree.tagToQueryMap.delete(removedQueryTag)}}}function syncTreeGetNextQueryTag_(){return syncTreeNextQueryTag_++}function syncTreeSetupListener_(syncTree,query,view){const path=query._path;const tag=syncTreeTagForQuery(syncTree,query);const listener=syncTreeCreateListenerForView_(syncTree,view);const events=syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query),tag,listener.hashFn,listener.onComplete);const subtree=syncTree.syncPointTree_.subtree(path);if(tag){(0,_util.assert)(!syncPointHasCompleteView(subtree.value),"If we're adding a query, it shouldn't be shadowed")}else{const queriesToStop=subtree.fold(((relativePath,maybeChildSyncPoint,childMap)=>{if(!pathIsEmpty(relativePath)&&maybeChildSyncPoint&&syncPointHasCompleteView(maybeChildSyncPoint)){return[syncPointGetCompleteView(maybeChildSyncPoint).query]}else{let queries=[];if(maybeChildSyncPoint){queries=queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map((view=>view.query)))}each(childMap,((_key,childQueries)=>{queries=queries.concat(childQueries)}));return queries}}));for(let i=0;i<queriesToStop.length;++i){const queryToStop=queriesToStop[i];syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop),syncTreeTagForQuery(syncTree,queryToStop))}}return events}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ExistingValueProvider{constructor(node_){this.node_=node_}getImmediateChild(childName){const child=this.node_.getImmediateChild(childName);return new ExistingValueProvider(child)}node(){return this.node_}}class DeferredValueProvider{constructor(syncTree,path){this.syncTree_=syncTree;this.path_=path}getImmediateChild(childName){const childPath=pathChild(this.path_,childName);return new DeferredValueProvider(this.syncTree_,childPath)}node(){return syncTreeCalcCompleteEventCache(this.syncTree_,this.path_)}}const generateWithValues=function(values){values=values||{};values["timestamp"]=values["timestamp"]||(new Date).getTime();return values};const resolveDeferredLeafValue=function(value,existingVal,serverValues){if(!value||typeof value!=="object"){return value}(0,_util.assert)(".sv"in value,"Unexpected leaf node or priority contents");if(typeof value[".sv"]==="string"){return resolveScalarDeferredValue(value[".sv"],existingVal,serverValues)}else if(typeof value[".sv"]==="object"){return resolveComplexDeferredValue(value[".sv"],existingVal)}else{(0,_util.assert)(false,"Unexpected server value: "+JSON.stringify(value,null,2))}};const resolveScalarDeferredValue=function(op,existing,serverValues){switch(op){case"timestamp":return serverValues["timestamp"];default:(0,_util.assert)(false,"Unexpected server value: "+op)}};const resolveComplexDeferredValue=function(op,existing,unused){if(!op.hasOwnProperty("increment")){(0,_util.assert)(false,"Unexpected server value: "+JSON.stringify(op,null,2))}const delta=op["increment"];if(typeof delta!=="number"){(0,_util.assert)(false,"Unexpected increment value: "+delta)}const existingNode=existing.node();(0,_util.assert)(existingNode!==null&&typeof existingNode!=="undefined","Expected ChildrenNode.EMPTY_NODE for nulls");if(!existingNode.isLeafNode()){return delta}const leaf=existingNode;const existingVal=leaf.getValue();if(typeof existingVal!=="number"){return delta}return existingVal+delta};const resolveDeferredValueTree=function(path,node,syncTree,serverValues){return resolveDeferredValue(node,new DeferredValueProvider(syncTree,path),serverValues)};const resolveDeferredValueSnapshot=function(node,existing,serverValues){return resolveDeferredValue(node,new ExistingValueProvider(existing),serverValues)};function resolveDeferredValue(node,existingVal,serverValues){const rawPri=node.getPriority().val();const priority=resolveDeferredLeafValue(rawPri,existingVal.getImmediateChild(".priority"),serverValues);let newNode;if(node.isLeafNode()){const leafNode=node;const value=resolveDeferredLeafValue(leafNode.getValue(),existingVal,serverValues);if(value!==leafNode.getValue()||priority!==leafNode.getPriority().val()){return new LeafNode(value,nodeFromJSON(priority))}else{return node}}else{const childrenNode=node;newNode=childrenNode;if(priority!==childrenNode.getPriority().val()){newNode=newNode.updatePriority(new LeafNode(priority))}childrenNode.forEachChild(PRIORITY_INDEX,((childName,childNode)=>{const newChildNode=resolveDeferredValue(childNode,existingVal.getImmediateChild(childName),serverValues);if(newChildNode!==childNode){newNode=newNode.updateImmediateChild(childName,newChildNode)}}));return newNode}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Tree{constructor(name="",parent=null,node={children:{},childCount:0}){this.name=name;this.parent=parent;this.node=node}}function treeSubTree(tree,pathObj){let path=pathObj instanceof Path?pathObj:new Path(pathObj);let child=tree,next=pathGetFront(path);while(next!==null){const childNode=(0,_util.safeGet)(child.node.children,next)||{children:{},childCount:0};child=new Tree(next,child,childNode);path=pathPopFront(path);next=pathGetFront(path)}return child}function treeGetValue(tree){return tree.node.value}function treeSetValue(tree,value){tree.node.value=value;treeUpdateParents(tree)}function treeHasChildren(tree){return tree.node.childCount>0}function treeIsEmpty(tree){return treeGetValue(tree)===undefined&&!treeHasChildren(tree)}function treeForEachChild(tree,action){each(tree.node.children,((child,childTree)=>{action(new Tree(child,tree,childTree))}))}function treeForEachDescendant(tree,action,includeSelf,childrenFirst){if(includeSelf&&!childrenFirst){action(tree)}treeForEachChild(tree,(child=>{treeForEachDescendant(child,action,true,childrenFirst)}));if(includeSelf&&childrenFirst){action(tree)}}function treeForEachAncestor(tree,action,includeSelf){let node=includeSelf?tree:tree.parent;while(node!==null){if(action(node)){return true}node=node.parent}return false}function treeGetPath(tree){return new Path(tree.parent===null?tree.name:treeGetPath(tree.parent)+"/"+tree.name)}function treeUpdateParents(tree){if(tree.parent!==null){treeUpdateChild(tree.parent,tree.name,tree)}}function treeUpdateChild(tree,childName,child){const childEmpty=treeIsEmpty(child);const childExists=(0,_util.contains)(tree.node.children,childName);if(childEmpty&&childExists){delete tree.node.children[childName];tree.node.childCount--;treeUpdateParents(tree)}else if(!childEmpty&&!childExists){tree.node.children[childName]=child.node;tree.node.childCount++;treeUpdateParents(tree)}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const INVALID_KEY_REGEX_=/[\[\].#$\/\u0000-\u001F\u007F]/;const INVALID_PATH_REGEX_=/[\[\].#$\u0000-\u001F\u007F]/;const MAX_LEAF_SIZE_=10*1024*1024;const isValidKey=function(key){return typeof key==="string"&&key.length!==0&&!INVALID_KEY_REGEX_.test(key)};const isValidPathString=function(pathString){return typeof pathString==="string"&&pathString.length!==0&&!INVALID_PATH_REGEX_.test(pathString)};const isValidRootPathString=function(pathString){if(pathString){pathString=pathString.replace(/^\/*\.info(\/|$)/,"/")}return isValidPathString(pathString)};const isValidPriority=function(priority){return priority===null||typeof priority==="string"||typeof priority==="number"&&!isInvalidJSONNumber(priority)||priority&&typeof priority==="object"&&(0,_util.contains)(priority,".sv")};const validateFirebaseDataArg=function(fnName,value,path,optional){if(optional&&value===undefined){return}validateFirebaseData((0,_util.errorPrefix)(fnName,"value"),value,path)};const validateFirebaseData=function(errorPrefix,data,path_){const path=path_ instanceof Path?new ValidationPath(path_,errorPrefix):path_;if(data===undefined){throw new Error(errorPrefix+"contains undefined "+validationPathToErrorString(path))}if(typeof data==="function"){throw new Error(errorPrefix+"contains a function "+validationPathToErrorString(path)+" with contents = "+data.toString())}if(isInvalidJSONNumber(data)){throw new Error(errorPrefix+"contains "+data.toString()+" "+validationPathToErrorString(path))}if(typeof data==="string"&&data.length>MAX_LEAF_SIZE_/3&&(0,_util.stringLength)(data)>MAX_LEAF_SIZE_){throw new Error(errorPrefix+"contains a string greater than "+MAX_LEAF_SIZE_+" utf8 bytes "+validationPathToErrorString(path)+" ('"+data.substring(0,50)+"...')")}if(data&&typeof data==="object"){let hasDotValue=false;let hasActualChild=false;each(data,((key,value)=>{if(key===".value"){hasDotValue=true}else if(key!==".priority"&&key!==".sv"){hasActualChild=true;if(!isValidKey(key)){throw new Error(errorPrefix+" contains an invalid key ("+key+") "+validationPathToErrorString(path)+".  Keys must be non-empty strings "+'and can\'t contain ".", "#", "$", "/", "[", or "]"')}}validationPathPush(path,key);validateFirebaseData(errorPrefix,value,path);validationPathPop(path)}));if(hasDotValue&&hasActualChild){throw new Error(errorPrefix+' contains ".value" child '+validationPathToErrorString(path)+" in addition to actual children.")}}};const validateFirebaseMergePaths=function(errorPrefix,mergePaths){let i,curPath;for(i=0;i<mergePaths.length;i++){curPath=mergePaths[i];const keys=pathSlice(curPath);for(let j=0;j<keys.length;j++){if(keys[j]===".priority"&&j===keys.length-1);else if(!isValidKey(keys[j])){throw new Error(errorPrefix+"contains an invalid key ("+keys[j]+") in path "+curPath.toString()+". Keys must be non-empty strings "+'and can\'t contain ".", "#", "$", "/", "[", or "]"')}}}mergePaths.sort(pathCompare);let prevPath=null;for(i=0;i<mergePaths.length;i++){curPath=mergePaths[i];if(prevPath!==null&&pathContains(prevPath,curPath)){throw new Error(errorPrefix+"contains a path "+prevPath.toString()+" that is ancestor of another path "+curPath.toString())}prevPath=curPath}};const validateFirebaseMergeDataArg=function(fnName,data,path,optional){if(optional&&data===undefined){return}const errorPrefix$1=(0,_util.errorPrefix)(fnName,"values");if(!(data&&typeof data==="object")||Array.isArray(data)){throw new Error(errorPrefix$1+" must be an object containing the children to replace.")}const mergePaths=[];each(data,((key,value)=>{const curPath=new Path(key);validateFirebaseData(errorPrefix$1,value,pathChild(path,curPath));if(pathGetBack(curPath)===".priority"){if(!isValidPriority(value)){throw new Error(errorPrefix$1+"contains an invalid value for '"+curPath.toString()+"', which must be a valid "+"Firebase priority (a string, finite number, server value, or null).")}}mergePaths.push(curPath)}));validateFirebaseMergePaths(errorPrefix$1,mergePaths)};const validatePriority=function(fnName,priority,optional){if(optional&&priority===undefined){return}if(isInvalidJSONNumber(priority)){throw new Error((0,_util.errorPrefix)(fnName,"priority")+"is "+priority.toString()+", but must be a valid Firebase priority (a string, finite number, "+"server value, or null).")}if(!isValidPriority(priority)){throw new Error((0,_util.errorPrefix)(fnName,"priority")+"must be a valid Firebase priority "+"(a string, finite number, server value, or null).")}};const validateKey=function(fnName,argumentName,key,optional){if(optional&&key===undefined){return}if(!isValidKey(key)){throw new Error((0,_util.errorPrefix)(fnName,argumentName)+'was an invalid key = "'+key+'".  Firebase keys must be non-empty strings and '+'can\'t contain ".", "#", "$", "/", "[", or "]").')}};const validatePathString=function(fnName,argumentName,pathString,optional){if(optional&&pathString===undefined){return}if(!isValidPathString(pathString)){throw new Error((0,_util.errorPrefix)(fnName,argumentName)+'was an invalid path = "'+pathString+'". Paths must be non-empty strings and '+'can\'t contain ".", "#", "$", "[", or "]"')}};exports._validatePathString=validatePathString;const validateRootPathString=function(fnName,argumentName,pathString,optional){if(pathString){pathString=pathString.replace(/^\/*\.info(\/|$)/,"/")}validatePathString(fnName,argumentName,pathString,optional)};const validateWritablePath=function(fnName,path){if(pathGetFront(path)===".info"){throw new Error(fnName+" failed = Can't modify data under /.info/")}};exports._validateWritablePath=validateWritablePath;const validateUrl=function(fnName,parsedUrl){const pathString=parsedUrl.path.toString();if(!(typeof parsedUrl.repoInfo.host==="string")||parsedUrl.repoInfo.host.length===0||!isValidKey(parsedUrl.repoInfo.namespace)&&parsedUrl.repoInfo.host.split(":")[0]!=="localhost"||pathString.length!==0&&!isValidRootPathString(pathString)){throw new Error((0,_util.errorPrefix)(fnName,"url")+"must be a valid firebase URL and "+'the path can\'t contain ".", "#", "$", "[", or "]".')}};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class EventQueue{constructor(){this.eventLists_=[];this.recursionDepth_=0}}function eventQueueQueueEvents(eventQueue,eventDataList){let currList=null;for(let i=0;i<eventDataList.length;i++){const data=eventDataList[i];const path=data.getPath();if(currList!==null&&!pathEquals(path,currList.path)){eventQueue.eventLists_.push(currList);currList=null}if(currList===null){currList={events:[],path:path}}currList.events.push(data)}if(currList){eventQueue.eventLists_.push(currList)}}function eventQueueRaiseEventsAtPath(eventQueue,path,eventDataList){eventQueueQueueEvents(eventQueue,eventDataList);eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,(eventPath=>pathEquals(eventPath,path)))}function eventQueueRaiseEventsForChangedPath(eventQueue,changedPath,eventDataList){eventQueueQueueEvents(eventQueue,eventDataList);eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,(eventPath=>pathContains(eventPath,changedPath)||pathContains(changedPath,eventPath)))}function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,predicate){eventQueue.recursionDepth_++;let sentAll=true;for(let i=0;i<eventQueue.eventLists_.length;i++){const eventList=eventQueue.eventLists_[i];if(eventList){const eventPath=eventList.path;if(predicate(eventPath)){eventListRaise(eventQueue.eventLists_[i]);eventQueue.eventLists_[i]=null}else{sentAll=false}}}if(sentAll){eventQueue.eventLists_=[]}eventQueue.recursionDepth_--}function eventListRaise(eventList){for(let i=0;i<eventList.events.length;i++){const eventData=eventList.events[i];if(eventData!==null){eventList.events[i]=null;const eventFn=eventData.getEventRunner();if(logger){log("event: "+eventData.toString())}exceptionGuard(eventFn)}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const INTERRUPT_REASON="repo_interrupt";const MAX_TRANSACTION_RETRIES=25;class Repo{constructor(repoInfo_,forceRestClient_,authTokenProvider_,appCheckProvider_){this.repoInfo_=repoInfo_;this.forceRestClient_=forceRestClient_;this.authTokenProvider_=authTokenProvider_;this.appCheckProvider_=appCheckProvider_;this.dataUpdateCount=0;this.statsListener_=null;this.eventQueue_=new EventQueue;this.nextWriteId_=1;this.interceptServerDataCallback_=null;this.onDisconnect_=newSparseSnapshotTree();this.transactionQueueTree_=new Tree;this.persistentConnection_=null;this.key=this.repoInfo_.toURLString()}toString(){return(this.repoInfo_.secure?"https://":"http://")+this.repoInfo_.host}}function repoStart(repo,appId,authOverride){repo.stats_=statsManagerGetCollection(repo.repoInfo_);if(repo.forceRestClient_||beingCrawled()){repo.server_=new ReadonlyRestClient(repo.repoInfo_,((pathString,data,isMerge,tag)=>{repoOnDataUpdate(repo,pathString,data,isMerge,tag)}),repo.authTokenProvider_,repo.appCheckProvider_);setTimeout((()=>repoOnConnectStatus(repo,true)),0)}else{if(typeof authOverride!=="undefined"&&authOverride!==null){if(typeof authOverride!=="object"){throw new Error("Only objects are supported for option databaseAuthVariableOverride")}try{(0,_util.stringify)(authOverride)}catch(e){throw new Error("Invalid authOverride provided: "+e)}}repo.persistentConnection_=new PersistentConnection(repo.repoInfo_,appId,((pathString,data,isMerge,tag)=>{repoOnDataUpdate(repo,pathString,data,isMerge,tag)}),(connectStatus=>{repoOnConnectStatus(repo,connectStatus)}),(updates=>{repoOnServerInfoUpdate(repo,updates)}),repo.authTokenProvider_,repo.appCheckProvider_,authOverride);repo.server_=repo.persistentConnection_}repo.authTokenProvider_.addTokenChangeListener((token=>{repo.server_.refreshAuthToken(token)}));repo.appCheckProvider_.addTokenChangeListener((result=>{repo.server_.refreshAppCheckToken(result.token)}));repo.statsReporter_=statsManagerGetOrCreateReporter(repo.repoInfo_,(()=>new StatsReporter(repo.stats_,repo.server_)));repo.infoData_=new SnapshotHolder;repo.infoSyncTree_=new SyncTree({startListening:(query,tag,currentHashFn,onComplete)=>{let infoEvents=[];const node=repo.infoData_.getNode(query._path);if(!node.isEmpty()){infoEvents=syncTreeApplyServerOverwrite(repo.infoSyncTree_,query._path,node);setTimeout((()=>{onComplete("ok")}),0)}return infoEvents},stopListening:()=>{}});repoUpdateInfo(repo,"connected",false);repo.serverSyncTree_=new SyncTree({startListening:(query,tag,currentHashFn,onComplete)=>{repo.server_.listen(query,currentHashFn,tag,((status,data)=>{const events=onComplete(status,data);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,query._path,events)}));return[]},stopListening:(query,tag)=>{repo.server_.unlisten(query,tag)}})}function repoServerTime(repo){const offsetNode=repo.infoData_.getNode(new Path(".info/serverTimeOffset"));const offset=offsetNode.val()||0;return(new Date).getTime()+offset}function repoGenerateServerValues(repo){return generateWithValues({timestamp:repoServerTime(repo)})}function repoOnDataUpdate(repo,pathString,data,isMerge,tag){repo.dataUpdateCount++;const path=new Path(pathString);data=repo.interceptServerDataCallback_?repo.interceptServerDataCallback_(pathString,data):data;let events=[];if(tag){if(isMerge){const taggedChildren=(0,_util.map)(data,(raw=>nodeFromJSON(raw)));events=syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_,path,taggedChildren,tag)}else{const taggedSnap=nodeFromJSON(data);events=syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_,path,taggedSnap,tag)}}else if(isMerge){const changedChildren=(0,_util.map)(data,(raw=>nodeFromJSON(raw)));events=syncTreeApplyServerMerge(repo.serverSyncTree_,path,changedChildren)}else{const snap=nodeFromJSON(data);events=syncTreeApplyServerOverwrite(repo.serverSyncTree_,path,snap)}let affectedPath=path;if(events.length>0){affectedPath=repoRerunTransactions(repo,path)}eventQueueRaiseEventsForChangedPath(repo.eventQueue_,affectedPath,events)}function repoOnConnectStatus(repo,connectStatus){repoUpdateInfo(repo,"connected",connectStatus);if(connectStatus===false){repoRunOnDisconnectEvents(repo)}}function repoOnServerInfoUpdate(repo,updates){each(updates,((key,value)=>{repoUpdateInfo(repo,key,value)}))}function repoUpdateInfo(repo,pathString,value){const path=new Path("/.info/"+pathString);const newNode=nodeFromJSON(value);repo.infoData_.updateSnapshot(path,newNode);const events=syncTreeApplyServerOverwrite(repo.infoSyncTree_,path,newNode);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events)}function repoGetNextWriteId(repo){return repo.nextWriteId_++}function repoGetValue(repo,query,eventRegistration){const cached=syncTreeGetServerValue(repo.serverSyncTree_,query);if(cached!=null){return Promise.resolve(cached)}return repo.server_.get(query).then((payload=>{const node=nodeFromJSON(payload).withIndex(query._queryParams.getIndex());syncTreeAddEventRegistration(repo.serverSyncTree_,query,eventRegistration,true);let events;if(query._queryParams.loadsAllData()){events=syncTreeApplyServerOverwrite(repo.serverSyncTree_,query._path,node)}else{const tag=syncTreeTagForQuery(repo.serverSyncTree_,query);events=syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_,query._path,node,tag)}eventQueueRaiseEventsForChangedPath(repo.eventQueue_,query._path,events);syncTreeRemoveEventRegistration(repo.serverSyncTree_,query,eventRegistration,null,true);return node}),(err=>{repoLog(repo,"get for query "+(0,_util.stringify)(query)+" failed: "+err);return Promise.reject(new Error(err))}))}function repoSetWithPriority(repo,path,newVal,newPriority,onComplete){repoLog(repo,"set",{path:path.toString(),value:newVal,priority:newPriority});const serverValues=repoGenerateServerValues(repo);const newNodeUnresolved=nodeFromJSON(newVal,newPriority);const existing=syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path);const newNode=resolveDeferredValueSnapshot(newNodeUnresolved,existing,serverValues);const writeId=repoGetNextWriteId(repo);const events=syncTreeApplyUserOverwrite(repo.serverSyncTree_,path,newNode,writeId,true);eventQueueQueueEvents(repo.eventQueue_,events);repo.server_.put(path.toString(),newNodeUnresolved.val(true),((status,errorReason)=>{const success=status==="ok";if(!success){warn("set at "+path+" failed: "+status)}const clearEvents=syncTreeAckUserWrite(repo.serverSyncTree_,writeId,!success);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,clearEvents);repoCallOnCompleteCallback(repo,onComplete,status,errorReason)}));const affectedPath=repoAbortTransactions(repo,path);repoRerunTransactions(repo,affectedPath);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,affectedPath,[])}function repoUpdate(repo,path,childrenToMerge,onComplete){repoLog(repo,"update",{path:path.toString(),value:childrenToMerge});let empty=true;const serverValues=repoGenerateServerValues(repo);const changedChildren={};each(childrenToMerge,((changedKey,changedValue)=>{empty=false;changedChildren[changedKey]=resolveDeferredValueTree(pathChild(path,changedKey),nodeFromJSON(changedValue),repo.serverSyncTree_,serverValues)}));if(!empty){const writeId=repoGetNextWriteId(repo);const events=syncTreeApplyUserMerge(repo.serverSyncTree_,path,changedChildren,writeId);eventQueueQueueEvents(repo.eventQueue_,events);repo.server_.merge(path.toString(),childrenToMerge,((status,errorReason)=>{const success=status==="ok";if(!success){warn("update at "+path+" failed: "+status)}const clearEvents=syncTreeAckUserWrite(repo.serverSyncTree_,writeId,!success);const affectedPath=clearEvents.length>0?repoRerunTransactions(repo,path):path;eventQueueRaiseEventsForChangedPath(repo.eventQueue_,affectedPath,clearEvents);repoCallOnCompleteCallback(repo,onComplete,status,errorReason)}));each(childrenToMerge,(changedPath=>{const affectedPath=repoAbortTransactions(repo,pathChild(path,changedPath));repoRerunTransactions(repo,affectedPath)}));eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,[])}else{log("update() called with empty data.  Don't do anything.");repoCallOnCompleteCallback(repo,onComplete,"ok",undefined)}}function repoRunOnDisconnectEvents(repo){repoLog(repo,"onDisconnectEvents");const serverValues=repoGenerateServerValues(repo);const resolvedOnDisconnectTree=newSparseSnapshotTree();sparseSnapshotTreeForEachTree(repo.onDisconnect_,newEmptyPath(),((path,node)=>{const resolved=resolveDeferredValueTree(path,node,repo.serverSyncTree_,serverValues);sparseSnapshotTreeRemember(resolvedOnDisconnectTree,path,resolved)}));let events=[];sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree,newEmptyPath(),((path,snap)=>{events=events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_,path,snap));const affectedPath=repoAbortTransactions(repo,path);repoRerunTransactions(repo,affectedPath)}));repo.onDisconnect_=newSparseSnapshotTree();eventQueueRaiseEventsForChangedPath(repo.eventQueue_,newEmptyPath(),events)}function repoOnDisconnectCancel(repo,path,onComplete){repo.server_.onDisconnectCancel(path.toString(),((status,errorReason)=>{if(status==="ok"){sparseSnapshotTreeForget(repo.onDisconnect_,path)}repoCallOnCompleteCallback(repo,onComplete,status,errorReason)}))}function repoOnDisconnectSet(repo,path,value,onComplete){const newNode=nodeFromJSON(value);repo.server_.onDisconnectPut(path.toString(),newNode.val(true),((status,errorReason)=>{if(status==="ok"){sparseSnapshotTreeRemember(repo.onDisconnect_,path,newNode)}repoCallOnCompleteCallback(repo,onComplete,status,errorReason)}))}function repoOnDisconnectSetWithPriority(repo,path,value,priority,onComplete){const newNode=nodeFromJSON(value,priority);repo.server_.onDisconnectPut(path.toString(),newNode.val(true),((status,errorReason)=>{if(status==="ok"){sparseSnapshotTreeRemember(repo.onDisconnect_,path,newNode)}repoCallOnCompleteCallback(repo,onComplete,status,errorReason)}))}function repoOnDisconnectUpdate(repo,path,childrenToMerge,onComplete){if((0,_util.isEmpty)(childrenToMerge)){log("onDisconnect().update() called with empty data.  Don't do anything.");repoCallOnCompleteCallback(repo,onComplete,"ok",undefined);return}repo.server_.onDisconnectMerge(path.toString(),childrenToMerge,((status,errorReason)=>{if(status==="ok"){each(childrenToMerge,((childName,childNode)=>{const newChildNode=nodeFromJSON(childNode);sparseSnapshotTreeRemember(repo.onDisconnect_,pathChild(path,childName),newChildNode)}))}repoCallOnCompleteCallback(repo,onComplete,status,errorReason)}))}function repoAddEventCallbackForQuery(repo,query,eventRegistration){let events;if(pathGetFront(query._path)===".info"){events=syncTreeAddEventRegistration(repo.infoSyncTree_,query,eventRegistration)}else{events=syncTreeAddEventRegistration(repo.serverSyncTree_,query,eventRegistration)}eventQueueRaiseEventsAtPath(repo.eventQueue_,query._path,events)}function repoRemoveEventCallbackForQuery(repo,query,eventRegistration){let events;if(pathGetFront(query._path)===".info"){events=syncTreeRemoveEventRegistration(repo.infoSyncTree_,query,eventRegistration)}else{events=syncTreeRemoveEventRegistration(repo.serverSyncTree_,query,eventRegistration)}eventQueueRaiseEventsAtPath(repo.eventQueue_,query._path,events)}function repoInterrupt(repo){if(repo.persistentConnection_){repo.persistentConnection_.interrupt(INTERRUPT_REASON)}}function repoResume(repo){if(repo.persistentConnection_){repo.persistentConnection_.resume(INTERRUPT_REASON)}}function repoLog(repo,...varArgs){let prefix="";if(repo.persistentConnection_){prefix=repo.persistentConnection_.id+":"}log(prefix,...varArgs)}function repoCallOnCompleteCallback(repo,callback,status,errorReason){if(callback){exceptionGuard((()=>{if(status==="ok"){callback(null)}else{const code=(status||"error").toUpperCase();let message=code;if(errorReason){message+=": "+errorReason}const error=new Error(message);error.code=code;callback(error)}}))}}function repoStartTransaction(repo,path,transactionUpdate,onComplete,unwatcher,applyLocally){repoLog(repo,"transaction on "+path);const transaction={path:path,update:transactionUpdate,onComplete:onComplete,status:null,order:LUIDGenerator(),applyLocally:applyLocally,retryCount:0,unwatcher:unwatcher,abortReason:null,currentWriteId:null,currentInputSnapshot:null,currentOutputSnapshotRaw:null,currentOutputSnapshotResolved:null};const currentState=repoGetLatestState(repo,path,undefined);transaction.currentInputSnapshot=currentState;const newVal=transaction.update(currentState.val());if(newVal===undefined){transaction.unwatcher();transaction.currentOutputSnapshotRaw=null;transaction.currentOutputSnapshotResolved=null;if(transaction.onComplete){transaction.onComplete(null,false,transaction.currentInputSnapshot)}}else{validateFirebaseData("transaction failed: Data returned ",newVal,transaction.path);transaction.status=0;const queueNode=treeSubTree(repo.transactionQueueTree_,path);const nodeQueue=treeGetValue(queueNode)||[];nodeQueue.push(transaction);treeSetValue(queueNode,nodeQueue);let priorityForNode;if(typeof newVal==="object"&&newVal!==null&&(0,_util.contains)(newVal,".priority")){priorityForNode=(0,_util.safeGet)(newVal,".priority");(0,_util.assert)(isValidPriority(priorityForNode),"Invalid priority returned by transaction. "+"Priority must be a valid string, finite number, server value, or null.")}else{const currentNode=syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path)||ChildrenNode.EMPTY_NODE;priorityForNode=currentNode.getPriority().val()}const serverValues=repoGenerateServerValues(repo);const newNodeUnresolved=nodeFromJSON(newVal,priorityForNode);const newNode=resolveDeferredValueSnapshot(newNodeUnresolved,currentState,serverValues);transaction.currentOutputSnapshotRaw=newNodeUnresolved;transaction.currentOutputSnapshotResolved=newNode;transaction.currentWriteId=repoGetNextWriteId(repo);const events=syncTreeApplyUserOverwrite(repo.serverSyncTree_,path,newNode,transaction.currentWriteId,transaction.applyLocally);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);repoSendReadyTransactions(repo,repo.transactionQueueTree_)}}function repoGetLatestState(repo,path,excludeSets){return syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path,excludeSets)||ChildrenNode.EMPTY_NODE}function repoSendReadyTransactions(repo,node=repo.transactionQueueTree_){if(!node){repoPruneCompletedTransactionsBelowNode(repo,node)}if(treeGetValue(node)){const queue=repoBuildTransactionQueue(repo,node);(0,_util.assert)(queue.length>0,"Sending zero length transaction queue");const allRun=queue.every((transaction=>transaction.status===0));if(allRun){repoSendTransactionQueue(repo,treeGetPath(node),queue)}}else if(treeHasChildren(node)){treeForEachChild(node,(childNode=>{repoSendReadyTransactions(repo,childNode)}))}}function repoSendTransactionQueue(repo,path,queue){const setsToIgnore=queue.map((txn=>txn.currentWriteId));const latestState=repoGetLatestState(repo,path,setsToIgnore);let snapToSend=latestState;const latestHash=latestState.hash();for(let i=0;i<queue.length;i++){const txn=queue[i];(0,_util.assert)(txn.status===0,"tryToSendTransactionQueue_: items in queue should all be run.");txn.status=1;txn.retryCount++;const relativePath=newRelativePath(path,txn.path);snapToSend=snapToSend.updateChild(relativePath,txn.currentOutputSnapshotRaw)}const dataToSend=snapToSend.val(true);const pathToSend=path;repo.server_.put(pathToSend.toString(),dataToSend,(status=>{repoLog(repo,"transaction put response",{path:pathToSend.toString(),status:status});let events=[];if(status==="ok"){const callbacks=[];for(let i=0;i<queue.length;i++){queue[i].status=2;events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,queue[i].currentWriteId));if(queue[i].onComplete){callbacks.push((()=>queue[i].onComplete(null,true,queue[i].currentOutputSnapshotResolved)))}queue[i].unwatcher()}repoPruneCompletedTransactionsBelowNode(repo,treeSubTree(repo.transactionQueueTree_,path));repoSendReadyTransactions(repo,repo.transactionQueueTree_);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);for(let i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i])}}else{if(status==="datastale"){for(let i=0;i<queue.length;i++){if(queue[i].status===3){queue[i].status=4}else{queue[i].status=0}}}else{warn("transaction at "+pathToSend.toString()+" failed: "+status);for(let i=0;i<queue.length;i++){queue[i].status=4;queue[i].abortReason=status}}repoRerunTransactions(repo,path)}}),latestHash)}function repoRerunTransactions(repo,changedPath){const rootMostTransactionNode=repoGetAncestorTransactionNode(repo,changedPath);const path=treeGetPath(rootMostTransactionNode);const queue=repoBuildTransactionQueue(repo,rootMostTransactionNode);repoRerunTransactionQueue(repo,queue,path);return path}function repoRerunTransactionQueue(repo,queue,path){if(queue.length===0){return}const callbacks=[];let events=[];const txnsToRerun=queue.filter((q=>q.status===0));const setsToIgnore=txnsToRerun.map((q=>q.currentWriteId));for(let i=0;i<queue.length;i++){const transaction=queue[i];const relativePath=newRelativePath(path,transaction.path);let abortTransaction=false,abortReason;(0,_util.assert)(relativePath!==null,"rerunTransactionsUnderNode_: relativePath should not be null.");if(transaction.status===4){abortTransaction=true;abortReason=transaction.abortReason;events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,true))}else if(transaction.status===0){if(transaction.retryCount>=MAX_TRANSACTION_RETRIES){abortTransaction=true;abortReason="maxretry";events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,true))}else{const currentNode=repoGetLatestState(repo,transaction.path,setsToIgnore);transaction.currentInputSnapshot=currentNode;const newData=queue[i].update(currentNode.val());if(newData!==undefined){validateFirebaseData("transaction failed: Data returned ",newData,transaction.path);let newDataNode=nodeFromJSON(newData);const hasExplicitPriority=typeof newData==="object"&&newData!=null&&(0,_util.contains)(newData,".priority");if(!hasExplicitPriority){newDataNode=newDataNode.updatePriority(currentNode.getPriority())}const oldWriteId=transaction.currentWriteId;const serverValues=repoGenerateServerValues(repo);const newNodeResolved=resolveDeferredValueSnapshot(newDataNode,currentNode,serverValues);transaction.currentOutputSnapshotRaw=newDataNode;transaction.currentOutputSnapshotResolved=newNodeResolved;transaction.currentWriteId=repoGetNextWriteId(repo);setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId),1);events=events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_,transaction.path,newNodeResolved,transaction.currentWriteId,transaction.applyLocally));events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,oldWriteId,true))}else{abortTransaction=true;abortReason="nodata";events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,true))}}}eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);events=[];if(abortTransaction){queue[i].status=2;(function(unwatcher){setTimeout(unwatcher,Math.floor(0))})(queue[i].unwatcher);if(queue[i].onComplete){if(abortReason==="nodata"){callbacks.push((()=>queue[i].onComplete(null,false,queue[i].currentInputSnapshot)))}else{callbacks.push((()=>queue[i].onComplete(new Error(abortReason),false,null)))}}}}repoPruneCompletedTransactionsBelowNode(repo,repo.transactionQueueTree_);for(let i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i])}repoSendReadyTransactions(repo,repo.transactionQueueTree_)}function repoGetAncestorTransactionNode(repo,path){let front;let transactionNode=repo.transactionQueueTree_;front=pathGetFront(path);while(front!==null&&treeGetValue(transactionNode)===undefined){transactionNode=treeSubTree(transactionNode,front);path=pathPopFront(path);front=pathGetFront(path)}return transactionNode}function repoBuildTransactionQueue(repo,transactionNode){const transactionQueue=[];repoAggregateTransactionQueuesForNode(repo,transactionNode,transactionQueue);transactionQueue.sort(((a,b)=>a.order-b.order));return transactionQueue}function repoAggregateTransactionQueuesForNode(repo,node,queue){const nodeQueue=treeGetValue(node);if(nodeQueue){for(let i=0;i<nodeQueue.length;i++){queue.push(nodeQueue[i])}}treeForEachChild(node,(child=>{repoAggregateTransactionQueuesForNode(repo,child,queue)}))}function repoPruneCompletedTransactionsBelowNode(repo,node){const queue=treeGetValue(node);if(queue){let to=0;for(let from=0;from<queue.length;from++){if(queue[from].status!==2){queue[to]=queue[from];to++}}queue.length=to;treeSetValue(node,queue.length>0?queue:undefined)}treeForEachChild(node,(childNode=>{repoPruneCompletedTransactionsBelowNode(repo,childNode)}))}function repoAbortTransactions(repo,path){const affectedPath=treeGetPath(repoGetAncestorTransactionNode(repo,path));const transactionNode=treeSubTree(repo.transactionQueueTree_,path);treeForEachAncestor(transactionNode,(node=>{repoAbortTransactionsOnNode(repo,node)}));repoAbortTransactionsOnNode(repo,transactionNode);treeForEachDescendant(transactionNode,(node=>{repoAbortTransactionsOnNode(repo,node)}));return affectedPath}function repoAbortTransactionsOnNode(repo,node){const queue=treeGetValue(node);if(queue){const callbacks=[];let events=[];let lastSent=-1;for(let i=0;i<queue.length;i++){if(queue[i].status===3);else if(queue[i].status===1){(0,_util.assert)(lastSent===i-1,"All SENT items should be at beginning of queue.");lastSent=i;queue[i].status=3;queue[i].abortReason="set"}else{(0,_util.assert)(queue[i].status===0,"Unexpected transaction status in abort");queue[i].unwatcher();events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,queue[i].currentWriteId,true));if(queue[i].onComplete){callbacks.push(queue[i].onComplete.bind(null,new Error("set"),false,null))}}}if(lastSent===-1){treeSetValue(node,undefined)}else{queue.length=lastSent+1}eventQueueRaiseEventsForChangedPath(repo.eventQueue_,treeGetPath(node),events);for(let i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i])}}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function decodePath(pathString){let pathStringDecoded="";const pieces=pathString.split("/");for(let i=0;i<pieces.length;i++){if(pieces[i].length>0){let piece=pieces[i];try{piece=decodeURIComponent(piece.replace(/\+/g," "))}catch(e){}pathStringDecoded+="/"+piece}}return pathStringDecoded}function decodeQuery(queryString){const results={};if(queryString.charAt(0)==="?"){queryString=queryString.substring(1)}for(const segment of queryString.split("&")){if(segment.length===0){continue}const kv=segment.split("=");if(kv.length===2){results[decodeURIComponent(kv[0])]=decodeURIComponent(kv[1])}else{warn(`Invalid query segment '${segment}' in query '${queryString}'`)}}return results}const parseRepoInfo=function(dataURL,nodeAdmin){const parsedUrl=parseDatabaseURL(dataURL),namespace=parsedUrl.namespace;if(parsedUrl.domain==="firebase.com"){fatal(parsedUrl.host+" is no longer supported. "+"Please use <YOUR FIREBASE>.firebaseio.com instead")}if((!namespace||namespace==="undefined")&&parsedUrl.domain!=="localhost"){fatal("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com")}if(!parsedUrl.secure){warnIfPageIsSecure()}const webSocketOnly=parsedUrl.scheme==="ws"||parsedUrl.scheme==="wss";return{repoInfo:new RepoInfo(parsedUrl.host,parsedUrl.secure,namespace,webSocketOnly,nodeAdmin,"",namespace!==parsedUrl.subdomain),path:new Path(parsedUrl.pathString)}};const parseDatabaseURL=function(dataURL){let host="",domain="",subdomain="",pathString="",namespace="";let secure=true,scheme="https",port=443;if(typeof dataURL==="string"){let colonInd=dataURL.indexOf("//");if(colonInd>=0){scheme=dataURL.substring(0,colonInd-1);dataURL=dataURL.substring(colonInd+2)}let slashInd=dataURL.indexOf("/");if(slashInd===-1){slashInd=dataURL.length}let questionMarkInd=dataURL.indexOf("?");if(questionMarkInd===-1){questionMarkInd=dataURL.length}host=dataURL.substring(0,Math.min(slashInd,questionMarkInd));if(slashInd<questionMarkInd){pathString=decodePath(dataURL.substring(slashInd,questionMarkInd))}const queryParams=decodeQuery(dataURL.substring(Math.min(dataURL.length,questionMarkInd)));colonInd=host.indexOf(":");if(colonInd>=0){secure=scheme==="https"||scheme==="wss";port=parseInt(host.substring(colonInd+1),10)}else{colonInd=host.length}const hostWithoutPort=host.slice(0,colonInd);if(hostWithoutPort.toLowerCase()==="localhost"){domain="localhost"}else if(hostWithoutPort.split(".").length<=2){domain=hostWithoutPort}else{const dotInd=host.indexOf(".");subdomain=host.substring(0,dotInd).toLowerCase();domain=host.substring(dotInd+1);namespace=subdomain}if("ns"in queryParams){namespace=queryParams["ns"]}}return{host:host,port:port,domain:domain,subdomain:subdomain,secure:secure,scheme:scheme,pathString:pathString,namespace:namespace}};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const PUSH_CHARS="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";const nextPushId=function(){let lastPushTime=0;const lastRandChars=[];return function(now){const duplicateTime=now===lastPushTime;lastPushTime=now;let i;const timeStampChars=new Array(8);for(i=7;i>=0;i--){timeStampChars[i]=PUSH_CHARS.charAt(now%64);now=Math.floor(now/64)}(0,_util.assert)(now===0,"Cannot push at time == 0");let id=timeStampChars.join("");if(!duplicateTime){for(i=0;i<12;i++){lastRandChars[i]=Math.floor(Math.random()*64)}}else{for(i=11;i>=0&&lastRandChars[i]===63;i--){lastRandChars[i]=0}lastRandChars[i]++}for(i=0;i<12;i++){id+=PUSH_CHARS.charAt(lastRandChars[i])}(0,_util.assert)(id.length===20,"nextPushId: Length should be 20.");return id}}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class DataEvent{constructor(eventType,eventRegistration,snapshot,prevName){this.eventType=eventType;this.eventRegistration=eventRegistration;this.snapshot=snapshot;this.prevName=prevName}getPath(){const ref=this.snapshot.ref;if(this.eventType==="value"){return ref._path}else{return ref.parent._path}}getEventType(){return this.eventType}getEventRunner(){return this.eventRegistration.getEventRunner(this)}toString(){return this.getPath().toString()+":"+this.eventType+":"+(0,_util.stringify)(this.snapshot.exportVal())}}class CancelEvent{constructor(eventRegistration,error,path){this.eventRegistration=eventRegistration;this.error=error;this.path=path}getPath(){return this.path}getEventType(){return"cancel"}getEventRunner(){return this.eventRegistration.getEventRunner(this)}toString(){return this.path.toString()+":cancel"}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class CallbackContext{constructor(snapshotCallback,cancelCallback){this.snapshotCallback=snapshotCallback;this.cancelCallback=cancelCallback}onValue(expDataSnapshot,previousChildName){this.snapshotCallback.call(null,expDataSnapshot,previousChildName)}onCancel(error){(0,_util.assert)(this.hasCancelCallback,"Raising a cancel event on a listener with no cancel callback");return this.cancelCallback.call(null,error)}get hasCancelCallback(){return!!this.cancelCallback}matches(other){return this.snapshotCallback===other.snapshotCallback||this.snapshotCallback.userCallback!==undefined&&this.snapshotCallback.userCallback===other.snapshotCallback.userCallback&&this.snapshotCallback.context===other.snapshotCallback.context}}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class OnDisconnect{constructor(_repo,_path){this._repo=_repo;this._path=_path}cancel(){const deferred=new _util.Deferred;repoOnDisconnectCancel(this._repo,this._path,deferred.wrapCallback((()=>{})));return deferred.promise}remove(){validateWritablePath("OnDisconnect.remove",this._path);const deferred=new _util.Deferred;repoOnDisconnectSet(this._repo,this._path,null,deferred.wrapCallback((()=>{})));return deferred.promise}set(value){validateWritablePath("OnDisconnect.set",this._path);validateFirebaseDataArg("OnDisconnect.set",value,this._path,false);const deferred=new _util.Deferred;repoOnDisconnectSet(this._repo,this._path,value,deferred.wrapCallback((()=>{})));return deferred.promise}setWithPriority(value,priority){validateWritablePath("OnDisconnect.setWithPriority",this._path);validateFirebaseDataArg("OnDisconnect.setWithPriority",value,this._path,false);validatePriority("OnDisconnect.setWithPriority",priority,false);const deferred=new _util.Deferred;repoOnDisconnectSetWithPriority(this._repo,this._path,value,priority,deferred.wrapCallback((()=>{})));return deferred.promise}update(values){validateWritablePath("OnDisconnect.update",this._path);validateFirebaseMergeDataArg("OnDisconnect.update",values,this._path,false);const deferred=new _util.Deferred;repoOnDisconnectUpdate(this._repo,this._path,values,deferred.wrapCallback((()=>{})));return deferred.promise}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.OnDisconnect=OnDisconnect;class QueryImpl{constructor(_repo,_path,_queryParams,_orderByCalled){this._repo=_repo;this._path=_path;this._queryParams=_queryParams;this._orderByCalled=_orderByCalled}get key(){if(pathIsEmpty(this._path)){return null}else{return pathGetBack(this._path)}}get ref(){return new ReferenceImpl(this._repo,this._path)}get _queryIdentifier(){const obj=queryParamsGetQueryObject(this._queryParams);const id=ObjectToUniqueKey(obj);return id==="{}"?"default":id}get _queryObject(){return queryParamsGetQueryObject(this._queryParams)}isEqual(other){other=(0,_util.getModularInstance)(other);if(!(other instanceof QueryImpl)){return false}const sameRepo=this._repo===other._repo;const samePath=pathEquals(this._path,other._path);const sameQueryIdentifier=this._queryIdentifier===other._queryIdentifier;return sameRepo&&samePath&&sameQueryIdentifier}toJSON(){return this.toString()}toString(){return this._repo.toString()+pathToUrlEncodedString(this._path)}}exports._QueryImpl=QueryImpl;function validateNoPreviousOrderByCall(query,fnName){if(query._orderByCalled===true){throw new Error(fnName+": You can't combine multiple orderBy calls.")}}function validateQueryEndpoints(params){let startNode=null;let endNode=null;if(params.hasStart()){startNode=params.getIndexStartValue()}if(params.hasEnd()){endNode=params.getIndexEndValue()}if(params.getIndex()===KEY_INDEX){const tooManyArgsError="Query: When ordering by key, you may only pass one argument to "+"startAt(), endAt(), or equalTo().";const wrongArgTypeError="Query: When ordering by key, the argument passed to startAt(), startAfter(), "+"endAt(), endBefore(), or equalTo() must be a string.";if(params.hasStart()){const startName=params.getIndexStartName();if(startName!==MIN_NAME){throw new Error(tooManyArgsError)}else if(typeof startNode!=="string"){throw new Error(wrongArgTypeError)}}if(params.hasEnd()){const endName=params.getIndexEndName();if(endName!==MAX_NAME){throw new Error(tooManyArgsError)}else if(typeof endNode!=="string"){throw new Error(wrongArgTypeError)}}}else if(params.getIndex()===PRIORITY_INDEX){if(startNode!=null&&!isValidPriority(startNode)||endNode!=null&&!isValidPriority(endNode)){throw new Error("Query: When ordering by priority, the first argument passed to startAt(), "+"startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value "+"(null, a number, or a string).")}}else{(0,_util.assert)(params.getIndex()instanceof PathIndex||params.getIndex()===VALUE_INDEX,"unknown index type.");if(startNode!=null&&typeof startNode==="object"||endNode!=null&&typeof endNode==="object"){throw new Error("Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or "+"equalTo() cannot be an object.")}}}function validateLimit(params){if(params.hasStart()&&params.hasEnd()&&params.hasLimit()&&!params.hasAnchoredLimit()){throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use "+"limitToFirst() or limitToLast() instead.")}}class ReferenceImpl extends QueryImpl{constructor(repo,path){super(repo,path,new QueryParams,false)}get parent(){const parentPath=pathParent(this._path);return parentPath===null?null:new ReferenceImpl(this._repo,parentPath)}get root(){let ref=this;while(ref.parent!==null){ref=ref.parent}return ref}}exports._ReferenceImpl=ReferenceImpl;class DataSnapshot{constructor(_node,ref,_index){this._node=_node;this.ref=ref;this._index=_index}get priority(){return this._node.getPriority().val()}get key(){return this.ref.key}get size(){return this._node.numChildren()}child(path){const childPath=new Path(path);const childRef=child(this.ref,path);return new DataSnapshot(this._node.getChild(childPath),childRef,PRIORITY_INDEX)}exists(){return!this._node.isEmpty()}exportVal(){return this._node.val(true)}forEach(action){if(this._node.isLeafNode()){return false}const childrenNode=this._node;return!!childrenNode.forEachChild(this._index,((key,node)=>action(new DataSnapshot(node,child(this.ref,key),PRIORITY_INDEX))))}hasChild(path){const childPath=new Path(path);return!this._node.getChild(childPath).isEmpty()}hasChildren(){if(this._node.isLeafNode()){return false}else{return!this._node.isEmpty()}}toJSON(){return this.exportVal()}val(){return this._node.val()}}exports.DataSnapshot=DataSnapshot;function ref(db,path){db=(0,_util.getModularInstance)(db);db._checkNotDeleted("ref");return path!==undefined?child(db._root,path):db._root}function refFromURL(db,url){db=(0,_util.getModularInstance)(db);db._checkNotDeleted("refFromURL");const parsedURL=parseRepoInfo(url,db._repo.repoInfo_.nodeAdmin);validateUrl("refFromURL",parsedURL);const repoInfo=parsedURL.repoInfo;if(!db._repo.repoInfo_.isCustomHost()&&repoInfo.host!==db._repo.repoInfo_.host){fatal("refFromURL"+": Host name does not match the current database: "+"(found "+repoInfo.host+" but expected "+db._repo.repoInfo_.host+")")}return ref(db,parsedURL.path.toString())}function child(parent,path){parent=(0,_util.getModularInstance)(parent);if(pathGetFront(parent._path)===null){validateRootPathString("child","path",path,false)}else{validatePathString("child","path",path,false)}return new ReferenceImpl(parent._repo,pathChild(parent._path,path))}function onDisconnect(ref){ref=(0,_util.getModularInstance)(ref);return new OnDisconnect(ref._repo,ref._path)}function push(parent,value){parent=(0,_util.getModularInstance)(parent);validateWritablePath("push",parent._path);validateFirebaseDataArg("push",value,parent._path,true);const now=repoServerTime(parent._repo);const name=nextPushId(now);const thennablePushRef=child(parent,name);const pushRef=child(parent,name);let promise;if(value!=null){promise=set(pushRef,value).then((()=>pushRef))}else{promise=Promise.resolve(pushRef)}thennablePushRef.then=promise.then.bind(promise);thennablePushRef.catch=promise.then.bind(promise,undefined);return thennablePushRef}function remove(ref){validateWritablePath("remove",ref._path);return set(ref,null)}function set(ref,value){ref=(0,_util.getModularInstance)(ref);validateWritablePath("set",ref._path);validateFirebaseDataArg("set",value,ref._path,false);const deferred=new _util.Deferred;repoSetWithPriority(ref._repo,ref._path,value,null,deferred.wrapCallback((()=>{})));return deferred.promise}function setPriority(ref,priority){ref=(0,_util.getModularInstance)(ref);validateWritablePath("setPriority",ref._path);validatePriority("setPriority",priority,false);const deferred=new _util.Deferred;repoSetWithPriority(ref._repo,pathChild(ref._path,".priority"),priority,null,deferred.wrapCallback((()=>{})));return deferred.promise}function setWithPriority(ref,value,priority){validateWritablePath("setWithPriority",ref._path);validateFirebaseDataArg("setWithPriority",value,ref._path,false);validatePriority("setWithPriority",priority,false);if(ref.key===".length"||ref.key===".keys"){throw"setWithPriority failed: "+ref.key+" is a read-only object."}const deferred=new _util.Deferred;repoSetWithPriority(ref._repo,ref._path,value,priority,deferred.wrapCallback((()=>{})));return deferred.promise}function update(ref,values){validateFirebaseMergeDataArg("update",values,ref._path,false);const deferred=new _util.Deferred;repoUpdate(ref._repo,ref._path,values,deferred.wrapCallback((()=>{})));return deferred.promise}function get(query){query=(0,_util.getModularInstance)(query);const callbackContext=new CallbackContext((()=>{}));const container=new ValueEventRegistration(callbackContext);return repoGetValue(query._repo,query,container).then((node=>new DataSnapshot(node,new ReferenceImpl(query._repo,query._path),query._queryParams.getIndex())))}class ValueEventRegistration{constructor(callbackContext){this.callbackContext=callbackContext}respondsTo(eventType){return eventType==="value"}createEvent(change,query){const index=query._queryParams.getIndex();return new DataEvent("value",this,new DataSnapshot(change.snapshotNode,new ReferenceImpl(query._repo,query._path),index))}getEventRunner(eventData){if(eventData.getEventType()==="cancel"){return()=>this.callbackContext.onCancel(eventData.error)}else{return()=>this.callbackContext.onValue(eventData.snapshot,null)}}createCancelEvent(error,path){if(this.callbackContext.hasCancelCallback){return new CancelEvent(this,error,path)}else{return null}}matches(other){if(!(other instanceof ValueEventRegistration)){return false}else if(!other.callbackContext||!this.callbackContext){return true}else{return other.callbackContext.matches(this.callbackContext)}}hasAnyCallback(){return this.callbackContext!==null}}class ChildEventRegistration{constructor(eventType,callbackContext){this.eventType=eventType;this.callbackContext=callbackContext}respondsTo(eventType){let eventToCheck=eventType==="children_added"?"child_added":eventType;eventToCheck=eventToCheck==="children_removed"?"child_removed":eventToCheck;return this.eventType===eventToCheck}createCancelEvent(error,path){if(this.callbackContext.hasCancelCallback){return new CancelEvent(this,error,path)}else{return null}}createEvent(change,query){(0,_util.assert)(change.childName!=null,"Child events should have a childName.");const childRef=child(new ReferenceImpl(query._repo,query._path),change.childName);const index=query._queryParams.getIndex();return new DataEvent(change.type,this,new DataSnapshot(change.snapshotNode,childRef,index),change.prevName)}getEventRunner(eventData){if(eventData.getEventType()==="cancel"){return()=>this.callbackContext.onCancel(eventData.error)}else{return()=>this.callbackContext.onValue(eventData.snapshot,eventData.prevName)}}matches(other){if(other instanceof ChildEventRegistration){return this.eventType===other.eventType&&(!this.callbackContext||!other.callbackContext||this.callbackContext.matches(other.callbackContext))}return false}hasAnyCallback(){return!!this.callbackContext}}function addEventListener(query,eventType,callback,cancelCallbackOrListenOptions,options){let cancelCallback;if(typeof cancelCallbackOrListenOptions==="object"){cancelCallback=undefined;options=cancelCallbackOrListenOptions}if(typeof cancelCallbackOrListenOptions==="function"){cancelCallback=cancelCallbackOrListenOptions}if(options&&options.onlyOnce){const userCallback=callback;const onceCallback=(dataSnapshot,previousChildName)=>{repoRemoveEventCallbackForQuery(query._repo,query,container);userCallback(dataSnapshot,previousChildName)};onceCallback.userCallback=callback.userCallback;onceCallback.context=callback.context;callback=onceCallback}const callbackContext=new CallbackContext(callback,cancelCallback||undefined);const container=eventType==="value"?new ValueEventRegistration(callbackContext):new ChildEventRegistration(eventType,callbackContext);repoAddEventCallbackForQuery(query._repo,query,container);return()=>repoRemoveEventCallbackForQuery(query._repo,query,container)}function onValue(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,"value",callback,cancelCallbackOrListenOptions,options)}function onChildAdded(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,"child_added",callback,cancelCallbackOrListenOptions,options)}function onChildChanged(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,"child_changed",callback,cancelCallbackOrListenOptions,options)}function onChildMoved(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,"child_moved",callback,cancelCallbackOrListenOptions,options)}function onChildRemoved(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,"child_removed",callback,cancelCallbackOrListenOptions,options)}function off(query,eventType,callback){let container=null;const expCallback=callback?new CallbackContext(callback):null;if(eventType==="value"){container=new ValueEventRegistration(expCallback)}else if(eventType){container=new ChildEventRegistration(eventType,expCallback)}repoRemoveEventCallbackForQuery(query._repo,query,container)}class QueryConstraint{}exports.QueryConstraint=QueryConstraint;class QueryEndAtConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;this.type="endAt"}_apply(query){validateFirebaseDataArg("endAt",this._value,query._path,true);const newParams=queryParamsEndAt(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasEnd()){throw new Error("endAt: Starting point was already set (by another call to endAt, "+"endBefore or equalTo).")}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled)}}function endAt(value,key){validateKey("endAt","key",key,true);return new QueryEndAtConstraint(value,key)}class QueryEndBeforeConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;this.type="endBefore"}_apply(query){validateFirebaseDataArg("endBefore",this._value,query._path,false);const newParams=queryParamsEndBefore(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasEnd()){throw new Error("endBefore: Starting point was already set (by another call to endAt, "+"endBefore or equalTo).")}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled)}}function endBefore(value,key){validateKey("endBefore","key",key,true);return new QueryEndBeforeConstraint(value,key)}class QueryStartAtConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;this.type="startAt"}_apply(query){validateFirebaseDataArg("startAt",this._value,query._path,true);const newParams=queryParamsStartAt(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasStart()){throw new Error("startAt: Starting point was already set (by another call to startAt, "+"startBefore or equalTo).")}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled)}}function startAt(value=null,key){validateKey("startAt","key",key,true);return new QueryStartAtConstraint(value,key)}class QueryStartAfterConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;this.type="startAfter"}_apply(query){validateFirebaseDataArg("startAfter",this._value,query._path,false);const newParams=queryParamsStartAfter(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasStart()){throw new Error("startAfter: Starting point was already set (by another call to startAt, "+"startAfter, or equalTo).")}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled)}}function startAfter(value,key){validateKey("startAfter","key",key,true);return new QueryStartAfterConstraint(value,key)}class QueryLimitToFirstConstraint extends QueryConstraint{constructor(_limit){super();this._limit=_limit;this.type="limitToFirst"}_apply(query){if(query._queryParams.hasLimit()){throw new Error("limitToFirst: Limit was already set (by another call to limitToFirst "+"or limitToLast).")}return new QueryImpl(query._repo,query._path,queryParamsLimitToFirst(query._queryParams,this._limit),query._orderByCalled)}}function limitToFirst(limit){if(typeof limit!=="number"||Math.floor(limit)!==limit||limit<=0){throw new Error("limitToFirst: First argument must be a positive integer.")}return new QueryLimitToFirstConstraint(limit)}class QueryLimitToLastConstraint extends QueryConstraint{constructor(_limit){super();this._limit=_limit;this.type="limitToLast"}_apply(query){if(query._queryParams.hasLimit()){throw new Error("limitToLast: Limit was already set (by another call to limitToFirst "+"or limitToLast).")}return new QueryImpl(query._repo,query._path,queryParamsLimitToLast(query._queryParams,this._limit),query._orderByCalled)}}function limitToLast(limit){if(typeof limit!=="number"||Math.floor(limit)!==limit||limit<=0){throw new Error("limitToLast: First argument must be a positive integer.")}return new QueryLimitToLastConstraint(limit)}class QueryOrderByChildConstraint extends QueryConstraint{constructor(_path){super();this._path=_path;this.type="orderByChild"}_apply(query){validateNoPreviousOrderByCall(query,"orderByChild");const parsedPath=new Path(this._path);if(pathIsEmpty(parsedPath)){throw new Error("orderByChild: cannot pass in empty path. Use orderByValue() instead.")}const index=new PathIndex(parsedPath);const newParams=queryParamsOrderBy(query._queryParams,index);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,true)}}function orderByChild(path){if(path==="$key"){throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.')}else if(path==="$priority"){throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.')}else if(path==="$value"){throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.')}validatePathString("orderByChild","path",path,false);return new QueryOrderByChildConstraint(path)}class QueryOrderByKeyConstraint extends QueryConstraint{constructor(){super(...arguments);this.type="orderByKey"}_apply(query){validateNoPreviousOrderByCall(query,"orderByKey");const newParams=queryParamsOrderBy(query._queryParams,KEY_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,true)}}function orderByKey(){return new QueryOrderByKeyConstraint}class QueryOrderByPriorityConstraint extends QueryConstraint{constructor(){super(...arguments);this.type="orderByPriority"}_apply(query){validateNoPreviousOrderByCall(query,"orderByPriority");const newParams=queryParamsOrderBy(query._queryParams,PRIORITY_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,true)}}function orderByPriority(){return new QueryOrderByPriorityConstraint}class QueryOrderByValueConstraint extends QueryConstraint{constructor(){super(...arguments);this.type="orderByValue"}_apply(query){validateNoPreviousOrderByCall(query,"orderByValue");const newParams=queryParamsOrderBy(query._queryParams,VALUE_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,true)}}function orderByValue(){return new QueryOrderByValueConstraint}class QueryEqualToValueConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;this.type="equalTo"}_apply(query){validateFirebaseDataArg("equalTo",this._value,query._path,false);if(query._queryParams.hasStart()){throw new Error("equalTo: Starting point was already set (by another call to startAt/startAfter or "+"equalTo).")}if(query._queryParams.hasEnd()){throw new Error("equalTo: Ending point was already set (by another call to endAt/endBefore or "+"equalTo).")}return new QueryEndAtConstraint(this._value,this._key)._apply(new QueryStartAtConstraint(this._value,this._key)._apply(query))}}function equalTo(value,key){validateKey("equalTo","key",key,true);return new QueryEqualToValueConstraint(value,key)}function query(query,...queryConstraints){let queryImpl=(0,_util.getModularInstance)(query);for(const constraint of queryConstraints){queryImpl=constraint._apply(queryImpl)}return queryImpl}syncPointSetReferenceConstructor(ReferenceImpl);syncTreeSetReferenceConstructor(ReferenceImpl);
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const FIREBASE_DATABASE_EMULATOR_HOST_VAR="FIREBASE_DATABASE_EMULATOR_HOST";const repos={};let useRestClient=false;function repoManagerApplyEmulatorSettings(repo,host,port,tokenProvider){repo.repoInfo_=new RepoInfo(`${host}:${port}`,false,repo.repoInfo_.namespace,repo.repoInfo_.webSocketOnly,repo.repoInfo_.nodeAdmin,repo.repoInfo_.persistenceKey,repo.repoInfo_.includeNamespaceInQueryParams,true);if(tokenProvider){repo.authTokenProvider_=tokenProvider}}function repoManagerDatabaseFromApp(app,authProvider,appCheckProvider,url,nodeAdmin){let dbUrl=url||app.options.databaseURL;if(dbUrl===undefined){if(!app.options.projectId){fatal("Can't determine Firebase Database URL. Be sure to include "+" a Project ID when calling firebase.initializeApp().")}log("Using default host for project ",app.options.projectId);dbUrl=`${app.options.projectId}-default-rtdb.firebaseio.com`}let parsedUrl=parseRepoInfo(dbUrl,nodeAdmin);let repoInfo=parsedUrl.repoInfo;let isEmulator;let dbEmulatorHost=undefined;if(typeof process!=="undefined"&&process.env){dbEmulatorHost=process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR]}if(dbEmulatorHost){isEmulator=true;dbUrl=`http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;parsedUrl=parseRepoInfo(dbUrl,nodeAdmin);repoInfo=parsedUrl.repoInfo}else{isEmulator=!parsedUrl.repoInfo.secure}const authTokenProvider=nodeAdmin&&isEmulator?new EmulatorTokenProvider(EmulatorTokenProvider.OWNER):new FirebaseAuthTokenProvider(app.name,app.options,authProvider);validateUrl("Invalid Firebase Database URL",parsedUrl);if(!pathIsEmpty(parsedUrl.path)){fatal("Database URL must point to the root of a Firebase Database "+"(not including a child path).")}const repo=repoManagerCreateRepo(repoInfo,app,authTokenProvider,new AppCheckTokenProvider(app.name,appCheckProvider));return new Database(repo,app)}function repoManagerDeleteRepo(repo,appName){const appRepos=repos[appName];if(!appRepos||appRepos[repo.key]!==repo){fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`)}repoInterrupt(repo);delete appRepos[repo.key]}function repoManagerCreateRepo(repoInfo,app,authTokenProvider,appCheckProvider){let appRepos=repos[app.name];if(!appRepos){appRepos={};repos[app.name]=appRepos}let repo=appRepos[repoInfo.toURLString()];if(repo){fatal("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.")}repo=new Repo(repoInfo,useRestClient,authTokenProvider,appCheckProvider);appRepos[repoInfo.toURLString()]=repo;return repo}function repoManagerForceRestClient(forceRestClient){useRestClient=forceRestClient}class Database{constructor(_repoInternal,app){this._repoInternal=_repoInternal;this.app=app;this["type"]="database";this._instanceStarted=false}get _repo(){if(!this._instanceStarted){repoStart(this._repoInternal,this.app.options.appId,this.app.options["databaseAuthVariableOverride"]);this._instanceStarted=true}return this._repoInternal}get _root(){if(!this._rootInternal){this._rootInternal=new ReferenceImpl(this._repo,newEmptyPath())}return this._rootInternal}_delete(){if(this._rootInternal!==null){repoManagerDeleteRepo(this._repo,this.app.name);this._repoInternal=null;this._rootInternal=null}return Promise.resolve()}_checkNotDeleted(apiName){if(this._rootInternal===null){fatal("Cannot call "+apiName+" on a deleted database.")}}}exports.Database=Database;function checkTransportInit(){if(TransportManager.IS_TRANSPORT_INITIALIZED){warn("Transport has already been initialized. Please call this function before calling ref or setting up a listener")}}function forceWebSockets(){checkTransportInit();BrowserPollConnection.forceDisallow()}function forceLongPolling(){checkTransportInit();WebSocketConnection.forceDisallow();BrowserPollConnection.forceAllow()}function getDatabase(app=(0,_app.getApp)(),url){const db=(0,_app._getProvider)(app,"database").getImmediate({identifier:url});if(!db._instanceStarted){const emulator=(0,_util.getDefaultEmulatorHostnameAndPort)("database");if(emulator){connectDatabaseEmulator(db,...emulator)}}return db}function connectDatabaseEmulator(db,host,port,options={}){db=(0,_util.getModularInstance)(db);db._checkNotDeleted("useEmulator");if(db._instanceStarted){fatal("Cannot call useEmulator() after instance has already been initialized.")}const repo=db._repoInternal;let tokenProvider=undefined;if(repo.repoInfo_.nodeAdmin){if(options.mockUserToken){fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".')}tokenProvider=new EmulatorTokenProvider(EmulatorTokenProvider.OWNER)}else if(options.mockUserToken){const token=typeof options.mockUserToken==="string"?options.mockUserToken:(0,_util.createMockUserToken)(options.mockUserToken,db.app.options.projectId);tokenProvider=new EmulatorTokenProvider(token)}repoManagerApplyEmulatorSettings(repo,host,port,tokenProvider)}function goOffline(db){db=(0,_util.getModularInstance)(db);db._checkNotDeleted("goOffline");repoInterrupt(db._repo)}function goOnline(db){db=(0,_util.getModularInstance)(db);db._checkNotDeleted("goOnline");repoResume(db._repo)}function enableLogging(logger,persistent){enableLogging$1(logger,persistent)}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function registerDatabase(variant){setSDKVersion(_app.SDK_VERSION);(0,_app._registerComponent)(new _component.Component("database",((container,{instanceIdentifier:url})=>{const app=container.getProvider("app").getImmediate();const authProvider=container.getProvider("auth-internal");const appCheckProvider=container.getProvider("app-check-internal");return repoManagerDatabaseFromApp(app,authProvider,appCheckProvider,url)}),"PUBLIC").setMultipleInstances(true));(0,_app.registerVersion)(name,version,variant);(0,_app.registerVersion)(name,version,"esm2017")}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const SERVER_TIMESTAMP={".sv":"timestamp"};function serverTimestamp(){return SERVER_TIMESTAMP}function increment(delta){return{".sv":{increment:delta}}}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class TransactionResult{constructor(committed,snapshot){this.committed=committed;this.snapshot=snapshot}toJSON(){return{committed:this.committed,snapshot:this.snapshot.toJSON()}}}exports.TransactionResult=TransactionResult;function runTransaction(ref,transactionUpdate,options){var _a;ref=(0,_util.getModularInstance)(ref);validateWritablePath("Reference.transaction",ref._path);if(ref.key===".length"||ref.key===".keys"){throw"Reference.transaction failed: "+ref.key+" is a read-only object."}const applyLocally=(_a=options===null||options===void 0?void 0:options.applyLocally)!==null&&_a!==void 0?_a:true;const deferred=new _util.Deferred;const promiseComplete=(error,committed,node)=>{let dataSnapshot=null;if(error){deferred.reject(error)}else{dataSnapshot=new DataSnapshot(node,new ReferenceImpl(ref._repo,ref._path),PRIORITY_INDEX);deferred.resolve(new TransactionResult(committed,dataSnapshot))}};const unwatcher=onValue(ref,(()=>{}));repoStartTransaction(ref._repo,ref._path,transactionUpdate,promiseComplete,unwatcher,applyLocally);return deferred.promise}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */PersistentConnection;PersistentConnection.prototype.simpleListen=function(pathString,onComplete){this.sendRequest("q",{p:pathString},onComplete)};PersistentConnection.prototype.echo=function(data,onEcho){this.sendRequest("echo",{d:data},onEcho)};Connection;const hijackHash=function(newHash){const oldPut=PersistentConnection.prototype.put;PersistentConnection.prototype.put=function(pathString,data,onComplete,hash){if(hash!==undefined){hash=newHash()}oldPut.call(this,pathString,data,onComplete,hash)};return function(){PersistentConnection.prototype.put=oldPut}};exports._TEST_ACCESS_hijackHash=hijackHash;RepoInfo;const forceRestClient=function(forceRestClient){repoManagerForceRestClient(forceRestClient)};
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports._TEST_ACCESS_forceRestClient=forceRestClient;function _initStandalone({app:app,url:url,version:version,customAuthImpl:customAuthImpl,customAppCheckImpl:customAppCheckImpl,nodeAdmin:nodeAdmin=false}){setSDKVersion(version);const componentContainer=new _component.ComponentContainer("database-standalone");const authProvider=new _component.Provider("auth-internal",componentContainer);let appCheckProvider;if(customAppCheckImpl){appCheckProvider=new _component.Provider("app-check-internal",componentContainer);appCheckProvider.setComponent(new _component.Component("app-check-internal",(()=>customAppCheckImpl),"PRIVATE"))}authProvider.setComponent(new _component.Component("auth-internal",(()=>customAuthImpl),"PRIVATE"));return repoManagerDatabaseFromApp(app,authProvider,appCheckProvider,url,nodeAdmin)}registerDatabase()}).call(this)}).call(this,require("_process"))},{"@firebase/app":4,"@firebase/component":8,"@firebase/logger":11,"@firebase/util":12,_process:1}],11:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Logger=exports.LogLevel=void 0;exports.setLogLevel=setLogLevel;exports.setUserLogHandler=setUserLogHandler;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const instances=[];var LogLevel;exports.LogLevel=LogLevel;(function(LogLevel){LogLevel[LogLevel["DEBUG"]=0]="DEBUG";LogLevel[LogLevel["VERBOSE"]=1]="VERBOSE";LogLevel[LogLevel["INFO"]=2]="INFO";LogLevel[LogLevel["WARN"]=3]="WARN";LogLevel[LogLevel["ERROR"]=4]="ERROR";LogLevel[LogLevel["SILENT"]=5]="SILENT"})(LogLevel||(exports.LogLevel=LogLevel={}));const levelStringToEnum={debug:LogLevel.DEBUG,verbose:LogLevel.VERBOSE,info:LogLevel.INFO,warn:LogLevel.WARN,error:LogLevel.ERROR,silent:LogLevel.SILENT};const defaultLogLevel=LogLevel.INFO;const ConsoleMethod={[LogLevel.DEBUG]:"log",[LogLevel.VERBOSE]:"log",[LogLevel.INFO]:"info",[LogLevel.WARN]:"warn",[LogLevel.ERROR]:"error"};const defaultLogHandler=(instance,logType,...args)=>{if(logType<instance.logLevel){return}const now=(new Date).toISOString();const method=ConsoleMethod[logType];if(method){console[method](`[${now}]  ${instance.name}:`,...args)}else{throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`)}};class Logger{constructor(name){this.name=name;this._logLevel=defaultLogLevel;this._logHandler=defaultLogHandler;this._userLogHandler=null;instances.push(this)}get logLevel(){return this._logLevel}set logLevel(val){if(!(val in LogLevel)){throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``)}this._logLevel=val}setLogLevel(val){this._logLevel=typeof val==="string"?levelStringToEnum[val]:val}get logHandler(){return this._logHandler}set logHandler(val){if(typeof val!=="function"){throw new TypeError("Value assigned to `logHandler` must be a function")}this._logHandler=val}get userLogHandler(){return this._userLogHandler}set userLogHandler(val){this._userLogHandler=val}debug(...args){this._userLogHandler&&this._userLogHandler(this,LogLevel.DEBUG,...args);this._logHandler(this,LogLevel.DEBUG,...args)}log(...args){this._userLogHandler&&this._userLogHandler(this,LogLevel.VERBOSE,...args);this._logHandler(this,LogLevel.VERBOSE,...args)}info(...args){this._userLogHandler&&this._userLogHandler(this,LogLevel.INFO,...args);this._logHandler(this,LogLevel.INFO,...args)}warn(...args){this._userLogHandler&&this._userLogHandler(this,LogLevel.WARN,...args);this._logHandler(this,LogLevel.WARN,...args)}error(...args){this._userLogHandler&&this._userLogHandler(this,LogLevel.ERROR,...args);this._logHandler(this,LogLevel.ERROR,...args)}}exports.Logger=Logger;function setLogLevel(level){instances.forEach((inst=>{inst.setLogLevel(level)}))}function setUserLogHandler(logCallback,options){for(const instance of instances){let customLogLevel=null;if(options&&options.level){customLogLevel=levelStringToEnum[options.level]}if(logCallback===null){instance.userLogHandler=null}else{instance.userLogHandler=(instance,level,...args)=>{const message=args.map((arg=>{if(arg==null){return null}else if(typeof arg==="string"){return arg}else if(typeof arg==="number"||typeof arg==="boolean"){return arg.toString()}else if(arg instanceof Error){return arg.message}else{try{return JSON.stringify(arg)}catch(ignored){return null}}})).filter((arg=>arg)).join(" ");if(level>=(customLogLevel!==null&&customLogLevel!==void 0?customLogLevel:instance.logLevel)){logCallback({level:LogLevel[level].toLowerCase(),message:message,args:args,type:instance.name})}}}}}},{}],12:[function(require,module,exports){(function(process,global){(function(){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Sha1=exports.RANDOM_FACTOR=exports.MAX_VALUE_MILLIS=exports.FirebaseError=exports.ErrorFactory=exports.Deferred=exports.DecodeBase64StringError=exports.CONSTANTS=void 0;exports.areCookiesEnabled=areCookiesEnabled;exports.assertionError=exports.assert=void 0;exports.async=async;exports.base64urlEncodeWithoutPadding=exports.base64Encode=exports.base64Decode=exports.base64=void 0;exports.calculateBackoffMillis=calculateBackoffMillis;exports.contains=contains;exports.createMockUserToken=createMockUserToken;exports.createSubscribe=createSubscribe;exports.decode=void 0;exports.deepCopy=deepCopy;exports.deepEqual=deepEqual;exports.deepExtend=deepExtend;exports.errorPrefix=errorPrefix;exports.extractQuerystring=extractQuerystring;exports.getExperimentalSetting=exports.getDefaults=exports.getDefaultEmulatorHostnameAndPort=exports.getDefaultEmulatorHost=exports.getDefaultAppConfig=void 0;exports.getGlobal=getGlobal;exports.getModularInstance=getModularInstance;exports.getUA=getUA;exports.isAdmin=void 0;exports.isBrowser=isBrowser;exports.isBrowserExtension=isBrowserExtension;exports.isElectron=isElectron;exports.isEmpty=isEmpty;exports.isIE=isIE;exports.isIndexedDBAvailable=isIndexedDBAvailable;exports.isMobileCordova=isMobileCordova;exports.isNode=isNode;exports.isNodeSdk=isNodeSdk;exports.isReactNative=isReactNative;exports.isSafari=isSafari;exports.isUWP=isUWP;exports.issuedAtTime=exports.isValidTimestamp=exports.isValidFormat=void 0;exports.jsonEval=jsonEval;exports.map=map;exports.ordinal=ordinal;exports.promiseWithTimeout=promiseWithTimeout;exports.querystring=querystring;exports.querystringDecode=querystringDecode;exports.safeGet=safeGet;exports.stringToByteArray=exports.stringLength=void 0;exports.stringify=stringify;exports.validateArgCount=exports.uuidv4=void 0;exports.validateCallback=validateCallback;exports.validateContextObject=validateContextObject;exports.validateIndexedDBOpenable=validateIndexedDBOpenable;exports.validateNamespace=validateNamespace;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const CONSTANTS={NODE_CLIENT:false,NODE_ADMIN:false,SDK_VERSION:"${JSCORE_VERSION}"};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.CONSTANTS=CONSTANTS;const assert=function(assertion,message){if(!assertion){throw assertionError(message)}};exports.assert=assert;const assertionError=function(message){return new Error("Firebase Database ("+CONSTANTS.SDK_VERSION+") INTERNAL ASSERT FAILED: "+message)};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.assertionError=assertionError;const stringToByteArray$1=function(str){const out=[];let p=0;for(let i=0;i<str.length;i++){let c=str.charCodeAt(i);if(c<128){out[p++]=c}else if(c<2048){out[p++]=c>>6|192;out[p++]=c&63|128}else if((c&64512)===55296&&i+1<str.length&&(str.charCodeAt(i+1)&64512)===56320){c=65536+((c&1023)<<10)+(str.charCodeAt(++i)&1023);out[p++]=c>>18|240;out[p++]=c>>12&63|128;out[p++]=c>>6&63|128;out[p++]=c&63|128}else{out[p++]=c>>12|224;out[p++]=c>>6&63|128;out[p++]=c&63|128}}return out};const byteArrayToString=function(bytes){const out=[];let pos=0,c=0;while(pos<bytes.length){const c1=bytes[pos++];if(c1<128){out[c++]=String.fromCharCode(c1)}else if(c1>191&&c1<224){const c2=bytes[pos++];out[c++]=String.fromCharCode((c1&31)<<6|c2&63)}else if(c1>239&&c1<365){const c2=bytes[pos++];const c3=bytes[pos++];const c4=bytes[pos++];const u=((c1&7)<<18|(c2&63)<<12|(c3&63)<<6|c4&63)-65536;out[c++]=String.fromCharCode(55296+(u>>10));out[c++]=String.fromCharCode(56320+(u&1023))}else{const c2=bytes[pos++];const c3=bytes[pos++];out[c++]=String.fromCharCode((c1&15)<<12|(c2&63)<<6|c3&63)}}return out.join("")};const base64={byteToCharMap_:null,charToByteMap_:null,byteToCharMapWebSafe_:null,charToByteMapWebSafe_:null,ENCODED_VALS_BASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZ"+"abcdefghijklmnopqrstuvwxyz"+"0123456789",get ENCODED_VALS(){return this.ENCODED_VALS_BASE+"+/="},get ENCODED_VALS_WEBSAFE(){return this.ENCODED_VALS_BASE+"-_."},HAS_NATIVE_SUPPORT:typeof atob==="function",encodeByteArray(input,webSafe){if(!Array.isArray(input)){throw Error("encodeByteArray takes an array as a parameter")}this.init_();const byteToCharMap=webSafe?this.byteToCharMapWebSafe_:this.byteToCharMap_;const output=[];for(let i=0;i<input.length;i+=3){const byte1=input[i];const haveByte2=i+1<input.length;const byte2=haveByte2?input[i+1]:0;const haveByte3=i+2<input.length;const byte3=haveByte3?input[i+2]:0;const outByte1=byte1>>2;const outByte2=(byte1&3)<<4|byte2>>4;let outByte3=(byte2&15)<<2|byte3>>6;let outByte4=byte3&63;if(!haveByte3){outByte4=64;if(!haveByte2){outByte3=64}}output.push(byteToCharMap[outByte1],byteToCharMap[outByte2],byteToCharMap[outByte3],byteToCharMap[outByte4])}return output.join("")},encodeString(input,webSafe){if(this.HAS_NATIVE_SUPPORT&&!webSafe){return btoa(input)}return this.encodeByteArray(stringToByteArray$1(input),webSafe)},decodeString(input,webSafe){if(this.HAS_NATIVE_SUPPORT&&!webSafe){return atob(input)}return byteArrayToString(this.decodeStringToByteArray(input,webSafe))},decodeStringToByteArray(input,webSafe){this.init_();const charToByteMap=webSafe?this.charToByteMapWebSafe_:this.charToByteMap_;const output=[];for(let i=0;i<input.length;){const byte1=charToByteMap[input.charAt(i++)];const haveByte2=i<input.length;const byte2=haveByte2?charToByteMap[input.charAt(i)]:0;++i;const haveByte3=i<input.length;const byte3=haveByte3?charToByteMap[input.charAt(i)]:64;++i;const haveByte4=i<input.length;const byte4=haveByte4?charToByteMap[input.charAt(i)]:64;++i;if(byte1==null||byte2==null||byte3==null||byte4==null){throw new DecodeBase64StringError}const outByte1=byte1<<2|byte2>>4;output.push(outByte1);if(byte3!==64){const outByte2=byte2<<4&240|byte3>>2;output.push(outByte2);if(byte4!==64){const outByte3=byte3<<6&192|byte4;output.push(outByte3)}}}return output},init_(){if(!this.byteToCharMap_){this.byteToCharMap_={};this.charToByteMap_={};this.byteToCharMapWebSafe_={};this.charToByteMapWebSafe_={};for(let i=0;i<this.ENCODED_VALS.length;i++){this.byteToCharMap_[i]=this.ENCODED_VALS.charAt(i);this.charToByteMap_[this.byteToCharMap_[i]]=i;this.byteToCharMapWebSafe_[i]=this.ENCODED_VALS_WEBSAFE.charAt(i);this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]]=i;if(i>=this.ENCODED_VALS_BASE.length){this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)]=i;this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)]=i}}}}};exports.base64=base64;class DecodeBase64StringError extends Error{constructor(){super(...arguments);this.name="DecodeBase64StringError"}}exports.DecodeBase64StringError=DecodeBase64StringError;const base64Encode=function(str){const utf8Bytes=stringToByteArray$1(str);return base64.encodeByteArray(utf8Bytes,true)};exports.base64Encode=base64Encode;const base64urlEncodeWithoutPadding=function(str){return base64Encode(str).replace(/\./g,"")};exports.base64urlEncodeWithoutPadding=base64urlEncodeWithoutPadding;const base64Decode=function(str){try{return base64.decodeString(str,true)}catch(e){console.error("base64Decode failed: ",e)}return null};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.base64Decode=base64Decode;function deepCopy(value){return deepExtend(undefined,value)}function deepExtend(target,source){if(!(source instanceof Object)){return source}switch(source.constructor){case Date:const dateValue=source;return new Date(dateValue.getTime());case Object:if(target===undefined){target={}}break;case Array:target=[];break;default:return source}for(const prop in source){if(!source.hasOwnProperty(prop)||!isValidKey(prop)){continue}target[prop]=deepExtend(target[prop],source[prop])}return target}function isValidKey(key){return key!=="__proto__"}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function getGlobal(){if(typeof self!=="undefined"){return self}if(typeof window!=="undefined"){return window}if(typeof global!=="undefined"){return global}throw new Error("Unable to locate global object.")}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const getDefaultsFromGlobal=()=>getGlobal().__FIREBASE_DEFAULTS__;const getDefaultsFromEnvVariable=()=>{if(typeof process==="undefined"||typeof process.env==="undefined"){return}const defaultsJsonString=process.env.__FIREBASE_DEFAULTS__;if(defaultsJsonString){return JSON.parse(defaultsJsonString)}};const getDefaultsFromCookie=()=>{if(typeof document==="undefined"){return}let match;try{match=document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)}catch(e){return}const decoded=match&&base64Decode(match[1]);return decoded&&JSON.parse(decoded)};const getDefaults=()=>{try{return getDefaultsFromGlobal()||getDefaultsFromEnvVariable()||getDefaultsFromCookie()}catch(e){console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);return}};exports.getDefaults=getDefaults;const getDefaultEmulatorHost=productName=>{var _a,_b;return(_b=(_a=getDefaults())===null||_a===void 0?void 0:_a.emulatorHosts)===null||_b===void 0?void 0:_b[productName]};exports.getDefaultEmulatorHost=getDefaultEmulatorHost;const getDefaultEmulatorHostnameAndPort=productName=>{const host=getDefaultEmulatorHost(productName);if(!host){return undefined}const separatorIndex=host.lastIndexOf(":");if(separatorIndex<=0||separatorIndex+1===host.length){throw new Error(`Invalid host ${host} with no separate hostname and port!`)}const port=parseInt(host.substring(separatorIndex+1),10);if(host[0]==="["){return[host.substring(1,separatorIndex-1),port]}else{return[host.substring(0,separatorIndex),port]}};exports.getDefaultEmulatorHostnameAndPort=getDefaultEmulatorHostnameAndPort;const getDefaultAppConfig=()=>{var _a;return(_a=getDefaults())===null||_a===void 0?void 0:_a.config};exports.getDefaultAppConfig=getDefaultAppConfig;const getExperimentalSetting=name=>{var _a;return(_a=getDefaults())===null||_a===void 0?void 0:_a[`_${name}`]};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.getExperimentalSetting=getExperimentalSetting;class Deferred{constructor(){this.reject=()=>{};this.resolve=()=>{};this.promise=new Promise(((resolve,reject)=>{this.resolve=resolve;this.reject=reject}))}wrapCallback(callback){return(error,value)=>{if(error){this.reject(error)}else{this.resolve(value)}if(typeof callback==="function"){this.promise.catch((()=>{}));if(callback.length===1){callback(error)}else{callback(error,value)}}}}}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.Deferred=Deferred;function createMockUserToken(token,projectId){if(token.uid){throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.')}const header={alg:"none",type:"JWT"};const project=projectId||"demo-project";const iat=token.iat||0;const sub=token.sub||token.user_id;if(!sub){throw new Error("mockUserToken must contain 'sub' or 'user_id' field!")}const payload=Object.assign({iss:`https://securetoken.google.com/${project}`,aud:project,iat:iat,exp:iat+3600,auth_time:iat,sub:sub,user_id:sub,firebase:{sign_in_provider:"custom",identities:{}}},token);const signature="";return[base64urlEncodeWithoutPadding(JSON.stringify(header)),base64urlEncodeWithoutPadding(JSON.stringify(payload)),signature].join(".")}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function getUA(){if(typeof navigator!=="undefined"&&typeof navigator["userAgent"]==="string"){return navigator["userAgent"]}else{return""}}function isMobileCordova(){return typeof window!=="undefined"&&!!(window["cordova"]||window["phonegap"]||window["PhoneGap"])&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA())}function isNode(){var _a;const forceEnvironment=(_a=getDefaults())===null||_a===void 0?void 0:_a.forceEnvironment;if(forceEnvironment==="node"){return true}else if(forceEnvironment==="browser"){return false}try{return Object.prototype.toString.call(global.process)==="[object process]"}catch(e){return false}}function isBrowser(){return typeof self==="object"&&self.self===self}function isBrowserExtension(){const runtime=typeof chrome==="object"?chrome.runtime:typeof browser==="object"?browser.runtime:undefined;return typeof runtime==="object"&&runtime.id!==undefined}function isReactNative(){return typeof navigator==="object"&&navigator["product"]==="ReactNative"}function isElectron(){return getUA().indexOf("Electron/")>=0}function isIE(){const ua=getUA();return ua.indexOf("MSIE ")>=0||ua.indexOf("Trident/")>=0}function isUWP(){return getUA().indexOf("MSAppHost/")>=0}function isNodeSdk(){return CONSTANTS.NODE_CLIENT===true||CONSTANTS.NODE_ADMIN===true}function isSafari(){return!isNode()&&!!navigator.userAgent&&navigator.userAgent.includes("Safari")&&!navigator.userAgent.includes("Chrome")}function isIndexedDBAvailable(){try{return typeof indexedDB==="object"}catch(e){return false}}function validateIndexedDBOpenable(){return new Promise(((resolve,reject)=>{try{let preExist=true;const DB_CHECK_NAME="validate-browser-context-for-indexeddb-analytics-module";const request=self.indexedDB.open(DB_CHECK_NAME);request.onsuccess=()=>{request.result.close();if(!preExist){self.indexedDB.deleteDatabase(DB_CHECK_NAME)}resolve(true)};request.onupgradeneeded=()=>{preExist=false};request.onerror=()=>{var _a;reject(((_a=request.error)===null||_a===void 0?void 0:_a.message)||"")}}catch(error){reject(error)}}))}function areCookiesEnabled(){if(typeof navigator==="undefined"||!navigator.cookieEnabled){return false}return true}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ERROR_NAME="FirebaseError";class FirebaseError extends Error{constructor(code,message,customData){super(message);this.code=code;this.customData=customData;this.name=ERROR_NAME;Object.setPrototypeOf(this,FirebaseError.prototype);if(Error.captureStackTrace){Error.captureStackTrace(this,ErrorFactory.prototype.create)}}}exports.FirebaseError=FirebaseError;class ErrorFactory{constructor(service,serviceName,errors){this.service=service;this.serviceName=serviceName;this.errors=errors}create(code,...data){const customData=data[0]||{};const fullCode=`${this.service}/${code}`;const template=this.errors[code];const message=template?replaceTemplate(template,customData):"Error";const fullMessage=`${this.serviceName}: ${message} (${fullCode}).`;const error=new FirebaseError(fullCode,fullMessage,customData);return error}}exports.ErrorFactory=ErrorFactory;function replaceTemplate(template,data){return template.replace(PATTERN,((_,key)=>{const value=data[key];return value!=null?String(value):`<${key}?>`}))}const PATTERN=/\{\$([^}]+)}/g;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function jsonEval(str){return JSON.parse(str)}function stringify(data){return JSON.stringify(data)}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const decode=function(token){let header={},claims={},data={},signature="";try{const parts=token.split(".");header=jsonEval(base64Decode(parts[0])||"");claims=jsonEval(base64Decode(parts[1])||"");signature=parts[2];data=claims["d"]||{};delete claims["d"]}catch(e){}return{header:header,claims:claims,data:data,signature:signature}};exports.decode=decode;const isValidTimestamp=function(token){const claims=decode(token).claims;const now=Math.floor((new Date).getTime()/1e3);let validSince=0,validUntil=0;if(typeof claims==="object"){if(claims.hasOwnProperty("nbf")){validSince=claims["nbf"]}else if(claims.hasOwnProperty("iat")){validSince=claims["iat"]}if(claims.hasOwnProperty("exp")){validUntil=claims["exp"]}else{validUntil=validSince+86400}}return!!now&&!!validSince&&!!validUntil&&now>=validSince&&now<=validUntil};exports.isValidTimestamp=isValidTimestamp;const issuedAtTime=function(token){const claims=decode(token).claims;if(typeof claims==="object"&&claims.hasOwnProperty("iat")){return claims["iat"]}return null};exports.issuedAtTime=issuedAtTime;const isValidFormat=function(token){const decoded=decode(token),claims=decoded.claims;return!!claims&&typeof claims==="object"&&claims.hasOwnProperty("iat")};exports.isValidFormat=isValidFormat;const isAdmin=function(token){const claims=decode(token).claims;return typeof claims==="object"&&claims["admin"]===true};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.isAdmin=isAdmin;function contains(obj,key){return Object.prototype.hasOwnProperty.call(obj,key)}function safeGet(obj,key){if(Object.prototype.hasOwnProperty.call(obj,key)){return obj[key]}else{return undefined}}function isEmpty(obj){for(const key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){return false}}return true}function map(obj,fn,contextObj){const res={};for(const key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){res[key]=fn.call(contextObj,obj[key],key,obj)}}return res}function deepEqual(a,b){if(a===b){return true}const aKeys=Object.keys(a);const bKeys=Object.keys(b);for(const k of aKeys){if(!bKeys.includes(k)){return false}const aProp=a[k];const bProp=b[k];if(isObject(aProp)&&isObject(bProp)){if(!deepEqual(aProp,bProp)){return false}}else if(aProp!==bProp){return false}}for(const k of bKeys){if(!aKeys.includes(k)){return false}}return true}function isObject(thing){return thing!==null&&typeof thing==="object"}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function promiseWithTimeout(promise,timeInMS=2e3){const deferredPromise=new Deferred;setTimeout((()=>deferredPromise.reject("timeout!")),timeInMS);promise.then(deferredPromise.resolve,deferredPromise.reject);return deferredPromise.promise}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function querystring(querystringParams){const params=[];for(const[key,value]of Object.entries(querystringParams)){if(Array.isArray(value)){value.forEach((arrayVal=>{params.push(encodeURIComponent(key)+"="+encodeURIComponent(arrayVal))}))}else{params.push(encodeURIComponent(key)+"="+encodeURIComponent(value))}}return params.length?"&"+params.join("&"):""}function querystringDecode(querystring){const obj={};const tokens=querystring.replace(/^\?/,"").split("&");tokens.forEach((token=>{if(token){const[key,value]=token.split("=");obj[decodeURIComponent(key)]=decodeURIComponent(value)}}));return obj}function extractQuerystring(url){const queryStart=url.indexOf("?");if(!queryStart){return""}const fragmentStart=url.indexOf("#",queryStart);return url.substring(queryStart,fragmentStart>0?fragmentStart:undefined)}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Sha1{constructor(){this.chain_=[];this.buf_=[];this.W_=[];this.pad_=[];this.inbuf_=0;this.total_=0;this.blockSize=512/8;this.pad_[0]=128;for(let i=1;i<this.blockSize;++i){this.pad_[i]=0}this.reset()}reset(){this.chain_[0]=1732584193;this.chain_[1]=4023233417;this.chain_[2]=2562383102;this.chain_[3]=271733878;this.chain_[4]=3285377520;this.inbuf_=0;this.total_=0}compress_(buf,offset){if(!offset){offset=0}const W=this.W_;if(typeof buf==="string"){for(let i=0;i<16;i++){W[i]=buf.charCodeAt(offset)<<24|buf.charCodeAt(offset+1)<<16|buf.charCodeAt(offset+2)<<8|buf.charCodeAt(offset+3);offset+=4}}else{for(let i=0;i<16;i++){W[i]=buf[offset]<<24|buf[offset+1]<<16|buf[offset+2]<<8|buf[offset+3];offset+=4}}for(let i=16;i<80;i++){const t=W[i-3]^W[i-8]^W[i-14]^W[i-16];W[i]=(t<<1|t>>>31)&4294967295}let a=this.chain_[0];let b=this.chain_[1];let c=this.chain_[2];let d=this.chain_[3];let e=this.chain_[4];let f,k;for(let i=0;i<80;i++){if(i<40){if(i<20){f=d^b&(c^d);k=1518500249}else{f=b^c^d;k=1859775393}}else{if(i<60){f=b&c|d&(b|c);k=2400959708}else{f=b^c^d;k=3395469782}}const t=(a<<5|a>>>27)+f+e+k+W[i]&4294967295;e=d;d=c;c=(b<<30|b>>>2)&4294967295;b=a;a=t}this.chain_[0]=this.chain_[0]+a&4294967295;this.chain_[1]=this.chain_[1]+b&4294967295;this.chain_[2]=this.chain_[2]+c&4294967295;this.chain_[3]=this.chain_[3]+d&4294967295;this.chain_[4]=this.chain_[4]+e&4294967295}update(bytes,length){if(bytes==null){return}if(length===undefined){length=bytes.length}const lengthMinusBlock=length-this.blockSize;let n=0;const buf=this.buf_;let inbuf=this.inbuf_;while(n<length){if(inbuf===0){while(n<=lengthMinusBlock){this.compress_(bytes,n);n+=this.blockSize}}if(typeof bytes==="string"){while(n<length){buf[inbuf]=bytes.charCodeAt(n);++inbuf;++n;if(inbuf===this.blockSize){this.compress_(buf);inbuf=0;break}}}else{while(n<length){buf[inbuf]=bytes[n];++inbuf;++n;if(inbuf===this.blockSize){this.compress_(buf);inbuf=0;break}}}}this.inbuf_=inbuf;this.total_+=length}digest(){const digest=[];let totalBits=this.total_*8;if(this.inbuf_<56){this.update(this.pad_,56-this.inbuf_)}else{this.update(this.pad_,this.blockSize-(this.inbuf_-56))}for(let i=this.blockSize-1;i>=56;i--){this.buf_[i]=totalBits&255;totalBits/=256}this.compress_(this.buf_);let n=0;for(let i=0;i<5;i++){for(let j=24;j>=0;j-=8){digest[n]=this.chain_[i]>>j&255;++n}}return digest}}exports.Sha1=Sha1;function createSubscribe(executor,onNoObservers){const proxy=new ObserverProxy(executor,onNoObservers);return proxy.subscribe.bind(proxy)}class ObserverProxy{constructor(executor,onNoObservers){this.observers=[];this.unsubscribes=[];this.observerCount=0;this.task=Promise.resolve();this.finalized=false;this.onNoObservers=onNoObservers;this.task.then((()=>{executor(this)})).catch((e=>{this.error(e)}))}next(value){this.forEachObserver((observer=>{observer.next(value)}))}error(error){this.forEachObserver((observer=>{observer.error(error)}));this.close(error)}complete(){this.forEachObserver((observer=>{observer.complete()}));this.close()}subscribe(nextOrObserver,error,complete){let observer;if(nextOrObserver===undefined&&error===undefined&&complete===undefined){throw new Error("Missing Observer.")}if(implementsAnyMethods(nextOrObserver,["next","error","complete"])){observer=nextOrObserver}else{observer={next:nextOrObserver,error:error,complete:complete}}if(observer.next===undefined){observer.next=noop}if(observer.error===undefined){observer.error=noop}if(observer.complete===undefined){observer.complete=noop}const unsub=this.unsubscribeOne.bind(this,this.observers.length);if(this.finalized){this.task.then((()=>{try{if(this.finalError){observer.error(this.finalError)}else{observer.complete()}}catch(e){}return}))}this.observers.push(observer);return unsub}unsubscribeOne(i){if(this.observers===undefined||this.observers[i]===undefined){return}delete this.observers[i];this.observerCount-=1;if(this.observerCount===0&&this.onNoObservers!==undefined){this.onNoObservers(this)}}forEachObserver(fn){if(this.finalized){return}for(let i=0;i<this.observers.length;i++){this.sendOne(i,fn)}}sendOne(i,fn){this.task.then((()=>{if(this.observers!==undefined&&this.observers[i]!==undefined){try{fn(this.observers[i])}catch(e){if(typeof console!=="undefined"&&console.error){console.error(e)}}}}))}close(err){if(this.finalized){return}this.finalized=true;if(err!==undefined){this.finalError=err}this.task.then((()=>{this.observers=undefined;this.onNoObservers=undefined}))}}function async(fn,onError){return(...args)=>{Promise.resolve(true).then((()=>{fn(...args)})).catch((error=>{if(onError){onError(error)}}))}}function implementsAnyMethods(obj,methods){if(typeof obj!=="object"||obj===null){return false}for(const method of methods){if(method in obj&&typeof obj[method]==="function"){return true}}return false}function noop(){}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const validateArgCount=function(fnName,minCount,maxCount,argCount){let argError;if(argCount<minCount){argError="at least "+minCount}else if(argCount>maxCount){argError=maxCount===0?"none":"no more than "+maxCount}if(argError){const error=fnName+" failed: Was called with "+argCount+(argCount===1?" argument.":" arguments.")+" Expects "+argError+".";throw new Error(error)}};exports.validateArgCount=validateArgCount;function errorPrefix(fnName,argName){return`${fnName} failed: ${argName} argument `}function validateNamespace(fnName,namespace,optional){if(optional&&!namespace){return}if(typeof namespace!=="string"){throw new Error(errorPrefix(fnName,"namespace")+"must be a valid firebase namespace.")}}function validateCallback(fnName,argumentName,callback,optional){if(optional&&!callback){return}if(typeof callback!=="function"){throw new Error(errorPrefix(fnName,argumentName)+"must be a valid function.")}}function validateContextObject(fnName,argumentName,context,optional){if(optional&&!context){return}if(typeof context!=="object"||context===null){throw new Error(errorPrefix(fnName,argumentName)+"must be a valid context object.")}}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const stringToByteArray=function(str){const out=[];let p=0;for(let i=0;i<str.length;i++){let c=str.charCodeAt(i);if(c>=55296&&c<=56319){const high=c-55296;i++;assert(i<str.length,"Surrogate pair missing trail surrogate.");const low=str.charCodeAt(i)-56320;c=65536+(high<<10)+low}if(c<128){out[p++]=c}else if(c<2048){out[p++]=c>>6|192;out[p++]=c&63|128}else if(c<65536){out[p++]=c>>12|224;out[p++]=c>>6&63|128;out[p++]=c&63|128}else{out[p++]=c>>18|240;out[p++]=c>>12&63|128;out[p++]=c>>6&63|128;out[p++]=c&63|128}}return out};exports.stringToByteArray=stringToByteArray;const stringLength=function(str){let p=0;for(let i=0;i<str.length;i++){const c=str.charCodeAt(i);if(c<128){p++}else if(c<2048){p+=2}else if(c>=55296&&c<=56319){p+=4;i++}else{p+=3}}return p};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.stringLength=stringLength;const uuidv4=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(c=>{const r=Math.random()*16|0,v=c==="x"?r:r&3|8;return v.toString(16)}))};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.uuidv4=uuidv4;const DEFAULT_INTERVAL_MILLIS=1e3;const DEFAULT_BACKOFF_FACTOR=2;const MAX_VALUE_MILLIS=4*60*60*1e3;exports.MAX_VALUE_MILLIS=MAX_VALUE_MILLIS;const RANDOM_FACTOR=.5;exports.RANDOM_FACTOR=RANDOM_FACTOR;function calculateBackoffMillis(backoffCount,intervalMillis=DEFAULT_INTERVAL_MILLIS,backoffFactor=DEFAULT_BACKOFF_FACTOR){const currBaseValue=intervalMillis*Math.pow(backoffFactor,backoffCount);const randomWait=Math.round(RANDOM_FACTOR*currBaseValue*(Math.random()-.5)*2);return Math.min(MAX_VALUE_MILLIS,currBaseValue+randomWait)}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function ordinal(i){if(!Number.isFinite(i)){return`${i}`}return i+indicator(i)}function indicator(i){i=Math.abs(i);const cent=i%100;if(cent>=10&&cent<=20){return"th"}const dec=i%10;if(dec===1){return"st"}if(dec===2){return"nd"}if(dec===3){return"rd"}return"th"}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function getModularInstance(service){if(service&&service._delegate){return service._delegate}else{return service}}}).call(this)}).call(this,require("_process"),typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{_process:1}],13:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});Object.defineProperty(exports,"default",{enumerable:true,get:function(){return _appCompat.default}});var _appCompat=_interopRequireDefault(require("@firebase/app-compat"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var name="firebase";var version="10.11.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */_appCompat.default.registerVersion(name,version,"app-compat")},{"@firebase/app-compat":3}],14:[function(require,module,exports){"use strict";require("@firebase/auth-compat")},{"@firebase/auth-compat":5}],15:[function(require,module,exports){"use strict";require("@firebase/database-compat")},{"@firebase/database-compat":9}],16:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.deleteDB=deleteDB;exports.openDB=openDB;Object.defineProperty(exports,"unwrap",{enumerable:true,get:function(){return _wrapIdbValue.u}});Object.defineProperty(exports,"wrap",{enumerable:true,get:function(){return _wrapIdbValue.w}});var _wrapIdbValue=require("./wrap-idb-value.js");function openDB(name,version,{blocked:blocked,upgrade:upgrade,blocking:blocking,terminated:terminated}={}){const request=indexedDB.open(name,version);const openPromise=(0,_wrapIdbValue.w)(request);if(upgrade){request.addEventListener("upgradeneeded",(event=>{upgrade((0,_wrapIdbValue.w)(request.result),event.oldVersion,event.newVersion,(0,_wrapIdbValue.w)(request.transaction),event)}))}if(blocked){request.addEventListener("blocked",(event=>blocked(event.oldVersion,event.newVersion,event)))}openPromise.then((db=>{if(terminated)db.addEventListener("close",(()=>terminated()));if(blocking){db.addEventListener("versionchange",(event=>blocking(event.oldVersion,event.newVersion,event)))}})).catch((()=>{}));return openPromise}function deleteDB(name,{blocked:blocked}={}){const request=indexedDB.deleteDatabase(name);if(blocked){request.addEventListener("blocked",(event=>blocked(event.oldVersion,event)))}return(0,_wrapIdbValue.w)(request).then((()=>undefined))}const readMethods=["get","getKey","getAll","getAllKeys","count"];const writeMethods=["put","add","delete","clear"];const cachedMethods=new Map;function getMethod(target,prop){if(!(target instanceof IDBDatabase&&!(prop in target)&&typeof prop==="string")){return}if(cachedMethods.get(prop))return cachedMethods.get(prop);const targetFuncName=prop.replace(/FromIndex$/,"");const useIndex=prop!==targetFuncName;const isWrite=writeMethods.includes(targetFuncName);if(!(targetFuncName in(useIndex?IDBIndex:IDBObjectStore).prototype)||!(isWrite||readMethods.includes(targetFuncName))){return}const method=async function(storeName,...args){const tx=this.transaction(storeName,isWrite?"readwrite":"readonly");let target=tx.store;if(useIndex)target=target.index(args.shift());return(await Promise.all([target[targetFuncName](...args),isWrite&&tx.done]))[0]};cachedMethods.set(prop,method);return method}(0,_wrapIdbValue.r)((oldTraps=>({...oldTraps,get:(target,prop,receiver)=>getMethod(target,prop)||oldTraps.get(target,prop,receiver),has:(target,prop)=>!!getMethod(target,prop)||oldTraps.has(target,prop)})))},{"./wrap-idb-value.js":17}],17:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.i=exports.a=void 0;exports.r=replaceTraps;exports.u=void 0;exports.w=wrap;const instanceOfAny=(object,constructors)=>constructors.some((c=>object instanceof c));exports.i=instanceOfAny;let idbProxyableTypes;let cursorAdvanceMethods;function getIdbProxyableTypes(){return idbProxyableTypes||(idbProxyableTypes=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function getCursorAdvanceMethods(){return cursorAdvanceMethods||(cursorAdvanceMethods=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const cursorRequestMap=new WeakMap;const transactionDoneMap=new WeakMap;const transactionStoreNamesMap=new WeakMap;const transformCache=new WeakMap;const reverseTransformCache=new WeakMap;exports.a=reverseTransformCache;function promisifyRequest(request){const promise=new Promise(((resolve,reject)=>{const unlisten=()=>{request.removeEventListener("success",success);request.removeEventListener("error",error)};const success=()=>{resolve(wrap(request.result));unlisten()};const error=()=>{reject(request.error);unlisten()};request.addEventListener("success",success);request.addEventListener("error",error)}));promise.then((value=>{if(value instanceof IDBCursor){cursorRequestMap.set(value,request)}})).catch((()=>{}));reverseTransformCache.set(promise,request);return promise}function cacheDonePromiseForTransaction(tx){if(transactionDoneMap.has(tx))return;const done=new Promise(((resolve,reject)=>{const unlisten=()=>{tx.removeEventListener("complete",complete);tx.removeEventListener("error",error);tx.removeEventListener("abort",error)};const complete=()=>{resolve();unlisten()};const error=()=>{reject(tx.error||new DOMException("AbortError","AbortError"));unlisten()};tx.addEventListener("complete",complete);tx.addEventListener("error",error);tx.addEventListener("abort",error)}));transactionDoneMap.set(tx,done)}let idbProxyTraps={get(target,prop,receiver){if(target instanceof IDBTransaction){if(prop==="done")return transactionDoneMap.get(target);if(prop==="objectStoreNames"){return target.objectStoreNames||transactionStoreNamesMap.get(target)}if(prop==="store"){return receiver.objectStoreNames[1]?undefined:receiver.objectStore(receiver.objectStoreNames[0])}}return wrap(target[prop])},set(target,prop,value){target[prop]=value;return true},has(target,prop){if(target instanceof IDBTransaction&&(prop==="done"||prop==="store")){return true}return prop in target}};function replaceTraps(callback){idbProxyTraps=callback(idbProxyTraps)}function wrapFunction(func){if(func===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)){return function(storeNames,...args){const tx=func.call(unwrap(this),storeNames,...args);transactionStoreNamesMap.set(tx,storeNames.sort?storeNames.sort():[storeNames]);return wrap(tx)}}if(getCursorAdvanceMethods().includes(func)){return function(...args){func.apply(unwrap(this),args);return wrap(cursorRequestMap.get(this))}}return function(...args){return wrap(func.apply(unwrap(this),args))}}function transformCachableValue(value){if(typeof value==="function")return wrapFunction(value);if(value instanceof IDBTransaction)cacheDonePromiseForTransaction(value);if(instanceOfAny(value,getIdbProxyableTypes()))return new Proxy(value,idbProxyTraps);return value}function wrap(value){if(value instanceof IDBRequest)return promisifyRequest(value);if(transformCache.has(value))return transformCache.get(value);const newValue=transformCachableValue(value);if(newValue!==value){transformCache.set(value,newValue);reverseTransformCache.set(newValue,value)}return newValue}const unwrap=value=>reverseTransformCache.get(value);exports.u=unwrap},{}],18:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.__assign=void 0;exports.__asyncDelegator=__asyncDelegator;exports.__asyncGenerator=__asyncGenerator;exports.__asyncValues=__asyncValues;exports.__await=__await;exports.__awaiter=__awaiter;exports.__classPrivateFieldGet=__classPrivateFieldGet;exports.__classPrivateFieldIn=__classPrivateFieldIn;exports.__classPrivateFieldSet=__classPrivateFieldSet;exports.__createBinding=void 0;exports.__decorate=__decorate;exports.__exportStar=__exportStar;exports.__extends=__extends;exports.__generator=__generator;exports.__importDefault=__importDefault;exports.__importStar=__importStar;exports.__makeTemplateObject=__makeTemplateObject;exports.__metadata=__metadata;exports.__param=__param;exports.__read=__read;exports.__rest=__rest;exports.__spread=__spread;exports.__spreadArray=__spreadArray;exports.__spreadArrays=__spreadArrays;exports.__values=__values;var extendStatics=function(d,b){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(Object.prototype.hasOwnProperty.call(b,p))d[p]=b[p]};return extendStatics(d,b)};function __extends(d,b){if(typeof b!=="function"&&b!==null)throw new TypeError("Class extends value "+String(b)+" is not a constructor or null");extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}var __assign=function(){exports.__assign=__assign=Object.assign||function __assign(t){for(var s,i=1,n=arguments.length;i<n;i++){s=arguments[i];for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p))t[p]=s[p]}return t};return __assign.apply(this,arguments)};exports.__assign=__assign;function __rest(s,e){var t={};for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0)t[p]=s[p];if(s!=null&&typeof Object.getOwnPropertySymbols==="function")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++){if(e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i]))t[p[i]]=s[p[i]]}return t}function __decorate(decorators,target,key,desc){var c=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")r=Reflect.decorate(decorators,target,key,desc);else for(var i=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;return c>3&&r&&Object.defineProperty(target,key,r),r}function __param(paramIndex,decorator){return function(target,key){decorator(target,key,paramIndex)}}function __metadata(metadataKey,metadataValue){if(typeof Reflect==="object"&&typeof Reflect.metadata==="function")return Reflect.metadata(metadataKey,metadataValue)}function __awaiter(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P((function(resolve){resolve(value)}))}return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))}function __generator(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(g&&(g=0,op[0]&&(_=0)),_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e];y=0}finally{f=t=0}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true}}}var __createBinding=Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||("get"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function(){return m[k]}}}Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k]};exports.__createBinding=__createBinding;function __exportStar(m,o){for(var p in m)if(p!=="default"&&!Object.prototype.hasOwnProperty.call(o,p))__createBinding(o,m,p)}function __values(o){var s=typeof Symbol==="function"&&Symbol.iterator,m=s&&o[s],i=0;if(m)return m.call(o);if(o&&typeof o.length==="number")return{next:function(){if(o&&i>=o.length)o=void 0;return{value:o&&o[i++],done:!o}}};throw new TypeError(s?"Object is not iterable.":"Symbol.iterator is not defined.")}function __read(o,n){var m=typeof Symbol==="function"&&o[Symbol.iterator];if(!m)return o;var i=m.call(o),r,ar=[],e;try{while((n===void 0||n-- >0)&&!(r=i.next()).done)ar.push(r.value)}catch(error){e={error:error}}finally{try{if(r&&!r.done&&(m=i["return"]))m.call(i)}finally{if(e)throw e.error}}return ar}function __spread(){for(var ar=[],i=0;i<arguments.length;i++)ar=ar.concat(__read(arguments[i]));return ar}function __spreadArrays(){for(var s=0,i=0,il=arguments.length;i<il;i++)s+=arguments[i].length;for(var r=Array(s),k=0,i=0;i<il;i++)for(var a=arguments[i],j=0,jl=a.length;j<jl;j++,k++)r[k]=a[j];return r}function __spreadArray(to,from,pack){if(pack||arguments.length===2)for(var i=0,l=from.length,ar;i<l;i++){if(ar||!(i in from)){if(!ar)ar=Array.prototype.slice.call(from,0,i);ar[i]=from[i]}}return to.concat(ar||Array.prototype.slice.call(from))}function __await(v){return this instanceof __await?(this.v=v,this):new __await(v)}function __asyncGenerator(thisArg,_arguments,generator){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var g=generator.apply(thisArg,_arguments||[]),i,q=[];return i={},verb("next"),verb("throw"),verb("return"),i[Symbol.asyncIterator]=function(){return this},i;function verb(n){if(g[n])i[n]=function(v){return new Promise((function(a,b){q.push([n,v,a,b])>1||resume(n,v)}))}}function resume(n,v){try{step(g[n](v))}catch(e){settle(q[0][3],e)}}function step(r){r.value instanceof __await?Promise.resolve(r.value.v).then(fulfill,reject):settle(q[0][2],r)}function fulfill(value){resume("next",value)}function reject(value){resume("throw",value)}function settle(f,v){if(f(v),q.shift(),q.length)resume(q[0][0],q[0][1])}}function __asyncDelegator(o){var i,p;return i={},verb("next"),verb("throw",(function(e){throw e})),verb("return"),i[Symbol.iterator]=function(){return this},i;function verb(n,f){i[n]=o[n]?function(v){return(p=!p)?{value:__await(o[n](v)),done:n==="return"}:f?f(v):v}:f}}function __asyncValues(o){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var m=o[Symbol.asyncIterator],i;return m?m.call(o):(o=typeof __values==="function"?__values(o):o[Symbol.iterator](),i={},verb("next"),verb("throw"),verb("return"),i[Symbol.asyncIterator]=function(){return this},i);function verb(n){i[n]=o[n]&&function(v){return new Promise((function(resolve,reject){v=o[n](v),settle(resolve,reject,v.done,v.value)}))}}function settle(resolve,reject,d,v){Promise.resolve(v).then((function(v){resolve({value:v,done:d})}),reject)}}function __makeTemplateObject(cooked,raw){if(Object.defineProperty){Object.defineProperty(cooked,"raw",{value:raw})}else{cooked.raw=raw}return cooked}var __setModuleDefault=Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:true,value:v})}:function(o,v){o["default"]=v};function __importStar(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!=="default"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result}function __importDefault(mod){return mod&&mod.__esModule?mod:{default:mod}}function __classPrivateFieldGet(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)}function __classPrivateFieldSet(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value}function __classPrivateFieldIn(state,receiver){if(receiver===null||typeof receiver!=="object"&&typeof receiver!=="function")throw new TypeError("Cannot use 'in' operator on non-object");return typeof state==="function"?receiver===state:state.has(receiver)}},{}]},{},[2])(2)}));